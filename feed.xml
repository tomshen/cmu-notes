<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Notes</title>
    <description>Notes on classes at CMU.
</description>
    <link>http://www.tomshen.me/notes/</link>
    <atom:link href="http://www.tomshen.me/notes/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 09 Apr 2015 14:46:39 -0400</pubDate>
    <lastBuildDate>Thu, 09 Apr 2015 14:46:39 -0400</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>15-312 Lecture 23: Concurrency &amp; Interaction</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}
\def\a{\alpha}
\def\b{\beta}
\def\t{\tau}
$$
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Delivered by Bob Harper&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We’re going to discuss &lt;strong&gt;abstract process calculus&lt;/strong&gt;, which is derived from &lt;script type=&quot;math/tex&quot;&gt;\pi&lt;/script&gt;-calculus. The key idea is &lt;em&gt;interacting automata&lt;/em&gt;. We will introduce concurrency to Modernized Algol, creating &lt;em&gt;Concurrent Algol&lt;/em&gt;, thus applying process calculus to a “real” programming language.&lt;/p&gt;

&lt;p&gt;What is concurrency? It’s unrelated to parallelism. Instead, it’s really about &lt;em&gt;composition&lt;/em&gt;, and non-determinism (Bob Harper prefers &lt;em&gt;indeterminacy&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Our starting point is consideration of processes as automata. One example is Milner’s vending machine. We have an automata for the vending machine &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt;, and an automata for the person using it &lt;script type=&quot;math/tex&quot;&gt;U&lt;/script&gt;. They interact concurrently (&lt;script type=&quot;math/tex&quot;&gt;V \| U&lt;/script&gt;), since the person loses money as they put it into the machine, and when the machine dispenses a drink, the person gains a drink.&lt;/p&gt;

&lt;h1 id=&quot;process-notation&quot;&gt;Process Notation&lt;/h1&gt;
&lt;p&gt;We have a primitive called &lt;script type=&quot;math/tex&quot;&gt;\m{await}(E)&lt;/script&gt;, for awaiting events. It can also be represented with &lt;script type=&quot;math/tex&quot;&gt;\$E&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;?a.P&lt;/script&gt; represents receiving events. &lt;script type=&quot;math/tex&quot;&gt;P&lt;/script&gt; represents a process. &lt;script type=&quot;math/tex&quot;&gt;!a.P&lt;/script&gt; represents sending events. Note these are symmetric, in the sense that we could switch their meanings. &lt;script type=&quot;math/tex&quot;&gt;E_1 + E_2&lt;/script&gt; represents a binary sum, or a binary choice, between events. &lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt; represents the null choice, or no choice.&lt;/p&gt;

&lt;p&gt;We can represent &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;U&lt;/script&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;V = \$(?2p.\$(!tea.V + ?2p.(\$(!coffee.V))))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;U = \$(!2p . \$(!2p . \$(?coffee.U)))&lt;/script&gt;

&lt;p&gt;Note that these are cursive, so some equation solving is required. We want a fixed point.&lt;/p&gt;

&lt;h1 id=&quot;structural-congruence&quot;&gt;Structural Congruence&lt;/h1&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;P \equiv P&#39;&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;E \equiv E&#39;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Structural congruence&lt;/strong&gt; is an equivalence relation that is compaible with all the constructs of the language. The idea is to treat processes and events modulo structural congruence. &lt;script type=&quot;math/tex&quot;&gt;\alpha&lt;/script&gt;-equivalence is structural equivalence. We want the order of events to not matter.&lt;/p&gt;

&lt;p&gt;We have commutivity: &lt;script type=&quot;math/tex&quot;&gt;E_1 + E_2 \equiv E_2 + E_1&lt;/script&gt;, associativity: &lt;script type=&quot;math/tex&quot;&gt;E_1 + (E_2 + E_3) \equiv (E_1 + E_2) + E_3&lt;/script&gt;, and unit &lt;script type=&quot;math/tex&quot;&gt;E + 0 \equiv E \equiv 0 + E&lt;/script&gt;. Thus, we have a commutative monoid (additivity).&lt;/p&gt;

&lt;h1 id=&quot;composition&quot;&gt;Composition&lt;/h1&gt;
&lt;p&gt;We’re going to think about of our processors as get/set servers for assignables. &lt;script type=&quot;math/tex&quot;&gt;P_1 \parallel P_2&lt;/script&gt; (or “tensor” &lt;script type=&quot;math/tex&quot;&gt;P_1 \otimes P_2&lt;/script&gt;) represents concurrrent composition. 1 represents inert composition. The order of processes doesn’t matter. This is another commutative monoid (multiplicative).&lt;/p&gt;

&lt;p&gt;The main missing thing is distributivity, so we don’t have a ring.&lt;/p&gt;

&lt;h1 id=&quot;normal-form&quot;&gt;Normal Form&lt;/h1&gt;
&lt;p&gt;Every process is sturcturally congruent to one of the form&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\$E_1 \parallel \cdots \parallel \$E_n&lt;/script&gt;

&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;n \geq 0&lt;/script&gt;. That is, it’s a bunch of automata in “a big pot of (matzoh ball) soup.” The multiplicative structure corresponds to “Brownian motion,” letting “the soup boil.”&lt;/p&gt;

&lt;h1 id=&quot;dynamicsinteraction-between-processes&quot;&gt;Dynamics—interaction between processes&lt;/h1&gt;
&lt;p&gt;We have a labelled transition system:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
P \mapsto^{\epsilon} P&#39; &amp; \alpha  ::= a? &amp; \text{receive action} \\
P \mapsto^{\alpha} P&#39; &amp; |  a! &amp; \text{send action} \\
&amp; |  \epsilon &amp; \text{null action}
\end{align} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;V \overset{2p?}{\mapsto} V&#39; \overset{2p?}{\mapsto} V&#39;&#39; \overset{coffee!}{\mapsto} V&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;V&#39; \overset{tea!}{\mapsto} V&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;U \overset{2p!}{\mapsto} U&#39; \overset{2p!}{\mapsto} \ \overset{coffee?}{\mapsto} U&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{P_1 \equiv P_1&#39; \overset{\alpha}{\mapsto} P_2&#39; \equiv P_2}
{P_1 \overset{\alpha}{\mapsto} P_2}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\$(a.P + E) \overset{a?}{\mapsto} P&lt;/script&gt;

&lt;p&gt;Note that &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; is lost. A non-deterministic choice is made.&lt;/p&gt;

&lt;p&gt;The framing principle is that a process takes the same action regardless of “who’s watching.” Thus, if you have several processors, you can have two of them interact in parallel without affecting the others.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    P_1
    \overset{\alpha}{\mapsto}
    P_1&#39;
}{
    P_1 \parallel P_2 \overset{\alpha}{\mapsto} P_1&#39; \parallel P_2
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    P_1 \overset{\alpha}{\mapsto} P_1&#39; ~~~~
    P_2 \overset{\overline{\alpha}}{\mapsto} P_2&#39;
}{
    P_1 \parallel P_2 \mapsto P_1&#39; \parallel P_2&#39;
}&lt;/script&gt;

&lt;p&gt;This rule allows for interaction. Thus, the user can get a coffee at the same time the vending machine sends a coffee.&lt;/p&gt;

&lt;h1 id=&quot;replication&quot;&gt;Replication&lt;/h1&gt;
&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;*P \equiv *P \parallel P&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;*P&lt;/script&gt; is any number of copies of &lt;script type=&quot;math/tex&quot;&gt;P&lt;/script&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;accept recursive definitions as given&lt;/li&gt;
  &lt;li&gt;reduce to replication &amp;amp; synchronization&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The activator waits for the assert to arrive, and activates &lt;script type=&quot;math/tex&quot;&gt;P&lt;/script&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A = *\$(?a.P(\$(!a.1))) \equiv A&#39; \parallel A&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A&#39; = \$(?a.P(\$(!a.1)))&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\$(!a.1)&lt;/script&gt; is the “spark” to activate the next &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;.&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Apr 2015 13:30:34 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/04/09/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/04/09/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 22: Exceptions, Continuations</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}
\def\a{\alpha}
\def\b{\beta}
\def\t{\tau}
\def\emp{\cdotp}

\def\natt{\m{nat}}
\def\unit{\m{unit}}
\def\exn{\m{exn}}
\def\prove{\vdash}
\def\typet{\m{type}}

\def\fail{\m{fail}}
\renewcommand\catch[2]{\m{catch}~#1~\m{ow}~#2}

\renewcommand\raiset[2]{\m{raise}_{#1}~#2}
\renewcommand\raise[1]{\m{raise}~#1}
\renewcommand\handle[3]{\m{handle}~#1~\m{ow}~#2.#3}

\def\defeq{\overset{def}{=}}

\renewcommand\ifz[4]{\m{ifz}(#1 ; #2 ; #3 . #4)}

\renewcommand\clsfdt{\m{clsfd}}
\renewcommand\classt[1]{\m{class}(#1)}
\renewcommand\newcls[1]{\m{newcls}[#1]}
\renewcommand\mk[2]{\m{mk}(#1;#2)}
\renewcommand\isofcls[5]{\m{isofcls}(#1;#2;#3.#4;#5)}
$$
&lt;/div&gt;

&lt;h1 id=&quot;control-operators-continued&quot;&gt;Control Operators (continued)&lt;/h1&gt;

&lt;h2 id=&quot;exceptions-continued&quot;&gt;Exceptions (continued)&lt;/h2&gt;

&lt;p&gt;We introduced classified terms, which are exceptions in ML.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\t &amp; ::= \cdots \mid \clsfdt \mid \classt{\t} \\
e &amp; ::= \cdots \mid \newcls{\t} \mid \mk{e}{e} \mid \isofcls{e}{e}{x}{e}{e}
\end{align} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
\ctx \prove e : \classt{\t} \qquad \ctx \prove e&#39;:\t
}{
\ctx \prove \mk{e}{e&#39;} : \clsfdt
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
\ctx \prove e_0 : \classt{\t} \qquad \ctx \prove e_1 : \clsfdt \qquad \ctx, x : \t \prove e_2 : \t&#39; \qquad \ctx \prove e_3 : \t&#39;
}{
\ctx \prove \isofcls{e_0}{e_1}{x}{e_2}{e_3} : \t&#39;
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
\ctx \prove \t : \typet
}{
\newcls{\t} : \classt{\t}
}&lt;/script&gt;

&lt;p&gt;This system is more powerful than ML’s exceptions. Here’s a way to implement it in ML (or any language with first-class functions and references), though it would probably be more efficient as a primitive.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;n&quot;&gt;signature&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CLSFD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sig&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clsfd&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clsfd&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;isofcls&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clsfd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;structure&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Clsfd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CLSFD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clsfd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unit&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;option&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NONE&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;option&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SOME&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isofcls&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;option&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NONE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NONE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SOME&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Thus, we can see &lt;script type=&quot;math/tex&quot;&gt;\clsfdt&lt;/script&gt; as an abstract data type, with multiple possible implementations. One thing that must be true across all implementations is that classes must be dynamically generated.&lt;/p&gt;

&lt;h3 id=&quot;static-exceptions&quot;&gt;Static Exceptions&lt;/h3&gt;
&lt;p&gt;Crary claims static exceptions (such as those in Java) don’t work. In our terminology, static exceptions are those that have classes that can be determined statically. In theory, this lets us reason about exceptions that a piece of code may raise.&lt;/p&gt;

&lt;p&gt;However, if you have type abstraction, this doesn’t work. If &lt;code&gt;new&lt;/code&gt; returns a static class, then if you have two classes with different &lt;code&gt;&#39;a&lt;/code&gt;s, they would still have the same classes, which breaks type safety. &lt;em&gt;[My understanding of Crary’s explanation is questionable.]&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;continuations&quot;&gt;Continuations&lt;/h2&gt;

&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand\contt[1]{#1~\m{cont}}
\renewcommand\letcc[3]{\m{letcc}_{#1}~#2~\m{in}~#3}
\renewcommand\throw[3]{\m{throw}_{#1}~#2~\m{to}~#3}
\renewcommand\cont[1]{\m{cont}(#1)}
$$
&lt;/div&gt;

&lt;p&gt;We’re going to talk about first-class continuations. They give you the ability to capture the “sequel” of the evaluation of the program.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\t &amp; ::= \cdots \mid \contt{\t} \\
e &amp; ::= \cdots \mid \letcc{\t}{x}{e} \mid \throw{\t}{e}{e} \mid \cont{k}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\contt{\t}&lt;/script&gt; can be thought of as a function that does something, but never returns anything we care about.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
\ctx, x : \contt{\t} \prove e: \t
}{
\ctx \prove \letcc{\t}{x}{e} : \t
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
\ctx \prove e : \t \qquad \ctx \prove e&#39; : \contt{\t}
}{
\ctx \prove \throw{\t&#39;}{e}{e&#39;} : \t&#39;
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[

k &gt; \letcc{\t}{x}{e} \mapsto k &gt; [\cont{k} / x] c \\
k &gt; \throw{\t}{e_1}{e_2} \mapsto k; \throw{\t}{\square}{e_2} &gt; e_1 \\
k; \throw{\t}{\square}{e_2} &lt; v \mapsto k; \throw{\t}{v}{\square} &gt; e_2 \\
k; \throw{\t}{v}{\square} &lt; \cont{k&#39;} \mapsto k&#39; &lt; v \\
 %]]&gt;&lt;/script&gt;

&lt;p&gt;Continuations let us have non-local exits. SML/NJ (but not Standard ML) has &lt;code&gt;callcc: (&#39;a cont -&amp;gt; &#39;a) -&amp;gt; &#39;a&lt;/code&gt; and &lt;code&gt;throw: &#39;a * &#39;a cont -&amp;gt; &#39;b&lt;/code&gt;. C has &lt;code&gt;setjmp&lt;/code&gt; and &lt;code&gt;longjmp&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Consider a function that computes the product of a list of &lt;code&gt;nat&lt;/code&gt;s. We might want to exit early if any of them are 0, since there’s no point in computing the product any further.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;λl : nat list .
    letcc exit in
        (fix product : nat list -&amp;gt; nat =
            λl . case l of
                nil =&amp;gt; 1
            | 0 :: _ =&amp;gt; throw 0 to exit
            | n :: t =&amp;gt; n * product t)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can use continuations for “time travel,” without the “paradoxes” that might result if had state.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;n&quot;&gt;datatype&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Large&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Small&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;guessSize&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;letcc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Small&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;Large&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;disp&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Small&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Large&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&amp;#39;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;largedisp&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;&lt;code&gt;compose (f : τ&#39; -&amp;gt; τ) (k: τ cont) : τ&#39; cont =
    letcc k&#39;&#39; in throw f (letcc k&#39; in throw k&#39; to k&#39;&#39;) to k
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &lt;code&gt;k&#39;&#39;: τ&#39; cont cont&lt;/code&gt;. We can use &lt;code&gt;compose&lt;/code&gt; to implement coroutines in user space.&lt;/p&gt;

&lt;h2 id=&quot;comparing-exceptions-and-continuations&quot;&gt;Comparing Exceptions and Continuations&lt;/h2&gt;

&lt;p&gt;Neither continuations nor exceptions are more powerful than the other. The two features are incomparable. You &lt;em&gt;can&lt;/em&gt; implement exceptions with continuations and references.&lt;/p&gt;

&lt;p&gt;Exceptions actually expand the computing power of a language, because you can implement a loop, which you can’t do with just continuations. In that sense, exceptions are “more powerful.”&lt;/p&gt;

&lt;p&gt;On the other hand, with continuations, we expand the logical scope from constructive logic to classical logic. You can prove anything with loops, but that isn’t &lt;em&gt;that&lt;/em&gt; useful from a logical perspective.&lt;/p&gt;
</description>
        <pubDate>Tue, 07 Apr 2015 13:29:45 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/04/07/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/04/07/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 21: Stack Machines, Unraveling, Exceptions</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}
\def\a{\alpha}
\def\b{\beta}
\def\t{\tau}
\def\emp{\cdotp}

\def\natt{\m{nat}}
\def\unit{\m{unit}}
\def\exn{\m{exn}}

\def\fail{\m{fail}}
\renewcommand\catch[2]{\m{catch}~#1~\m{ow}~#2}

\renewcommand\raiset[2]{\m{raise}_{#1}~#2}
\renewcommand\raise[1]{\m{raise}~#1}
\renewcommand\handle[3]{\m{handle}~#1~\m{ow}~#2.#3}

\def\defeq{\overset{def}{=}}

\renewcommand\ifz[4]{\m{ifz}(#1 ; #2 ; #3 . #4)}
$$
&lt;/div&gt;

&lt;h1 id=&quot;control-operators-continued&quot;&gt;Control Operators (continued)&lt;/h1&gt;

&lt;h2 id=&quot;stack-machines-continued&quot;&gt;Stack machines (continued)&lt;/h2&gt;

&lt;p&gt;Refactoring the syntax a bit:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
k &amp; ::= \emp \mid k;~f \\
f &amp; ::= s~\square \mid \ifz{\square}{e_0}{x}{e_1} \mid \cdots \\
S &amp; ::= k &gt; e \mid k &lt; e
\end{align} %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;soundness--completeness-continued&quot;&gt;Soundness &amp;amp; Completeness (continued)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Lemma.&lt;/strong&gt; If &lt;script type=&quot;math/tex&quot;&gt;e \Downarrow v&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\forall k. k &gt; e \mapsto^* k &lt; v %]]&gt;&lt;/script&gt;.&lt;/p&gt;

&lt;h2 id=&quot;unraveling-reraveling&quot;&gt;Unraveling (Reraveling)&lt;/h2&gt;

&lt;p&gt;For any state &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;s^*&lt;/script&gt; is a term.&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;(k &gt; e)^* \defeq k[e]&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
(k &lt; e)^* \defeq k[e] %]]&gt;&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\emp[e] \defeq e&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;(k; s \square)[e] \defeq k[s(e)]&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;(k; \ifz{\square}{e_0}{x}{e_1})[e] = k[\ifz{e}{e_0}{x}{e_1}]&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;(k; \square e_2)[e] = k[e~e_2]&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;(k; v_1 \square)[e] = k[v_1~e]&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lemma.&lt;/strong&gt; If &lt;script type=&quot;math/tex&quot;&gt;s \mapsto s&#39;&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;s^* \mapsto^* s&#39;^*&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Proof.&lt;/strong&gt; By case analysis on &lt;script type=&quot;math/tex&quot;&gt;s \mapsto s&#39;&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lemma.&lt;/strong&gt; If &lt;script type=&quot;math/tex&quot;&gt;e \mapsto e&#39;&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;\forall k . k[e] \mapsto k[e&#39;]&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Proof.&lt;/strong&gt; By induction on &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Consider the case &lt;script type=&quot;math/tex&quot;&gt;k = k&#39;; v \square&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;We want to show &lt;script type=&quot;math/tex&quot;&gt;(k; v \square)[e] \mapsto (k&#39;; v \square)[e&#39;]&lt;/script&gt;. Thus, we want to show &lt;script type=&quot;math/tex&quot;&gt;k&#39;[v~e] \mapsto k&#39;[v~e&#39;]&lt;/script&gt;, and so, we want &lt;script type=&quot;math/tex&quot;&gt;v~e \mapsto v~e&#39;&lt;/script&gt;. But, do we actually know that &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; is a value? It turns out this is true, but we need to codify this in an invariant.&lt;/p&gt;

&lt;p&gt;We rephrase the lemma: “if &lt;script type=&quot;math/tex&quot;&gt;e \mapsto e&#39;&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;\forall k&lt;/script&gt;, if &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; is good, &lt;script type=&quot;math/tex&quot;&gt;k[e] \mapsto k[e&#39;]&lt;/script&gt;”. Note that since the book does call-by-name, we don’t have to worry about this case, since &lt;script type=&quot;math/tex&quot;&gt;v\square&lt;/script&gt; never happens.&lt;/p&gt;

&lt;h2 id=&quot;exceptions&quot;&gt;Exceptions&lt;/h2&gt;

&lt;h3 id=&quot;failcatch&quot;&gt;Fail/Catch&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e ::= \cdots \mid \fail \mid \catch{e}{e}&lt;/script&gt;

&lt;p&gt;We can interpret the &lt;script type=&quot;math/tex&quot;&gt;\m{catch}&lt;/script&gt; expression as evaluating the first expression, and if reach &lt;script type=&quot;math/tex&quot;&gt;\fail&lt;/script&gt;, we evaluate the second expression.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;k ::= \cdots \mid k; f \mid k; \catch{\square}{e}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;k &gt; \fail \mapsto k \ll&lt;/script&gt;

&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;\ll&lt;/script&gt; represents unwinding the stack (to find a handler for &lt;script type=&quot;math/tex&quot;&gt;\fail&lt;/script&gt;)&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;k &gt; \catch{e_1}{e_2} \mapsto k; \catch{\square}{e_2} &gt; e_1&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k; \catch{\square}{e} &lt; v \mapsto k &lt; v %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;k; \catch{\square}{e} \ll~\mapsto k &gt; e&lt;/script&gt;

&lt;p&gt;If there’s nothing to pop off the stack, then we’ll reach an error.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;k;f \ll~\mapsto k \ll&lt;/script&gt;

&lt;h3 id=&quot;raisehandle&quot;&gt;Raise/Handle&lt;/h3&gt;

&lt;p&gt;We want our exceptions to be able to carry data as well:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e ::= \cdots \mid \raiset{\t}{e} \mid \handle{e}{x}{e}&lt;/script&gt;

&lt;p&gt;We need to choose &lt;script type=&quot;math/tex&quot;&gt;\t&lt;/script&gt; to be a specific type (as part of the language definition), &lt;script type=&quot;math/tex&quot;&gt;\tau_{exn}&lt;/script&gt;, for typechecking to work. If this is just &lt;script type=&quot;math/tex&quot;&gt;\m{unit}&lt;/script&gt;, then this is basically the same as &lt;script type=&quot;math/tex&quot;&gt;\fail&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;k &gt; \raise{e} \mapsto k; \raise{\square} &gt; e&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
k; \raise{\square} &lt; v \mapsto k \ll v %]]&gt;&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;k &gt; \handle{e_1}{x}{e_2} \mapsto k; \handle{\square}{x}{e_2} &gt; e_1&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
k; \handle{\square}{x}{e_2} &lt; v \mapsto k &lt; v %]]&gt;&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;k; \handle{\square}{x}{e_2} \ll v \mapsto k &gt; [v/x]e_2&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;k;f \ll v \mapsto k \ll v&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;For proof of type safety, look in &lt;em&gt;PFPL&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Now, let’s consider what &lt;script type=&quot;math/tex&quot;&gt;\tau_{exn}&lt;/script&gt; should be.&lt;/p&gt;

&lt;p&gt;Strings are possible (older versions of ML did this), but require serialization and deserialization, which isn’t great.&lt;/p&gt;

&lt;p&gt;Ints are used in C, but you’re limited to a fixed mapping of integers to exceptions. You &lt;em&gt;could&lt;/em&gt; use Gödel numberings, but no one actually wants that.&lt;/p&gt;

&lt;p&gt;We could do &lt;script type=&quot;math/tex&quot;&gt;\unit + \unit + \unit + \m{string} + \unit + \cdots \unit&lt;/script&gt;, where we map each layer of the sum to a different exception. This can be pattern matched on, but is pretty silly.&lt;/p&gt;

&lt;p&gt;Instead, (and modern ML does this) we use the extensible type &lt;script type=&quot;math/tex&quot;&gt;\exn&lt;/script&gt;. According to Crary’s revisionist history, &lt;script type=&quot;math/tex&quot;&gt;\exn&lt;/script&gt; stands for “extensible,” &lt;strong&gt;not&lt;/strong&gt; exception. We can add to this type with the syntax &lt;script type=&quot;math/tex&quot;&gt;\m{extension}~\m{Foo}&lt;/script&gt;.&lt;/p&gt;
</description>
        <pubDate>Thu, 02 Apr 2015 13:26:59 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/04/02/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/04/02/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 20: Futures, Control Operators</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}
\def\a{\alpha}
\def\b{\beta}
\def\t{\tau}

\def\natt{\m{nat}}
\def\boolt{\m{bool}}
\def\unitt{\m{unit}}
\def\voidt{\m{void}}

\def\unit{\langle \rangle}

\def\tt{\m{true}}
\def\ff{\m{false}}

\def\prove{\vdash}

\renewcommand\fun[3]{\lambda #1 : #2 . #3}
\renewcommand\Fun[2]{\Lambda #1 . #2}

\renewcommand\let[3]{\m{let}~#1 = #2~\m{in}~#3}

\def\typet{\m{type}}
\renewcommand\type[1]{#1 : \typet}

\renewcommand\allt[2]{\forall #1.#2}
\renewcommand\prodt[2]{#1 \times #2}
\renewcommand\pair[2]{\langle #1, #2 \rangle}
\renewcommand\App[2]{#1[#2]}
\renewcommand\subst[3]{[#1 / #2] #3}

\renewcommand\existst[2]{\exists #1.#2}
\renewcommand\pack[4]{\m{pack}~[#1,#2]~\m{as}~\exists #3.#4}
\renewcommand\open[4]{\m{open}~[#1,#2] = #3~\m{in}~#4}

\def\defeq{\overset{def}{=}}

\renewcommand\par[5]{\m{par}~#1=#2 \m{ and } #3=#4 \m{ in } #5}
\renewcommand\val[1]{#1~\m{val}}
\def\mapstos{\mapsto_{\m{seq}}}
\def\mapstop{\mapsto_{\m{par}}}

\renewcommand\futt[1]{#1~\m{fut}}
\renewcommand\fute[1]{\m{fut}(#1)}
\renewcommand\fsyn[1]{\m{fsyn}(#1)}
$$
&lt;/div&gt;

&lt;h1 id=&quot;parallelism-continued&quot;&gt;Parallelism (continued)&lt;/h1&gt;

&lt;h2 id=&quot;implicit-parallelism-theorem&quot;&gt;Implicit Parallelism Theorem&lt;/h2&gt;
&lt;p&gt;For all values &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;e \mapstos^* v \iff e \mapstop^* v&lt;/script&gt;.&lt;/p&gt;

&lt;h2 id=&quot;futures&quot;&gt;Futures&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\t &amp; ::= \cdots \mid \futt{\t} \\
e &amp; ::= \cdots \mid \fute{e} \mid \fsyn{e}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\fsyn{e}&lt;/script&gt; is used to synchronize a future and thereby get its actual value.&lt;/p&gt;

&lt;p&gt;We can define nested parallelism with futures:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\par{x_1}{e_1}{x_2}{e_2} \defeq \let{x_1&#39;}{\fute{e_1}}{
    \let{x_2}{e_2}{
        \let{x_1}{\fsyn{x_1&#39;}}{e}
    }
}&lt;/script&gt;

&lt;h3 id=&quot;statics&quot;&gt;Statics&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \prove e : \t}
{\ctx \prove \fute{e} : \futt{\t}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \prove e : \futt{\t}}
{\ctx \prove \fsyn{e} : \t}&lt;/script&gt;

&lt;h3 id=&quot;sequential-dynamics&quot;&gt;Sequential Dynamics&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\val{e}}
{\val{\fute{e}}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \mapstos e&#39;}
{\fute{e} \mapstos \fute{e&#39;}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \mapstos e&#39;}
{\fsyn{e} \mapstos \fsyn{e&#39;}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\val{e}}
{\fsyn{\fute{e}} \mapstos e}&lt;/script&gt;

&lt;h3 id=&quot;pipelining&quot;&gt;Pipelining&lt;/h3&gt;

&lt;p&gt;Consider a situation where a &lt;em&gt;producer&lt;/em&gt; builds a list where elements represent units of works. This can easily be programming with a future list.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[See p.395 of PFPL]&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;speculations&quot;&gt;Speculations&lt;/h3&gt;

&lt;p&gt;Speculations are the by-name version of futures.&lt;/p&gt;

&lt;h3 id=&quot;cost-dynamics--brents-theorem&quot;&gt;Cost Dynamics / Brent’s Theorem&lt;/h3&gt;

&lt;p&gt;Work/span analysis.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[Will be covered in recitation]&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;control-operators&quot;&gt;Control Operators&lt;/h1&gt;
&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}
\def\a{\alpha}
\def\b{\beta}
\def\t{\tau}

\def\natt{\m{nat}}

\renewcommand\ifz[4]{\m{ifz}(#1 ; #2 ; #3 . #4)}
$$
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Exceptions&lt;/li&gt;
  &lt;li&gt;Continuations&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;stack-machines&quot;&gt;Stack machines&lt;/h2&gt;
&lt;p&gt;We want to store &lt;em&gt;where we are in an expression&lt;/em&gt;. Note that we’re doing call-by-value, and the book does call-by-name.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
k &amp; ::= \cdotp \mid k;s~\square \mid k;\ifz{\square}{e_0}{x}{e_1} \mid \cdots \\
S &amp; ::= k &gt; e \mid k &lt; e
\end{align} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k &gt; z \mapsto k &lt; z %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;k &gt; s(e) \mapsto k; s~\square &gt; e&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k; s~\square &lt; v \mapsto k &lt; s(v) %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;k &gt; \ifz{e}{e_0}{x}{e_1} \mapsto k; \ifz{\square}{e_0}{x}{e_1}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k; \ifz{\square}{e_0}{x}{e_1} &lt; z \mapsto k &gt; e_0 %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k; \ifz{\square}{e_0}{x}{e_1} &lt; s(v) \mapsto k &gt; [v / x] e_1 %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;soundness--completeness&quot;&gt;Soundness &amp;amp; Completeness&lt;/h3&gt;

&lt;h4 id=&quot;soundness&quot;&gt;Soundness&lt;/h4&gt;
&lt;p&gt;If &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\cdotp &gt; e \mapsto^* \cdotp &lt; v %]]&gt;&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;e \mapsto^*&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\val{v}&lt;/script&gt;.&lt;/p&gt;

&lt;h4 id=&quot;completeness&quot;&gt;Completeness&lt;/h4&gt;
&lt;p&gt;If &lt;script type=&quot;math/tex&quot;&gt;e \mapsto^* v&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\val{v}&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\cdotp &gt; e \mapsto^* \cdotp &lt; v %]]&gt;&lt;/script&gt;.&lt;/p&gt;
</description>
        <pubDate>Tue, 31 Mar 2015 13:33:22 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/03/31/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/03/31/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 19: Representation Independence, Parallelism</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}
\def\a{\alpha}
\def\b{\beta}
\def\t{\tau}

\def\natt{\m{nat}}
\def\boolt{\m{bool}}
\def\unitt{\m{unit}}
\def\voidt{\m{void}}

\def\unit{\langle \rangle}

\def\tt{\m{true}}
\def\ff{\m{false}}

\def\prove{\vdash}

\renewcommand\fun[3]{\lambda #1 : #2 . #3}
\renewcommand\Fun[2]{\Lambda #1 . #2}

\def\typet{\m{type}}
\renewcommand\type[1]{#1 : \typet}

\renewcommand\allt[2]{\forall #1.#2}
\renewcommand\prodt[2]{#1 \times #2}
\renewcommand\pair[2]{\langle #1, #2 \rangle}
\renewcommand\App[2]{#1[#2]}
\renewcommand\subst[3]{[#1 / #2] #3}

\renewcommand\existst[2]{\exists #1.#2}
\renewcommand\pack[4]{\m{pack}~[#1,#2]~\m{as}~\exists #3.#4}
\renewcommand\open[4]{\m{open}~[#1,#2] = #3~\m{in}~#4}

\def\defeq{\overset{def}{=}}

\renewcommand\par[5]{\m{par}~#1=#2 \m{ and } #3=#4 \m{ in } #5}
\renewcommand\val[1]{#1~\m{val}}
\def\mapstos{\mapsto_{\m{seq}}}
\def\mapstop{\mapsto_{\m{par}}}
$$
&lt;/div&gt;

&lt;h1 id=&quot;representation-independence--abstraction-theoremhttpwwwandrewcmueducourse15-312notesmar-20pdf-continued&quot;&gt;&lt;a href=&quot;http://www.andrew.cmu.edu/course/15-312/notes/mar-20.pdf&quot;&gt;Representation Independence / Abstraction Theorem&lt;/a&gt; (continued)&lt;/h1&gt;

&lt;h2 id=&quot;equivalence-continued&quot;&gt;Equivalence (continued)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Lemma&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;If &lt;script type=&quot;math/tex&quot;&gt;M,M&#39; : \exists{\a}{\t}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;M = \pack{\sigma}{e}{\a}{\t}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;M&#39; = \pack{\sigma&#39;}{e&#39;}{\a}{\t}&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;R : \sigma \to \sigma&#39;&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; is closed under equivalence and &lt;script type=&quot;math/tex&quot;&gt;e \sim e&#39; : \subst{R}{\a}{\t}&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;M \sim M&#39; : \existst{\a}{\t}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Proof&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;Suppose &lt;script type=&quot;math/tex&quot;&gt;M,M&#39; : \exists{\a}{\t}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;M = \pack{\sigma}{e}{\a}{\t}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;M&#39; = \pack{\sigma&#39;}{e&#39;}{\a}{\t}&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;R : \sigma \to \sigma&#39;&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; is closed under equivalence and &lt;script type=&quot;math/tex&quot;&gt;e \sim e&#39; : \subst{R}{\a}{\t}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;We want to show that &lt;script type=&quot;math/tex&quot;&gt;M \sim M&#39; : \allt{\beta}{(\allt{\a}{\t \to \b}) \to \b}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Suppose &lt;script type=&quot;math/tex&quot;&gt;\rho, \rho&#39; : \typet&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;Q : \rho \leftrightarrow \rho&#39;&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;Q&lt;/script&gt; is closed under equivalence.&lt;/p&gt;

&lt;p&gt;We want to show &lt;script type=&quot;math/tex&quot;&gt;\App{M}{\rho} \sim \App{M&#39;}{\rho&#39;} : (\allt{\a}{\t \to Q}) \to Q&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Suppose &lt;script type=&quot;math/tex&quot;&gt;f \sim f&#39; : \allt{\a}{\t \to Q}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;We want to show &lt;script type=&quot;math/tex&quot;&gt;\App{M}{\rho}f \sim \App{M&#39;}{\rho&#39;}f&#39; : Q&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;We want to show that &lt;script type=&quot;math/tex&quot;&gt;\App{M}{\rho}f~~Q~~\App{M&#39;}{\rho&#39;}f&#39;&lt;/script&gt;.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\App{(\Fun{\b}{\lambda g . \App{g}{\sigma}e})}{\rho}f \mapsto^* \App{f}{\sigma}e&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\App{(\Fun{\b}{\lambda g . \App{g}{\sigma&#39;}e&#39;})}{\rho&#39;}f&#39; \mapsto^* \App{f&#39;}{\sigma&#39;}e&#39;&lt;/script&gt;

&lt;p&gt;We want to show that &lt;script type=&quot;math/tex&quot;&gt;\App{f}{\sigma}e~~Q~~\App{f&#39;}{\sigma&#39;}e&#39;&lt;/script&gt;.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\App{f}{\sigma} \sim \App{f&#39;}{\sigma&#39;} : \subst{R}{\a}{(\t \to Q)}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\therefore \App{f}{\sigma} \sim \App{f&#39;}{\sigma&#39;} : Q&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\therefore \App{f}{\sigma}e~~Q~~\App{f&#39;}{\sigma&#39;}e&#39;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\blacksquare&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Theorem&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;If &lt;script type=&quot;math/tex&quot;&gt;e : \allt{\a}{\a \to \a}&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;e \cong \Fun{\a}{\fun{x}{\a}{x}} : \allt{\a}{\a \to \a}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;This theorem states that we can still have &lt;script type=&quot;math/tex&quot;&gt;\unitt&lt;/script&gt;.&lt;/p&gt;

&lt;h1 id=&quot;parallelism&quot;&gt;Parallelism&lt;/h1&gt;

&lt;p&gt;Thus far, we’ve been focusing on &lt;em&gt;small-step evaluation&lt;/em&gt;, &lt;script type=&quot;math/tex&quot;&gt;e \mapsto e&#39;&lt;/script&gt;, where each step is a small, atomic operation. We’ve also encountered &lt;em&gt;large-step evaluation&lt;/em&gt;, &lt;script type=&quot;math/tex&quot;&gt;e \Downarrow v&lt;/script&gt;, where &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt; evaluates to the value &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; after a number of small steps: &lt;script type=&quot;math/tex&quot;&gt;e \mapsto^* v \wedge v~\m{val} \iff e \Downarrow v&lt;/script&gt;.&lt;/p&gt;

&lt;h2 id=&quot;nested-parallelism&quot;&gt;Nested Parallelism&lt;/h2&gt;

&lt;p&gt;This terminology is still non-standard, but Crary believes it should and will be.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Parallelism &lt;script type=&quot;math/tex&quot;&gt;\neq&lt;/script&gt; concurrency.&lt;/strong&gt; Parallelism is deterministic–we want to run a computation on multiple processors to improve efficiency, but there is one, deterministic result that is the result of the computation. Concurrency is nondeterministic.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Nested parallelism&lt;/em&gt; is also known as &lt;em&gt;fork-join parallelism&lt;/em&gt;.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e ::= \cdots \mid \par{x_1}{e_1}{x_2}{e_2}{e}&lt;/script&gt;

&lt;h3 id=&quot;statics&quot;&gt;Statics&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \prove e_1 : \t_1 \qquad \ctx \prove e_2 : \t_2 \qquad \ctx, x_1 : \t_1, x_2 : \t_2 \prove e : \t}
{\ctx \prove \par{x_1}{e_1}{x_2}{e_2}{e} : \tau}&lt;/script&gt;

&lt;h3 id=&quot;dynamics&quot;&gt;Dynamics&lt;/h3&gt;

&lt;p&gt;Let’s pretend our construct isn’t parallel, and just evaluate the two expressions sequentially.&lt;/p&gt;

&lt;h4 id=&quot;sequential&quot;&gt;Sequential&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e_1 \mapsto e_1&#39;}
{\par{x_1}{e_1}{x_2}{e_2}{e} \mapsto \par{x_1}{e_1&#39;}{x_2}{e_2}{e}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\val{e_1} \qquad e_2 \mapsto e_2&#39;}
{\par{x_1}{e_1}{x_2}{e_2}{e} \mapsto \par{x_1}{e_1}{x_2}{e_2&#39;}{e}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\val{e_1} \qquad \val{e_2}}
{\par{x_1}{e_1}{x_2}{e_2}{e} \mapsto \subst{e_1~e_2}{x_1~x_2}{e}}&lt;/script&gt;

&lt;p&gt;If we can show the actual implementation works like this, we can reason about our parallel code the same way we’ve reasoned about sequential code, which greatly simplifies analysis.&lt;/p&gt;

&lt;p&gt;We will make the distinction between &lt;script type=&quot;math/tex&quot;&gt;\mapstos&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\mapstop&lt;/script&gt;.&lt;/p&gt;

&lt;h4 id=&quot;parallel&quot;&gt;Parallel&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e_1 \mapstop e_1&#39; \qquad e_2 \mapstop e_2&#39;}
{\par{x_1}{e_1}{x_2}{e_2}{e} \mapstop \par{x_1}{e_1&#39;}{x_2}{e_2&#39;}{e}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\val{e_1} \qquad e_2 \mapstop e_2&#39;}
{\par{x_1}{e_1}{x_2}{e_2}{e} \mapstop \par{x_1}{e_1}{x_2}{e_2&#39;}{e}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e_1 \mapstop e_1&#39; \qquad \val{e_2}}
{\par{x_1}{e_1}{x_2}{e_2}{e} \mapstop \par{x_1}{e_1&#39;}{x_2}{e_2}{e}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\val{e_1} \qquad \val{e_2}}
{\par{x_1}{e_1}{x_2}{e_2}{e} \mapstop \subst{e_1~e_2}{x_1~x_2}{e}}&lt;/script&gt;
</description>
        <pubDate>Thu, 26 Mar 2015 13:25:50 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/03/26/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/03/26/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 18: Existential Types, Representation Independence</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}
\def\a{\alpha}
\def\b{\beta}
\def\t{\tau}

\def\natt{\m{nat}}
\def\boolt{\m{bool}}
\def\unitt{\m{unit}}
\def\voidt{\m{void}}

\def\unit{\langle \rangle}

\def\tt{\m{true}}
\def\ff{\m{false}}

\def\prove{\vdash}

\renewcommand\fun[3]{\lambda #1 : #2 . #3}
\renewcommand\Fun[2]{\Lambda #1 . #2}

\def\typet{\m{type}}
\renewcommand\type[1]{#1 : \typet}

\renewcommand\allt[2]{\forall #1.#2}
\renewcommand\prodt[2]{#1 \times #2}
\renewcommand\pair[2]{\langle #1, #2 \rangle}
\renewcommand\App[2]{#1[#2]}
\renewcommand\subst[3]{[#1 / #2] #3}

\renewcommand\existst[2]{\exists #1.#2}
\renewcommand\pack[4]{\m{pack}~[#1,#2]~\m{as}~\exists #3.#4}
\renewcommand\open[4]{\m{open}~[#1,#2] = #3~\m{in}~#4}

\def\defeq{\overset{def}{=}}
$$
&lt;/div&gt;

&lt;h1 id=&quot;polymorphism-continued&quot;&gt;Polymorphism (continued)&lt;/h1&gt;

&lt;h2 id=&quot;data-asbstraction--existential-types&quot;&gt;Data asbstraction / existential types&lt;/h2&gt;

&lt;p&gt;An existential type is of the form&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\existst{\a}{\t}&lt;/script&gt;

&lt;p&gt;This forces us to be parametric on &lt;script type=&quot;math/tex&quot;&gt;\a&lt;/script&gt;. We introduce&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\pack{\t}{e}{\a}{\t&#39;}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\open{\a}{x}{e}{e&#39;}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx\prove \type{\t} \qquad \ctx\prove e : \subst{\t}{\a}{\t&#39;} \qquad \ctx,\type{\a} \prove \type{\t&#39;}}
{\ctx \prove \pack{\t}{e}{\a}{\t&#39;} : \existst{\a}{\t&#39;}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \prove e_1 : \existst{\a}{\t} \qquad \ctx, \type{\a}, x : \t \prove e_2 : \t&#39; \qquad \ctx \prove \type{\t&#39;}}
{\ctx \prove \open{\a}{x}{e_1}{e_2} : \t&#39;}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;{\tt
sig \\
  type~\tau \\
  val~init : \tau \\
  val~flip : t \to \tau \\
  val~out : t \to \m{bool} \\
end
}&lt;/script&gt;

&lt;p&gt;We actually don’t need explicit existential types, because we can implement them in terms of universal types.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\existst{\a}{\t} &amp; \defeq \allt{\b}{(\allt{\a}{\t \to \b}) \to \b} \\
\pack{\t}{e}{\a}{\t&#39;} &amp; \defeq \Fun{\b}{\fun{f}{(\allt{\a}{\t&#39; \to \b})}{f~\t~e}} \\
\open{\a}{x}{e_1}{e_2} &amp; \defeq \App{e_1}{\t&#39;}(\Fun{\a}{\fun{x}{\tau}{e_2}})
\end{align} %]]&gt;&lt;/script&gt;

&lt;h1 id=&quot;representation-independence--abstraction-theoremhttpwwwandrewcmueducourse15-312notesmar-20pdf&quot;&gt;&lt;a href=&quot;http://www.andrew.cmu.edu/course/15-312/notes/mar-20.pdf&quot;&gt;Representation Independence / Abstraction Theorem&lt;/a&gt;&lt;/h1&gt;

&lt;h2 id=&quot;equivalence&quot;&gt;Equivalence&lt;/h2&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\alpha&lt;/script&gt;-equivalence is when two terms are exactly the same, except for variable names. This is the strictest form of equivalence.&lt;/p&gt;

&lt;p&gt;Trivial equivalence is when everything is said to be equivalent. This is pretty useless.&lt;/p&gt;

&lt;p&gt;We will discuss &lt;em&gt;contexual&lt;/em&gt; and &lt;em&gt;logical&lt;/em&gt; equivalence, which are the same.&lt;/p&gt;

&lt;p&gt;Two terms are contextually equivalent if any program we embed those terms into cannot tell the difference between the two terms. This is pretty well motivated–we want to know if this is the case all the time. However, it’s hard to work with, since in theory, to show it, we have to check all possible inputs.&lt;/p&gt;

&lt;p&gt;Contexual: &lt;script type=&quot;math/tex&quot;&gt;e \cong e&#39; : \t&lt;/script&gt;&lt;br /&gt;
Logical: &lt;script type=&quot;math/tex&quot;&gt;e \sim e&#39; : \t&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;(Special case of) Reynold’s Abstraction Theorem: If &lt;script type=&quot;math/tex&quot;&gt;\prove e : \t&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;e \sim e : \t&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Logical relation:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
e \sim e&#39; : \boolt &amp; \iff (e \mapsto^* \tt \wedge e&#39; \mapsto^* \tt) \vee (e \mapsto^* \ff \wedge e&#39; \mapsto^* \ff) \\
e \sim e&#39; : \unitt &amp; \iff \m{yes} \\
e \sim e&#39; : \natt &amp; \iff \exists n . e \mapsto^* \bar{n} \wedge e&#39; \mapsto \bar{n} \\
e \sim e&#39; : \t_1 \to \t_2 &amp; \iff \forall v, v&#39; . \m{if}~v \sim v&#39; : \t_1, \m{then}~e~v\sim e&#39;~v&#39; : \t_2 \\
e \sim e&#39; : \t_1 \times \t_2 &amp; \iff e \cdot l \sim e&#39; \cdot l : \tau_1 \vee e \cdot r \sim e&#39; \cdot r : \t_2 \\
e \sim e&#39; : \allt{\a}{\t} &amp; \iff \forall \t_1, \t_2 . \forall R : \t_1 \leftrightarrow \t_2 . \App{e}{\t_1} \sim \App{e&#39;}{\t_2} : \subst{R}{\a}{\t} \\
e \sim e&#39; : R &amp; \iff e~R~e&#39;
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;We’re using quasi-types:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;q ::= \boolt \mid \natt \mid \unitt \mid q \to q \mid q \times q \mid \allt{\a}{q} \mid R&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;R \subseteq \{ e\mid e : \t_1 \} \times \{ e \mid e : \t_2 \}&lt;/script&gt;

&lt;p&gt;such that &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; is closed under equivalence. Thus, reflexivity is no longer obvious, which makes the abstraction theorem so useful.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;M_1 = \pack{\boolt}{\pair{\ff}{\pair{\natt}{\lambda x . x}}}{\a}{\a \times (\a \to \a) \times \a \to \boolt}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;M_2 = \pack{\natt}{\pair{\bar{0}}{\pair{\m{succ}}{\m{odd?}}}}{\a}{\a \times (\a \to \a) \times \a \to \boolt}&lt;/script&gt;

&lt;p&gt;We can prove that &lt;script type=&quot;math/tex&quot;&gt;M_1 \sim M_2 : \existst{\a}{\a \times (\a \to \a) \times \a \to \boolt}.&lt;/script&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 24 Mar 2015 13:27:21 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/03/24/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/03/24/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 17: Polymorphism</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}
\def\a{\alpha}
\def\t{\tau}

\def\natt{\m{nat}}
\def\boolt{\m{bool}}
\def\unitt{\m{unit}}
\def\voidt{\m{void}}

\def\unit{\langle \rangle}

\def\prove{\vdash}

\renewcommand\fun[3]{\lambda #1 : #2 . #3}
\renewcommand\Fun[2]{\Lambda #1 . #2}

\def\typet{\m{type}}
\renewcommand\type[1]{#1~\typet}

\renewcommand\allt[2]{\forall(#1.#2)}
\renewcommand\prodt[2]{#1 \times #2}
\renewcommand\pair[2]{\langle #1, #2 \rangle}
\renewcommand\App[2]{#1[#2]}
\renewcommand\subst[3]{[#1 / #2] #3}
$$
&lt;/div&gt;

&lt;h1 id=&quot;polymorphism-continued&quot;&gt;Polymorphism (continued)&lt;/h1&gt;

&lt;h2 id=&quot;type-safety&quot;&gt;Type Safety&lt;/h2&gt;

&lt;p&gt;Preservation and progress do hold. See &lt;em&gt;PFPL&lt;/em&gt; for more details.&lt;/p&gt;

&lt;p&gt;To prove preservation for&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\App{(\Fun{\alpha}{e})}{\tau} \to \subst{\tau}{\alpha}{e}}&lt;/script&gt;

&lt;p&gt;we need a substitution lemma (type substitution).&lt;/p&gt;

&lt;h2 id=&quot;language-constructs&quot;&gt;Language Constructs&lt;/h2&gt;

&lt;p&gt;Recall natural numbers from the untyped lambda calculus:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\bar{0} = \lambda z . \lambda s . z&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\overline{n+1} = \lambda z . \lambda s . s ~ (\bar{n} ~ z ~ s)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\natt: b \to (b \to b) \to b&lt;/script&gt;

&lt;p&gt;We need to fix $b$ to be a specific type, which works in an untyped language (type is just &lt;script type=&quot;math/tex&quot;&gt;\m{dyn}&lt;/script&gt;) but not in the typed lambda calculus.&lt;/p&gt;

&lt;p&gt;With polymorphism, we can make this work:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\natt &amp; = \allt{\alpha}{\alpha \to (\alpha \to \alpha) \to \alpha} \\
\bar{0} &amp; = \Fun{\alpha}{\fun{z}{\alpha}{\fun{s}{\alpha \to \alpha}{z}}} \\
\overline{n+1} &amp; = \Fun{\alpha}{\fun{z}{\alpha}{\fun{s}{\alpha \to \alpha}{s~(\App{\bar{n}}{\alpha}~z~s)}}} \\
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;We can also implement other constructs we’ve seen in this class:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\boolt &amp; = \allt{\alpha}{\alpha \to \alpha \to \a} \\
\overline{\m{true}} &amp; = \Fun{\alpha}{\fun{x}{\a}{\fun{y}{\a}{x}}}
\end{align} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\prod{\tau_1}{\tau_2} &amp; = \allt{\a}{(\tau_1 \to \tau_2 \to \a) \to \a} \\
\overline{\pair{e}{e&#39;}} &amp; = \Fun{\a}{\fun{f}{\t_1 \to \t_2 \to \a}{f~e~e&#39;}} \\
\m{outl}_{\t_1,t_2}~e &amp; = \App{e}{\t_1}(\fun{x}{\t_1}{\fun{y}{\t_2}{x}})
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;System-F also has sum types, though it does &lt;em&gt;not&lt;/em&gt; have recursive types, because all programs terminate.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\unitt &amp; = \allt{\a}{\a \to \a} \\
\overline{\unit} &amp; = \Fun{\a}{\fun{x}{\a}{x}} \\
\voidt &amp; = \allt{\a}{\a} \\
\overline{\m{abort}_\t~e} &amp; = \App{e}{\t}
\end{align} %]]&gt;&lt;/script&gt;

&lt;h2 id=&quot;natural-numbers&quot;&gt;Natural Numbers&lt;/h2&gt;
&lt;p&gt;We claim that our definition of natural numbers &lt;em&gt;are the natural numbers&lt;/em&gt;: there is nothing else in the type. Similarly, for &lt;script type=&quot;math/tex&quot;&gt;\unitt&lt;/script&gt;, if &lt;script type=&quot;math/tex&quot;&gt;e : \unitt&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;e \cong \Fun{\a}{\fun{x}{\a}{x}}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Proving this rigorously takes an additional semester of math. But, in short, this proof relies on &lt;em&gt;parametricity&lt;/em&gt;. Since we can’t branch on type, we have parametric polymorphism. Consider&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e \cong \Fun{\alpha}{\fun{x}{\a}{\_}}&lt;/script&gt;

&lt;p&gt;Because we can’t branch on &lt;script type=&quot;math/tex&quot;&gt;\a&lt;/script&gt;, and because $\a$ is unknown, the only way to produce a value of type &lt;script type=&quot;math/tex&quot;&gt;\a&lt;/script&gt; is to fill in the blank with &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;If the language allowed for non-terminating programs (recursion), then for &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt; to have type &lt;script type=&quot;math/tex&quot;&gt;\alpha&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;e \cong \bot&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\Fun{\a}{\bot}&lt;/script&gt;, or &lt;script type=&quot;math/tex&quot;&gt;\Fun{\alpha}{\fun{x}{\a}{\bot}}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;The Parametricity Theorem is also called the Abstraction Theorem, which is an important part of modular programming. It basically says that we can have a program composed of separate pieces that can possibly work.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Crary claims that the Abstraction Theorem is the most important theorem in computer science.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;impredicative-types&quot;&gt;Impredicative Types&lt;/h2&gt;

&lt;p&gt;In &lt;script type=&quot;math/tex&quot;&gt;\allt{\a}{\t}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\a&lt;/script&gt; ranges over a collection (possibly not a set) of types that includes &lt;script type=&quot;math/tex&quot;&gt;\allt{\a}{\t}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;In ML, we have &lt;em&gt;predicative&lt;/em&gt; types. There are monotypes (&lt;script type=&quot;math/tex&quot;&gt;\tau ::= \a \mid \t \to \t&lt;/script&gt;) and polytypes (&lt;script type=&quot;math/tex&quot;&gt;\sigma ::= \t \mid \allt{\a}{\sigma}&lt;/script&gt;). Note that the &lt;script type=&quot;math/tex&quot;&gt;\forall&lt;/script&gt; ranges over monotypes, not polytypes. This lets ML hide all quanitifies, and it uses prenex quantification to put all the quantifies at the front of the type.&lt;/p&gt;

&lt;h2 id=&quot;value-restriction&quot;&gt;Value Restriction&lt;/h2&gt;
&lt;p&gt;[&lt;em&gt;I’m not sure I understand this explanation.&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;Why does ML blow up if you have &lt;code&gt;val x = rev nil&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Consider&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val x = (print &quot;hello&quot;; nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we let this have the type &lt;code&gt;&#39;a list&lt;/code&gt;, then &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; would be a value. Whenever &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; is used, “hello” will be printed. Thus, we can introduce unexpected side effects to our program.&lt;/p&gt;

&lt;p&gt;This is commonly, &lt;em&gt;incorrectly&lt;/em&gt; believed to be to preserve type safety. (For what it’s worth, &lt;a href=&quot;http://mlton.org/ValueRestriction&quot;&gt;MLTon claims this&lt;/a&gt;.) The concern is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val r = ref NONE;
val () = r := SOME 12;
val x = case !(r : (int -&amp;gt; int) option ref) of
            NONE =&amp;gt; ...
          | SOME f =&amp;gt; f 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, a new reference &lt;script type=&quot;math/tex&quot;&gt;r&lt;/script&gt; is being generated each time, so while the behavior is unexpected, it does not break type safety. The reason it’s believed this breaks type safety is that it’s incorrectly believed there should be a rule&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \mapsto e&#39;}
{\Fun{\a}{e} \mapsto \Fun{\a}{e&#39;}}&lt;/script&gt;
</description>
        <pubDate>Thu, 19 Mar 2015 13:30:50 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/03/19/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/03/19/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 16: Aliasing, Free References, Polymorphism (System F)</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\newcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\newcommand\ok[1]{#1~~\m{ok}}
\newcommand\oks[1]{#1~~\m{ok}_{\sig}}
\def\natt{\m{nat}}
\def\gap{\hspace{1cm}}
\def\valt{\m{val}}
\newcommand\val[1]{#1~\valt}
\newcommand\vals[1]{#1~\valt_{\scriptscriptstyle\sig}}
\newcommand\valsx[2]{#1~\valt_{\scriptscriptstyle\sig, #2}}
\def\gt{\mapsto}
\def\gts{\gt_{\scriptscriptstyle\sig}}
\newcommand\gtsx[1]{\gt_{\scriptscriptstyle\sig, #1}}
\def\defeq{\overset{def}{=}}

\def\prove{\vdash}
\def\provesig{\prove_{\scriptscriptstyle\sig}}
\def\provee{\prove_{\emptyset}}
\newcommand\provesigx[1]{\prove_{\scriptscriptstyle \sig,#1}}

\def\cmdt{\m{cmd}}
\newcommand\cmd[1]{\cmdt~(#1)}

\newcommand\ret[1]{\m{ret}~(#1)}

\newcommand\bnd[3]{\m{bnd}~#1 \leftarrow #2; #3}
\newcommand\bind[3]{\{ #1 \leftarrow #2; #3 \}}

\newcommand\final[1]{#1~\m{final}_{\scriptscriptstyle\sig}}
\newcommand\finalx[2]{#1~\m{final}_{\scriptscriptstyle\sig,#2}}

\def\midd{~||~}

\newcommand\do[1]{\m{do}~#1}

\newcommand\ifelse[3]{\m{if}~(#1)~#2~\m{else}~#3}
\newcommand\while[2]{\m{while}~(#1)~#2}

\newcommand\ifz[4]{\m{ifz}(#1;#2;#3.#4)}
\newcommand\fix[3]{\m{fix}~#1:#2~#3}

\newcommand\dcl[3]{\m{dcl}~#1 := #2~\m{in}~#3}
\newcommand\dcla[3]{\m{dcl}(#1; #2.#3)}
\newcommand\dclt[4]{\m{dcl}_{#1}~#2 := #3~\m{in}~#4}

\newcommand\get[1]{@#1}
\newcommand\geta[1]{\m{get}[#1]}

\newcommand\set[2]{#1 := #2}
\newcommand\seta[2]{\m{set}[#1](#2)}

\newcommand\fun[3]{\lambda #1 : #2 . #3}

\def\qquad{~~~~}

\newcommand\mobile[1]{#1~\m{mobile}}
\def\voidt{\m{void}}
\def\unitt{\langle \rangle}

\newcommand\reft[1]{\m{ref}(#1)}
\newcommand\ref[1]{\&amp;amp;#1}
\newcommand\getref[1]{*#1}
\newcommand\setref[2]{#1 := #2}
\newcommand\newref[2]{\m{newref}_{#1} #2}

\newcommand\state[3]{\nu (#1) \{ #2 \midd #3 \}}
\newcommand\statesig[2]{\nu \sig \{ #1 \midd #2 \}}
$$
&lt;/div&gt;

&lt;h1 id=&quot;modernized-algol-continued&quot;&gt;Modernized Algol (continued)&lt;/h1&gt;

&lt;h2 id=&quot;references-continued&quot;&gt;References (continued)&lt;/h2&gt;

&lt;h3 id=&quot;aliasing&quot;&gt;Aliasing&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
e \mathrel{+}= e&#39; &amp; \defeq \bind{x}{\getref{e}}{\bind{y}{\getref{e&#39;}}{\setref{e}{(x+y)}}}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Two references that govern the same underlying assignable are said to be &lt;em&gt;aliases&lt;/em&gt;. The possibility of aliasing complicates reasoning about the correctness of code that uses references, for we must always consider for any two references whether or not they might be aliases.&lt;/p&gt;

&lt;h2 id=&quot;free-assignables&quot;&gt;Free Assignables&lt;/h2&gt;

&lt;p&gt;In order to be able to have mutable data structures, we need assignables that can live outside the scopes of their declarations. We call these &lt;em&gt;scope-free&lt;/em&gt; or &lt;em&gt;free&lt;/em&gt; assignables.&lt;/p&gt;

&lt;p&gt;We change &lt;script type=&quot;math/tex&quot;&gt;\m{dcl}&lt;/script&gt; to add assignables to the state.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\statesig{m}{\mu}&lt;/script&gt;

&lt;p&gt;represents a state where the assignables &lt;script type=&quot;math/tex&quot;&gt;m \midd \mu&lt;/script&gt; are bound. &lt;script type=&quot;math/tex&quot;&gt;\nu&lt;/script&gt; is purely for notational purposes.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\vals{e}}
{\statesig{\dclt{\tau}{a}{e}{m}}{\mu} \gt \state{\sig,a \sim \tau}{m}{(\mu, a \hookrightarrow e)}}&lt;/script&gt;

&lt;p&gt;We don’t need a mobility condition for&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig{e : \tau} \qquad \ctx \provesigx{a \sim \tau}{m \sim \tau&#39;}}
{\ctx \provesig{\dclt{\tau}{a}{e}{m \sim \tau&#39;}}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\newref{\tau}{e} \defeq \dclt{\tau}{a}{e}{\ref{a}}&lt;/script&gt;

&lt;p&gt;&lt;em&gt;[backpatching to implement recursion]&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;preservation&quot;&gt;Preservation&lt;/h3&gt;

&lt;p&gt;If &lt;script type=&quot;math/tex&quot;&gt;\statesig{m}{\mu} \gt \statesig{m&#39;}{\mu&#39;}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\provesig{m \sim \tau}&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;\provesig{\mu : \sig}&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;\prove_{\scriptscriptstyle\sig&#39;} m&#39; \sim \tau&lt;/script&gt;,  &lt;script type=&quot;math/tex&quot;&gt;\prove_{\scriptscriptstyle\sig&#39;} \mu&#39; : \sig&#39;&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;\sig&#39;&lt;/script&gt; extends &lt;script type=&quot;math/tex&quot;&gt;\sig&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Note that in languages with &lt;script type=&quot;math/tex&quot;&gt;\m{free}&lt;/script&gt; (such as C), it is not always the case that &lt;script type=&quot;math/tex&quot;&gt;\sig&#39;&lt;/script&gt; extends &lt;script type=&quot;math/tex&quot;&gt;\sig&lt;/script&gt;. We would need a lot more sophistication in order to have a working type system. Most languages with &lt;script type=&quot;math/tex&quot;&gt;\m{free}&lt;/script&gt; are just broken.&lt;/p&gt;

&lt;h1 id=&quot;polymorphism&quot;&gt;Polymorphism&lt;/h1&gt;

&lt;p&gt;We will be discussing a language called System F, also known as polymorphic lambda calculus. We will have bare type variables.&lt;/p&gt;

&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}

\def\prove{\vdash}

\renewcommand\fun[3]{\lambda #1 : #2 . #3}
\renewcommand\Fun[2]{\Lambda #1 . #2}

\def\typet{\m{type}}
\renewcommand\type[1]{#1~\typet}

\renewcommand\allt[2]{\forall(#1.#2)}
\renewcommand\App[2]{#1[#2]}
\renewcommand\subst[3]{[#1 / #2] #3}
$$
&lt;/div&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\tau &amp; ::= \alpha \mid \tau \to \tau \mid \allt{\alpha}{\tau} \\
e &amp; ::= x \mid \fun{x}{\tau}{e} \mid ee \mid \Fun{\alpha}{e} \mid \App{e}{\tau}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Note the lack of explicit product and sum types. System F’s typing is actually more powerful than ML because you can include $\forall$ in types. (ML forces you to have all quantifiers at the beginning of the type, but saves you from having to write them explicitly.)&lt;/p&gt;

&lt;h2 id=&quot;statics&quot;&gt;Statics&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx(x)=\tau}
{\ctx \prove x : \tau}&lt;/script&gt;

&lt;p&gt;&lt;em&gt;[missing judgements]&lt;/em&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx,\alpha : \typet \prove e : \tau}
{\ctx \prove \Fun{\alpha}{e} : \allt{\alpha}{\tau}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \prove e : \allt{\alpha}{\tau&#39;} \qquad \ctx \prove \tau : \typet}
{\ctx \prove \App{e}{\tau} : \subst{\tau}{\alpha}{\tau&#39;}}&lt;/script&gt;

&lt;p&gt;&lt;em&gt;[missing judgements for &lt;script type=&quot;math/tex&quot;&gt;\typet&lt;/script&gt;]&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;dynamics&quot;&gt;Dynamics&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;[missing rules for usual evaluation]&lt;/em&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \to e&#39;}
{\App{e}{\tau} \to \App{e&#39;}{\tau}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\App{(\Fun{\alpha}{e})}{\tau} \to \subst{\tau}{\alpha}{e}}&lt;/script&gt;
</description>
        <pubDate>Tue, 17 Mar 2015 13:28:49 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/03/17/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/03/17/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 15: Benign effects, Mobile Types, References</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\newcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\newcommand\ok[1]{#1~~\m{ok}}
\newcommand\oks[1]{#1~~\m{ok}_{\sig}}
\def\natt{\m{nat}}
\def\gap{\hspace{1cm}}
\def\valt{\m{val}}
\newcommand\val[1]{#1~\valt}
\newcommand\vals[1]{#1~\valt_{\scriptscriptstyle\sig}}
\newcommand\valsx[2]{#1~\valt_{\scriptscriptstyle\sig, #2}}
\def\gt{\mapsto}
\def\gts{\gt_{\scriptscriptstyle\sig}}
\newcommand\gtsx[1]{\gt_{\scriptscriptstyle\sig, #1}}
\def\defeq{\overset{def}{=}}

\def\prove{\vdash}
\def\provesig{\prove_{\scriptscriptstyle\sig}}
\def\provee{\prove_{\emptyset}}
\newcommand\provesigx[1]{\prove_{\scriptscriptstyle \sig,#1}}

\def\cmdt{\m{cmd}}
\newcommand\cmd[1]{\cmdt~(#1)}

\newcommand\ret[1]{\m{ret}~(#1)}

\newcommand\bnd[3]{\m{bnd}~#1 \leftarrow #2; #3}
\newcommand\bind[3]{\{ #1 \leftarrow #2; #3 \}}

\newcommand\final[1]{#1~\m{final}_{\scriptscriptstyle\sig}}
\newcommand\finalx[2]{#1~\m{final}_{\scriptscriptstyle\sig,#2}}

\def\midd{~||~}

\newcommand\do[1]{\m{do}~#1}

\newcommand\ifelse[3]{\m{if}~(#1)~#2~\m{else}~#3}
\newcommand\while[2]{\m{while}~(#1)~#2}

\newcommand\ifz[4]{\m{ifz}(#1;#2;#3.#4)}
\newcommand\fix[3]{\m{fix}~#1:#2~#3}

\newcommand\dcl[3]{\m{dcl}~#1 := #2~\m{in}~#3}
\newcommand\dcla[3]{\m{dcl}(#1; #2.#3)}
\newcommand\dclt[4]{\m{dcl}_{#1}~#2 := #3~\m{in}~#4}

\newcommand\get[1]{@#1}
\newcommand\geta[1]{\m{get}[#1]}

\newcommand\set[2]{#1 := #2}
\newcommand\seta[2]{\m{set}[#1](#2)}

\newcommand\fun[3]{\lambda #1 : #2 . #3}

\def\qquad{~~~~}

\newcommand\mobile[1]{#1~\m{mobile}}
\def\voidt{\m{void}}
\def\unitt{\langle \rangle}

\newcommand\reft[1]{\m{ref}(#1)}
\newcommand\ref[1]{\&amp;amp;#1}
\newcommand\getref[1]{*#1}
\newcommand\setref[2]{#1 := #2}
$$
&lt;/div&gt;

&lt;h1 id=&quot;modernized-algol-continued&quot;&gt;Modernized Algol (continued)&lt;/h1&gt;

&lt;h2 id=&quot;syntactic-sugar&quot;&gt;Syntactic Sugar&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\{\bind{x}{m_1}{m_2}\} &amp; \defeq \bnd{x}{\cmd{m_1}}{m_2} \\
\{ m_1 ; m_2 \} &amp; \defeq \{ \bind{\_}{m_1}{m_2} \} \\
\while{m_1}{m_2} &amp; \defeq \do{(
    \fix{\m{loop}}
        {\cmdt}
        {\cmd{(\ifelse{m_1}
                      {\ret{\bar{0}}}
                      {\{m_2 ; \do{\m{loop}}\}}
        )}}
)}
\end{align} %]]&gt;&lt;/script&gt;

&lt;h2 id=&quot;factorial&quot;&gt;Factorial&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\m{fact} \defeq \fun
{x}
{\natt}
{\cmd{(
    \dcl{r}{1}{\\\dcl{a}{x}{\\ \{\while{\get{a}}{
    \{ \\
        \bnd{y}{\get{r}}{\\\bnd{z}{\get{a}}{\\\set{r}{(x-z+\bar{1})*y ; \\\set{a}{z - \bar{1}}}}}
    \\\}\\
    }; \get{r}\}}}
)}} \\
\m{fact} : \natt \to \cmdt
&lt;/script&gt;

&lt;h2 id=&quot;benign-effects&quot;&gt;Benign effects&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Benign effects&lt;/em&gt; do not change the visible state of the program. For $\m{fact}$, we’d like to produce a function with type $\natt \to \natt$. Even though it indeed only has benign effects, we can’t guarantee that. We can’t hide side effects, but we also can’t hide benign effects.&lt;/p&gt;

&lt;p&gt;Haskell is pure because it does not let you hide any effects, including benign ones. So, if there is an effect, it’s in the type (via monads). SML is impure because it lets you hide benign effects, but you can also hide any other effect.&lt;/p&gt;

&lt;h2 id=&quot;extending-the-language&quot;&gt;Extending the Language&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\tau &amp; ::= \cdots \mid \cmd{\tau} \\
m &amp; ::= \cdots \mid \dclt{\tau}{a}{e}{m}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Signatures now include types for assignables.&lt;/p&gt;

&lt;h3 id=&quot;proposed-incorrect-type-system&quot;&gt;Proposed (incorrect) type system&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ctx \provesig e : \tau&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ctx \provesig m \sim \tau&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig m \sim \tau}
{\ctx \provesig \cmd{m} : \cmd{\tau}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e : \tau}
{\ctx \provesig \ret{e} \sim \tau}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e : \cmd{\tau} \qquad \ctx, x : \tau \provesig m \sim \tau&#39;}
{\ctx \provesig \bind{x}{e}{m} \sim \tau&#39;}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e : \cmd{\tau} \qquad \ctx, x : \tau \provesig m \sim \tau&#39;}
{\ctx \provesig \dclt{\tau}{a}{e}{m} \sim \tau&#39;}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\ctx \provesigx{a \sim \tau} \get{a} \sim \tau}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesigx{a \sim \tau} e : \tau}
{\ctx \provesigx{a \sim \tau} \set{a}{e} \sim \tau}&lt;/script&gt;

&lt;p&gt;Why is this incorrect?&lt;/p&gt;

&lt;h3 id=&quot;mobile-types&quot;&gt;Mobile types&lt;/h3&gt;

&lt;p&gt;Consider the program&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\dcl{a}{\bar{0}}{\ret{\fun{x}{\natt}{\cmd{\set{a}{x}}}}}&lt;/script&gt;

&lt;p&gt;It steps to&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ret{\fun{x}{\natt}{\cmd{\set{a}{x}}}}&lt;/script&gt;

&lt;p&gt;but $a$ is not in scope.&lt;/p&gt;

&lt;p&gt;In the typing judgment for $\m{dcl}$, $\tau’$ needs to be mobile. Alternatively, we can require that the type for $\m{ret}$ must be mobile. Natural numbers are mobile, but functions are not, because they can refer to assignables.&lt;/p&gt;

&lt;p&gt;More precisely, &lt;script type=&quot;math/tex&quot;&gt;\tau&lt;/script&gt; is &lt;em&gt;mobile&lt;/em&gt; if &lt;script type=&quot;math/tex&quot;&gt;\forall e,\sig . \provesig e : \tau \wedge \vals{e}&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;\prove_{\emptyset} e : \tau&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\val{e}_{\emptyset}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Note that if successor for natural numbers ($\m{s}$) is lazy, then natural numbers are &lt;em&gt;not&lt;/em&gt; mobile.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\mobile{\tau_1} \qquad \mobile{\tau_2}}
{\mobile{\tau_1 + \tau_2}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\voidt}&lt;/script&gt;

&lt;p&gt;The typing rules are still incorrect. Consider the program&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\dcl{a}{\cmd{\ret{\bar{0}}}}{\dcl{b}{\bar{0}}{\{
    \set{a}{\cmd{\get{b}}}; \ret \unitt
\}}}&lt;/script&gt;

&lt;p&gt;Here, assignables are escaping through the store. We need $\tau$ to be mobile as well in the typing judgment for $\m{dcl}$.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;p&gt;References are a language concept that correspond to the implementation concept pointers. References are not mobile (since they are nothing but assignables).&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\tau &amp; ::= \cdots \mid \reft{\tau} \\
e &amp; ::= \cdots \mid \ref{\tau} \\
m &amp; ::= \cdots \mid \getref{e} \mid \setref{e}{e}
\end{align} %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;statics&quot;&gt;Statics&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\ctx \provesigx{a \sim \tau} \ref{\tau} : \reft{\tau}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e : \ref{\tau}}
{\ctx \provesig \getref{e} \sim \tau}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e_1 : \reft{\tau} \qquad \ctx \provesig e_2 : \tau}
{\ctx \provesig \setref{e_1}{e_2} : \tau}&lt;/script&gt;

&lt;h3 id=&quot;operational-semantics&quot;&gt;Operational Semantics&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\valsx{\ref{a}}{a}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \gts e&#39;}
{\getref{e} \midd \mu \gts \getref{e&#39;} \midd \mu}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\getref{\ref{a}} \midd \mu \gts \get{a} \midd \mu}&lt;/script&gt;

&lt;p&gt;&lt;em&gt;[for $\setref{e_1}{e_2}$, evaluate $e_1$ and $e_2$]&lt;/em&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\vals{e_2}}
{\setref{\ref{a}}{e_2} \gts \set{a}{e_2} \midd \mu}&lt;/script&gt;
</description>
        <pubDate>Tue, 03 Mar 2015 13:28:18 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/03/03/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/03/03/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>76-221 Class 15: Gulliver&#39;s Travels</title>
        <description>&lt;h2 id=&quot;language-of-objects-p-172&quot;&gt;Language of objects (p. 172)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;“Women,” “Vulgar,” and “Illiterate” are “constant irreconcileable enemies to Science”&lt;/li&gt;
  &lt;li&gt;opposing this language is pretty reasonable&lt;/li&gt;
  &lt;li&gt;strange that the illiterate would oppose a new language&lt;/li&gt;
  &lt;li&gt;but even the illiterate realize how terrible this is&lt;/li&gt;
  &lt;li&gt;implies that women talk too much, though this is Swift criticizing Gulliver and this society&lt;/li&gt;
  &lt;li&gt;speak with &lt;em&gt;tongues&lt;/em&gt;, with the body
    &lt;ul&gt;
      &lt;li&gt;p. 191: “my tongue is in the Mouth of my Friend” when using a translator, also French kissing&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;language is &lt;em&gt;abstract&lt;/em&gt; (more than just objects) and &lt;em&gt;physical&lt;/em&gt; (tongues)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;struldbrugs&quot;&gt;Struldbrugs&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;immortal humans who also age indefinitely&lt;/li&gt;
  &lt;li&gt;nature is directional, towards death&lt;/li&gt;
  &lt;li&gt;turning cucumbers back to sunbeams is thus unnatural&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;houyhnhnms&quot;&gt;Houyhnhnms&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;portrayed as perfectly rational , and thus people&lt;/li&gt;
  &lt;li&gt;yet, Yahoos feel more like people&lt;/li&gt;
  &lt;li&gt;have capacity for misrepresentation and genocide&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;p-221&quot;&gt;p. 221&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;no word for lying&lt;/li&gt;
  &lt;li&gt;deficient language&lt;/li&gt;
  &lt;li&gt;Gulliver defends Master, has gone over to their side&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;p-251&quot;&gt;p. 251&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;no Letters, no literature&lt;/li&gt;
  &lt;li&gt;yet, have poetry, which is possibly written, and possibly emotional (irrational)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;p-218-9&quot;&gt;p. 218-9&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Gulliver is a “perfect Yahoo”&lt;/li&gt;
  &lt;li&gt;yet, wants hides of Yahoos for clothing and shoes&lt;/li&gt;
  &lt;li&gt;Master lies, willing to hide Gulliver’s true nature&lt;/li&gt;
  &lt;li&gt;Gulliver hates Yahoos because he hates himself&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;p-249&quot;&gt;p. 249&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Houyhnhnms domesticated and bred the Yahoos
    &lt;ul&gt;
      &lt;li&gt;stupid, because asses are better workers anyways&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;now, they want to commit genocide by castrating them, yet consider this solution to avoid taking of lives&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;p-258&quot;&gt;p. 258&lt;/h3&gt;
&lt;p&gt;Gulliver kills and skins Yahoo children because their skins are softer, and he needs them for his canoe.&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Mar 2015 09:00:00 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/76221/2015/03/03/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/76221/2015/03/03/</guid>
        
        
        <category>cmu</category>
        
        <category>76221</category>
        
      </item>
    
  </channel>
</rss>
