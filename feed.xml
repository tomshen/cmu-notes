<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Notes</title>
    <description>Notes on classes at CMU.
</description>
    <link>http://www.tomshen.me/notes/</link>
    <atom:link href="http://www.tomshen.me/notes/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 24 Feb 2015 14:50:57 -0500</pubDate>
    <lastBuildDate>Tue, 24 Feb 2015 14:50:57 -0500</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>15-312 Lecture 13: Modernized Algol</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\newcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\newcommand\ok[1]{#1~~\m{ok}}
\def\natt{\m{nat}}
\def\gap{\hspace{1cm}}
\def\valt{\m{val}}
\newcommand\val[1]{#1~\valt}
\newcommand\vals[1]{#1~\valt_{\scriptscriptstyle\sig}}
\newcommand\valsx[2]{#1~\valt_{\scriptscriptstyle\sig, #2}}
\def\gt{\mapsto}
\def\gts{\gt_{\scriptscriptstyle\sig}}
\newcommand\gtsx[1]{\gt_{\scriptscriptstyle\sig, #1}}
\def\defeq{\overset{def}{=}}

\def\prove{\vdash}
\def\provesig{\prove_{\scriptscriptstyle\sig}}
\newcommand\provesigx[1]{\prove_{\scriptscriptstyle \sig,#1}}

\def\cmdt{\m{cmd}}
\newcommand\cmd[1]{\cmdt~#1}

\newcommand\ret[1]{\m{ret}~#1}

\newcommand\bnd[3]{\m{bnd}~#1 \leftarrow #2; #3}
\newcommand\bind[3]{\{ #1 \leftarrow #2; #3 \}}

\newcommand\final[1]{#1~\m{final}_{\scriptscriptstyle\sig}}

\def\midd{~||~}

\newcommand\do[1]{\m{do}~#1}

\newcommand\ifelse[3]{\m{if}~(#1)~#2~\m{else}~#3}

\newcommand\ifz[4]{\m{ifz}(#1;#2;#3.#4)}

\newcommand\dcl[3]{\m{dcl}~#1 := #2~\m{in}~#3}
\newcommand\dcla[3]{\m{dcl}(#1; #2.#3)}

\newcommand\get[1]{@#1}
\newcommand\geta[1]{\m{get}[#1]}

\newcommand\set[2]{#1 := #2}
\newcommand\seta[2]{\m{set}[#1](#2)}
$$
&lt;/div&gt;

&lt;h1 id=&quot;imperative-languages&quot;&gt;Imperative Languages&lt;/h1&gt;
&lt;p&gt;We’re going to discuss Algol, which inspired Pascal, which inspired C. In particular, we’re going talk about &lt;em&gt;Modernized Algol&lt;/em&gt;, which isn’t a real language.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Expressions&lt;/em&gt; are &lt;em&gt;pure&lt;/em&gt;: they have no side effects. Expressions are often referred to as terms.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Commands&lt;/em&gt; are &lt;em&gt;impure&lt;/em&gt;: they may have &lt;em&gt;side effects&lt;/em&gt;; they do something to the world. Side effects can involve changes to the store (modifying memory), or input and output. Commands are often referred to as, rather confusingly, expressions.&lt;/p&gt;

&lt;h1 id=&quot;modernized-algol&quot;&gt;Modernized Algol&lt;/h1&gt;
&lt;p&gt;A lot of justifications for why things in this language are the way they are will be by &lt;em&gt;lax logic&lt;/em&gt;.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\tau &amp; ::= \cdots \mid \cmdt \\
e &amp; ::= \cdots \mid \cmd{m} \\
m &amp; ::= \ret{e} \mid \bnd{x}{e}{m} \mid \dcl{a}{e}{m} \mid \get{a} \mid \set{a}{e}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;$m$ is a &lt;em&gt;command&lt;/em&gt;. $a$ is an &lt;em&gt;assignable&lt;/em&gt;. It’s commonly referred to as a variable, which is incorrect, because it’s not given meaning through substitution.&lt;/p&gt;

&lt;p&gt;Note that $\m{bnd}$ is not the same as $\m{let}$. With a $\m{bnd}$ command, once $e$ becomes a value, we know it’s a encapsulated command, so we execute it. With a $\m{let}$ expression, we substitute the value of $e$ in for $x$.&lt;/p&gt;

&lt;p&gt;The abstract syntax for some of the commands are:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\dcla{e}{a}{m} \gap \geta{a} \gap \seta{a}{e}&lt;/script&gt;

&lt;h2 id=&quot;static-semantics&quot;&gt;Static Semantics&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ctx \provesig e : \tau&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\sig&lt;/script&gt; is a &lt;em&gt;signature&lt;/em&gt;. In this language, it is a set of assignables.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx, x : \tau \provesig e : \tau&#39;}
{\ctx \provesig \lambda x : \tau . e : \tau \rightharpoonup \tau&#39;}
&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ctx \provesig \ok{m}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig \ok{m}}
{\ctx \provesig \cmd{m} : \cmdt}
&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e : \natt}
{\ctx \provesig \ok{\ret{e}}}
&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e : \cmdt \gap \Gamma, x : \natt \provesig \ok{m}}
{\ctx \provesig \ok{\bnd{x}{e}{m}}}
&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e : \natt \gap \ctx \provesigx{a} \ok{m}}
{\ctx \provesig \dcl{a}{e}{\ok{m}}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{a \in \sig}
{\ctx \provesig \ok{\get{a}}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{a \in \sig \gap \ctx \provesig e : \natt}
{\ctx \provesig \ok{\set{a}{e}}}&lt;/script&gt;

&lt;p&gt;Note that there is an implicit assumption that $a \not\in \sig$. Note also that this assignment is not persistent. In an implementation, $a$ would reside on the stack, and this is commonly referred to as &lt;em&gt;stack discipline&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;operational-semantics&quot;&gt;Operational Semantics&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vals{e}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e \gts e&#39;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;m \midd \mu \gts m&#39; \midd \mu&#39;&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\mu&lt;/script&gt; is a &lt;em&gt;state&lt;/em&gt;, representing memory where assignables are mapped to values. $m$ is a command.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\final{m \midd \mu}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}{\vals{\cmd{m}}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\vals{e}}
{\ret{e} \midd \final{\mu}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \gts e&#39;}
{\ret{e} \midd \mu \gts \ret{e&#39;} \midd \mu}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \gts e&#39;}
{\bnd{x}{e}{m} \midd \mu \gts \bnd{x}{e&#39;}{m \midd \mu}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{m_1 \midd \mu \gts m_1&#39; \midd \mu&#39;}
{\bnd{x}{\cmd{m_1}}{m_2} \midd \mu \gts \bnd{x}{\cmd{m_1&#39;}}{m_2} \midd \mu}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\vals{e}}
{\bnd{x}{\cmd{(\ret{e})}}{m} \midd \mu \gts [e/x]~m \midd \mu}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \gts e&#39;}
{\dcl{a}{e}{m} \midd \mu \gts \dcl{a}{e&#39;}{m} \midd \mu}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\vals{e} \gap m \midd (\mu, a \hookrightarrow e) \gtsx{a} m&#39; \midd (\mu&#39;, a \hookrightarrow e&#39;)}
{\dcl{a}{e}{m} \midd \mu \gts \dcl{a}{e&#39;}{m&#39;} \midd \mu&#39;}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\vals{e_1} \gap \valsx{e_2}{a}}
{\dcl{a}{e_1}{\ret{e_2}} \midd \mu \gts \ret{e_2} \midd \mu}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\get{a} \midd (\mu, a \hookrightarrow e) \gtsx{a} \ret{e} \midd (\mu, a \hookrightarrow e)}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e_1 \gtsx{a} e_1&#39;}
{\set{a}{e} \midd \mu \gts \set{a}{e_1&#39;} \midd \mu}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\vals{e_1}}
{\set{a}{e_1} \midd (\mu, a \hookrightarrow e_2) \gts \ret{e_1} \midd (\mu, a \hookrightarrow e_1)}&lt;/script&gt;

&lt;h2 id=&quot;syntactic-sugar&quot;&gt;Syntactic Sugar&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\bind{x}{m}{m&#39;} &amp; \defeq \bnd{x}{\cmd{m}}{m&#39;} \\
\do{e} &amp; \defeq \bnd{x}{e}{\ret{x}} \\
\ifelse{m}{m_1}{m_2} &amp; \defeq \bind{x}{m}{\do{(\ifz{x}{\cmd{m_1}}{\_}{\cmd{m_2}})}}
\end{align} %]]&gt;&lt;/script&gt;
</description>
        <pubDate>Tue, 24 Feb 2015 13:30:41 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/02/24/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/02/24/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>76-221 Class 13: Gulliver&#39;s Travels</title>
        <description>&lt;p&gt;Occasionally, irrationality is part of being human. Swift was an early proponent of the idea that the main thing that differentiates from animals is language.&lt;/p&gt;

&lt;h2 id=&quot;p-62&quot;&gt;p. 62&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;lots of unnecessary detail&lt;/li&gt;
  &lt;li&gt;joke is that he doesn’t need to defend her, because he is 12 times larger than her&lt;/li&gt;
  &lt;li&gt;too much association with the Lilliputians&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;p-80&quot;&gt;p. 80&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;long, overly-detailed passages as a game&lt;/li&gt;
  &lt;li&gt;playing with the reader&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pp-21-2&quot;&gt;pp. 21-2&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Swift is fond of puns&lt;/li&gt;
  &lt;li&gt;“Master Mr. Bates” to “Mr. Bates” to, finally, “Master Bates”&lt;/li&gt;
  &lt;li&gt;purpose of language is not communication
    &lt;ul&gt;
      &lt;li&gt;part of who we are&lt;/li&gt;
      &lt;li&gt;like why a monkey swings on his tail&lt;/li&gt;
      &lt;li&gt;something for us to play with&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;p-71&quot;&gt;p. 71&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;a “real boat” is real because it’s his size&lt;/li&gt;
  &lt;li&gt;shows he is getting out of his fictional mindset&lt;/li&gt;
  &lt;li&gt;Swift is showing that the body insists when it is denied&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pp-82-3&quot;&gt;pp. 82-3&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Worries that Brobdingnags would dash him against the ground, just as he was earlier considering dashing the Lilliputians against the ground
    &lt;ul&gt;
      &lt;li&gt;He doesn’t explicitly recognize this connection&lt;/li&gt;
      &lt;li&gt;to be human is to make connections, to have narrative history&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;p-110&quot;&gt;p. 110&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;beauty is relative, but still necessary&lt;/li&gt;
  &lt;li&gt;it’s all a matter of perspective&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;p-111&quot;&gt;p. 111&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;right after passage on beauty (or lack thereof)&lt;/li&gt;
  &lt;li&gt;grotesque&lt;/li&gt;
  &lt;li&gt;fountain of blood from neck stump compared to fountain in Palace of Versailles
    &lt;ul&gt;
      &lt;li&gt;quite an inappropriate comparison&lt;/li&gt;
      &lt;li&gt;misfit&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;neither the actual beheading nor the fountain of blood bothered him, but the bouncing of the head startled him&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Aside: William Boroughs claimed the above two passages inspired &lt;em&gt;Naked Lunch.&lt;/em&gt; He claims they present an argument against capital punishment.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 24 Feb 2015 09:00:00 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/76221/2015/02/24/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/76221/2015/02/24/</guid>
        
        
        <category>cmu</category>
        
        <category>76221</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 12: The Untyped Lambda Calculus</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\newcommand{\m}[1]{\textsf{#1}}
\def\okt{\m{ok}}
\newcommand\ok[1]{#1\;\okt}
\def\ctx{\Gamma}
\def\defeq{\overset{def}{=}}
\def\succ{\m{succ}}
\def\plus{\m{plus}}
\def\times{\m{times}}
\def\zero{\bar{0}}
\def\ifz{\m{ifz}}
\def\pred{\m{pred}}
\newcommand\pair[2]{\langle #1, #2 \rangle}
\def\yc{\m{Y}}
$$
&lt;/div&gt;

&lt;h1 id=&quot;the-untyped-lambda-calculus&quot;&gt;The Untyped $\lambda$-Calculus&lt;/h1&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;u = x \mid \lambda x . t \mid uu&lt;/script&gt;

&lt;p&gt;Since this is untyped, $\ok{u}$ and&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ok{u} \in \ctx}
{\Gamma \vdash \ok{u}}
&lt;/script&gt;

&lt;p&gt;We have the rules you’d expect for the $\okt$ judgement, and for equivalence. &lt;em&gt;[They were illegible. See PFPL 17.1]&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;church-encoding&quot;&gt;Church encoding&lt;/h2&gt;
&lt;p&gt;Church numerals are (the best-known) special case of Church encoding. We will use $\bar{0}$ to represent numbers in the language, rather than the real world.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\bar{0} \defeq \lambda b . \lambda s . b&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\bar{1} \equiv \lambda b . \lambda s . s(b)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\overline{n + 1} \defeq \lambda b . \lambda s . s(\bar{n} \; b \; s)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\succ \defeq \lambda f . \lambda b . \lambda s . s(f \; b \; s)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\succ&#39; \defeq \lambda f . \lambda b . \lambda s . f(s \; b) s&lt;/script&gt;

&lt;p&gt;We can prove, for any $n \in \mathbb{N}$, &lt;script type=&quot;math/tex&quot;&gt;\succ(\bar{n}) \equiv \succ&#39;(\bar{n}) \equiv \overline{n+1}&lt;/script&gt; by induction on $n$.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align*}
\plus &amp; = \lambda m . \lambda n . \lambda b . \lambda s . n \; (m \; b \; s) \; s \\
&amp; = \lambda m . \lambda n . m \; n \; \succ \\
\times &amp; = \lambda m . \lambda n . m \; \zero \; (\plus n)
\end{align*} %]]&gt;&lt;/script&gt;

&lt;p&gt;To define $\ifz$, we need to be able to find the predecessor of something:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ifz\{e, e_0, x. e_s\} = e \; e_0 \; (\lambda \_ . [\pred \; e / x] e_s)&lt;/script&gt;

&lt;p&gt;We define $\pred$ as&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\pred(\zero) &amp; \equiv \zero \\
\pred(\overline{n+1}) &amp; \equiv \bar{n}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Returning to Church encodings, we need to represent numbers as their iterators. This is necessary to be able to obtain the predecessor of a value. First, we define pairs&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\pair{u_1}{u_2} &amp; \defeq \lambda f . f \; u_1 \; u_2 \\
u \cdot l &amp; \defeq u \; (\lambda x . \lambda y . x) \\
u \cdot r &amp; \defeq u \; (\lambda x . \lambda y . y)
\end{align} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\pred&#39; &amp; = \lambda n . n \; \pair{\zero}{\zero} \; (\lambda p . \pair{p \cdot r}{\succ \; (p \cdot r)}) \\
\pred &amp; = \lambda n . \pred&#39; \; (n) \cdot l
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;To implement $\m{fix}$, we define the $\yc$ combinator.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\yc \defeq \lambda f . (\lambda x . f \; (x \; x)) \; (\lambda x . f \; (x \; x))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\yc \; F &amp; \equiv (\lambda x . F \; (x \; x)) \; (\lambda x . F \; (x \; x)) \\
&amp; \equiv F \; ((\lambda x . F \; (x \; x)) \; (\lambda x . F \; (x \; x))) \\
&amp; \equiv F \; (\lambda f . (\lambda x . f \; (x \; x)) (\lambda x . f \; (x \; x))) \; F \\
&amp; \equiv F \; (\yc \; F)
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Thus, we have all the computational power of PCF (and computation in general) in a much more compact language.&lt;/p&gt;

&lt;h2 id=&quot;scotts-theorem&quot;&gt;Scott’s Theorem&lt;/h2&gt;
&lt;p&gt;There exists no effectively computable (computable in the $\lambda$-calculus) algorithm for testing the equivalence of two lambda terms.&lt;/p&gt;

&lt;p&gt;Scott’s Theorem is a special case of &lt;em&gt;Rice’s Theorem&lt;/em&gt;, which states that there exists no effective computable algorithm that can test any (nontrivial, behavioral) property of lambda terms.&lt;/p&gt;

&lt;p&gt;A property $A$ is &lt;em&gt;trivial&lt;/em&gt; if $\forall u . A(u)$ or $\forall u . \neg A(u)$.&lt;/p&gt;

&lt;p&gt;A property $A$ is &lt;em&gt;behavioral&lt;/em&gt; if $u \equiv u’ \supset A(u) \iff A(u’)$.&lt;/p&gt;
</description>
        <pubDate>Thu, 19 Feb 2015 13:30:00 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/02/19/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/02/19/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 11: Dynamic Languages as Typed Languages</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\newcommand{\m}[1]{\textsf{#1}}
\def\ok{\m{ok}}
\def\num{\m{num}}
\def\fun{\m{fun}}
\def\dyn{\m{dyn}}
\def\nat{\m{nat}}
\def\new{\m{new}}
\def\cast{\m{cast}}
\def\err{\m{ err}}
\def\inst{\m{inst}}
\def\bool{\m{bool}}
\def\true{\m{true}}
\def\false{\m{false}}
$$
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Delivered by Bob Harper&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;dpcf-continued&quot;&gt;DPCF (continued)&lt;/h1&gt;
&lt;p&gt;Recall that DPCF is “dynamic PCF” (looks like PCF without types). There are two classes of values:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;numbers $\num[n]$, where $\num$ is a class of numbers&lt;/li&gt;
  &lt;li&gt;functions $\fun(x.d)$, where $\fun$ is a class of functions&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Recall that classes are not types. So, the classes are $\num$ and $\fun$, but both their types are $\ok$. So, while dynamic languages are often said to have “runtime type checking,” this is not quite correct. What we actually have is runtime &lt;em&gt;class&lt;/em&gt; checking:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$d \m{ is_num } n$.&lt;/li&gt;
  &lt;li&gt;$d \m{ is_fun } x.d’$.&lt;/li&gt;
  &lt;li&gt;$d \m{ isnt_num}$.&lt;/li&gt;
  &lt;li&gt;$d \m{ isnt_fun}$.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;which requires space, requires time, and can fail.&lt;/p&gt;

&lt;h1 id=&quot;hybrid-pcf&quot;&gt;Hybrid PCF&lt;/h1&gt;
&lt;p&gt;We can define a hybrid PCF as PCF $+$ $\dyn$, which is a subset of $FPC$ with recursive types. This lets us have “dynamic” typing while still being able to perform program transformations.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\tau ::= \nat \mid \tau_1 \rightharpoonup \tau_2 \mid \dyn&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\new[c](e) : \dyn \m{ if } \begin{cases}
e : \nat &amp; \m{if } c = \num \\
e : \dyn \rightharpoonup \dyn &amp; \m{if } c= \fun
\end{cases} %]]&gt;&lt;/script&gt;

&lt;p&gt;e.g. &lt;script type=&quot;math/tex&quot;&gt;\new[\num](7) : \dyn&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\num[\fun](7)\;X&lt;/script&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\cast[c](e) : \begin{cases}
\nat &amp; \m{if } c = \num \\
\dyn \rightharpoonup \dyn &amp; \m{if } c = \fun
\end{cases} \text{ where $e : \dyn$} %]]&gt;&lt;/script&gt;

&lt;p&gt;e.g. &lt;script type=&quot;math/tex&quot;&gt;\cast[\fun](\new[\num](\_))\err&lt;/script&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\inst[c](e) : \bool \text{ where $e : \dyn$}&lt;/script&gt;

&lt;p&gt;e.g. &lt;script type=&quot;math/tex&quot;&gt;\inst[\num](\new[\num](\_)) = \true&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Note that if&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x_1 : \ok, \ldots, x_n : \ok \vdash_{DPCF} d : \ok&lt;/script&gt;

&lt;p&gt;then&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x_1 : \dyn,\ldots,x_n : \dyn \vdash_{HPCF} d^+ : \dyn&lt;/script&gt;

&lt;p&gt;and the behavior is preserved.&lt;/p&gt;

&lt;p&gt;Ultimately, it makes much more sense to use a static language with type inference than a dynamic language. In either case, you can write code without explicit types. But with the static language, the compiler can perform transformations and guarantee (useful) type safety.&lt;/p&gt;

&lt;h1 id=&quot;dpcf-subseteq-hpcf-subseteq-fpc&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;DPCF \subseteq HPCF \subseteq FPC&lt;/script&gt;&lt;/h1&gt;
&lt;p&gt;(dynamic typing $\subseteq$ static typing $\subseteq$ FPC)&lt;/p&gt;

&lt;p&gt;Dynamic typing is not in opposition to static typing, because it is a subset of static typing. However, HPCF is an entirely artificial construct. It’s simply a way to show the power of FPC. FPC has many other useful features.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;FPC = \lambda \{ 0 ~ 1 + \times \to \mu \}&lt;/script&gt;
</description>
        <pubDate>Tue, 17 Feb 2015 13:30:00 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/02/17/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/02/17/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>76-221 Class 11: Gulliver&#39;s Travels</title>
        <description>&lt;p&gt;The prevailing idea of what it means to be a person at the time &lt;em&gt;Gulliver’s Travels&lt;/em&gt; was written was:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;chain of being: God to angels to humans (rational animals)&lt;/li&gt;
  &lt;li&gt;hierarchy&lt;/li&gt;
  &lt;li&gt;animals are without spirit or reason&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Is Gulliver a rational animal? We can consider him rational because he’s clearly a thinking being. But, we can also consider him an animal, and sometimes even irrational:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;talks about “making water” (p. 27)&lt;/li&gt;
  &lt;li&gt;traveling repeatedly despite the trouble he always runs into&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Compare &lt;em&gt;Gulliver’s Travels&lt;/em&gt; to the &lt;em&gt;Odyssey&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;emphasis on travel versus homecoming&lt;/li&gt;
  &lt;li&gt;hospitality
    &lt;ul&gt;
      &lt;li&gt;because strangers may be gods in the &lt;em&gt;Odyssey&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;why is hospitality so common in &lt;em&gt;Gulliver’s Travels&lt;/em&gt;?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cross-culture assimilation is part of human nature. But Gulliver takes it perhaps too far: he pretends to be a Lilliputian, and looks down on nobles of lower rank in their society. When he “makes water,” he sees it from their perspective: as a “torrent.”&lt;/p&gt;

&lt;p&gt;Violence is very much a part of Gulliver’s society, at least directed at smaller beings. He thinks nothing of dashing small animals against the ground. But, honor holds him back from doing so to the similarly small Lilliputians: assimilation!&lt;/p&gt;

&lt;p&gt;Is Gulliver a reliable narrator? While reading, it is easy for us to “believe in” the Lilliputians. &lt;/p&gt;
</description>
        <pubDate>Tue, 17 Feb 2015 00:09:00 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/76221/2015/02/17/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/76221/2015/02/17/</guid>
        
        
        <category>cmu</category>
        
        <category>76221</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 10: Dynamic Languages</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$
\newcommand{\m}[1]{\textsf{#1}}
\def\ok{\m{ok}}

$
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Delivered by Bob Harper&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;dynamic-languages&quot;&gt;Dynamic Languages&lt;/h1&gt;

&lt;h2 id=&quot;dynamic-vs-static-typinglanguages&quot;&gt;Dynamic vs Static Typing/Languages&lt;/h2&gt;

&lt;h3 id=&quot;static-languages&quot;&gt;Static languages&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;ML&lt;/li&gt;
  &lt;li&gt;Haskell&lt;/li&gt;
  &lt;li&gt;Java&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;dynamic-languages-1&quot;&gt;Dynamic languages&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Lisp (1960)
    &lt;ul&gt;
      &lt;li&gt;The original dynamic language&lt;/li&gt;
      &lt;li&gt;Racket/Scheme&lt;/li&gt;
      &lt;li&gt;Clojure&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Python&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;erroneous-ideas&quot;&gt;Erroneous ideas&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;interactive $\iff$ dynamic: There’s no coupling between interactive and dynamic languages. For instance, ML has a REPL, but is still a static language.&lt;/li&gt;
  &lt;li&gt;Bellman effect: Richard Bellman gave &lt;em&gt;dynamic&lt;/em&gt; programming its name because he though “dynamic” sounded good. Just because something is “dynamic” doesn’t mean it’s better.&lt;/li&gt;
  &lt;li&gt;Anti-types: Types are an obstacle.&lt;/li&gt;
  &lt;li&gt;heterogeneity: &lt;code&gt;[1, I, &quot;one&quot;]&lt;/code&gt; is ill-typed in ML. This is held up as an example of the limitations of static typing.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;technical-issues&quot;&gt;Technical issues&lt;/h3&gt;
&lt;p&gt;Dynamic languages are not opposed to static languages because dynamic languages $\subseteq$ static languages.&lt;/p&gt;

&lt;p&gt;The crucial idea is that untyped languages are &lt;em&gt;uni&lt;/em&gt;typed languages $\approx$ dynamic languages. A dynamic language restricts attention to a &lt;em&gt;single type&lt;/em&gt;. Bob Harper (unsurprisingly) thinks this is a bad idea.&lt;/p&gt;

&lt;p&gt;Surface syntax can be very deceiving. What &lt;code&gt;2 + 3&lt;/code&gt; means in ML is dramatically different from &lt;code&gt;2 + 3&lt;/code&gt; in Python or &lt;code&gt;+ 2 3&lt;/code&gt; in Lisp.&lt;/p&gt;

&lt;h2 id=&quot;dynamic-pcf-dpcf&quot;&gt;Dynamic PCF (DPCF)&lt;/h2&gt;
&lt;p&gt;It looks like we simply erased type information from programs.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
d &amp; ::= x \\
&amp; |\; \m{num}[n] \\
&amp; |\; \m{zero} \\
&amp; |\; \m{succ}(d) \\
&amp; |\; \m{ifz}(d, d_0, x.d_1) \\
&amp; |\; \m{fun}(x.d) &amp; \lambda x.d \\
&amp; |\; \m{app}(d_1; d_2) &amp; d_1(d_2 )\\
&amp; |\; \m{fix}(y.d) &amp; \m{fix } x \m{ is } d
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;So, it seems like PCF $=$ DPCF $+$ types.&lt;/p&gt;

&lt;h3 id=&quot;statics&quot;&gt;Statics&lt;/h3&gt;
&lt;p&gt;The statics are a little different. Consider&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x_1\m{ ok},\ldots,x_n\m{ ok} \vdash d\m{ ok}&lt;/script&gt;

&lt;p&gt;which could be written as&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x_1:\m{ok},\ldots,x_n:\m{ok} \vdash d:\m{ok}&lt;/script&gt;

&lt;p&gt;thus making $\m{ok}$ the one true type, thereby showing untyped DPCF is the same as unityped DPCF. This means that&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{\Gamma,x : \ok \vdash d : \ok}
{\Gamma \vdash \lambda x.d : \ok}&lt;/script&gt;

&lt;p&gt;Similarly, $\m{zero}(\m{zero}) : \ok$. This is rather unsettling.&lt;/p&gt;

&lt;p&gt;$\m{zero}(\m{zero})$ will fail at runtime instead of at compile time.&lt;/p&gt;

&lt;h3 id=&quot;dynamics&quot;&gt;Dynamics&lt;/h3&gt;
&lt;p&gt;The dynamics are &lt;em&gt;quite&lt;/em&gt; different. We have our usual&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{cases}
d \m{ val} \\
d \mapsto d&#39;
\end{cases}&lt;/script&gt;

&lt;p&gt;but we also need runtime class checks:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\begin{cases}
d \m{ err} \\
d \m{ is_name} \\
d \m{ isnt_num} \\
d \m{ is_fun} \\
d \m{ isnt_fun}
\end{cases}&lt;/script&gt;

&lt;p&gt;We’ll need to include these in dynamics, as well as propagate any errors that come up. We’ll need the basic rules:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{}
{\lambda x.d \;\m{is_fun}\; y.d}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{}
{\m{num}[\_] \;\m{isnt_fun}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{}
{\m{zero} \mapsto \m{num}[0]}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{d\;\m{val} \;\; d \;\m{is_num}\; n}
{\m{succ}(d) \mapsto \m{num}[n+1]}&lt;/script&gt;

&lt;p&gt;(This is why we needed to include $\m{num}[n]$ in our language.)&lt;/p&gt;

&lt;p&gt;Thus, when we compile down to machine code, we’ll need to store type information as well. This costs space (to store types) and time (to check types).&lt;/p&gt;

&lt;p&gt;In ML, &lt;code&gt;2 + 3&lt;/code&gt; compiles down to a register holding &lt;code&gt;2&lt;/code&gt;, a register holding &lt;code&gt;3&lt;/code&gt;, and an adding operation. In a DPCF, &lt;code&gt;2 + 3&lt;/code&gt; compiles down to memory holding &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;2&lt;/code&gt;, memory holding &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt;, and operations to not just add &lt;code&gt;2&lt;/code&gt; and &lt;code&gt;3&lt;/code&gt;, but check the two types are the same and store that type with &lt;code&gt;5&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The formalisms behind a dynamic language &lt;em&gt;force&lt;/em&gt; a less efficient implementation. And, this overhead (which is already substantial for such a simple language) increases even more as the language becomes more complex.&lt;/p&gt;

&lt;h3 id=&quot;type-safety&quot;&gt;Type safety&lt;/h3&gt;
&lt;p&gt;One of the oft-touted benefits of dynamic languages is that your program will never fail to compile due to type checking.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Aside: ML’s error messages are terrible because it sets up a set of simultaneous equations and attempts to solve them with a system similar to Gaussian elimination. There’s no easy way to turn that into a good error message.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;em&gt;Theorem.&lt;/em&gt; DPCF is type-safe.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Proof.&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Preservation: trivial, since $d : \ok \mapsto d’ : \ok$ (“anything goes”)&lt;/li&gt;
  &lt;li&gt;Progress: if $d : \ok$, then either
    &lt;ul&gt;
      &lt;li&gt;$d \m{ val}$&lt;/li&gt;
      &lt;li&gt;$d \m{ err}$&lt;/li&gt;
      &lt;li&gt;$\exists d’ : \ok . d \mapsto d’$&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\square&lt;/script&gt;

&lt;h3 id=&quot;addition-in-dpcf&quot;&gt;Addition in DPCF&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
x + 0 &amp; = x \\
x + (\m{succ}(y)) &amp; = \m{succ}(x+y)
\end{align} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\m{fun}(x . \m{fix} (p . \m{fun} (y . \m{ifz} (y;x;y&#39;. \m{succ}(\m{app}(p; y&#39;))))))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\lambda(x) . \m{fix} \;p \m{ is } \lambda(y) \m{ifz} \{ \m{zero} \hookrightarrow x \;|\; \m{succ}(y&#39;) \hookrightarrow \m{succ}(p(y&#39;)) \}&lt;/script&gt;

&lt;p&gt;Despite looking a lot like addition would in PCF,&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;We have to check $\m{is_fun}\;p$ every recursive call of $p$ despite the fact that $p$ cannot be anything but a function. If we allowed unchecked function calls here, we’d have to allow it in situations where it would not be appropriate, like $\lambda f . f(\m{zero})$.&lt;/li&gt;
  &lt;li&gt;We have to check $\m{is_num}\; p(y’)$ every recursive call for $\m{succ}$.&lt;/li&gt;
  &lt;li&gt;We have to check $\m{is_num}\; y$ every recursive call for $\m{ifz}$.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Thus, this will be a lot slower than the same function in PCF.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Aside: If you wrote $\m{add}$ as a multi-argument function, we’re already introducing typing in the form of light pattern matching, since $\lambda(x,y)$ takes in $\langle \ok, \ok \rangle$ as an argument.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;conclusion&quot;&gt;Conclusion&lt;/h3&gt;
&lt;p&gt;Structural operational semantics and type systems are extremely useful for understanding programming languages, especially when coupled with machine-checked proofs (e.g. Twelf).&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Aside: A machine-checked proof ($\approx$ 30k lines of Twelf) was written in a couple weeks that proves the type safety of Standard ML.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;It’s far too complicated to prove the type safety of dynamic languages.&lt;/p&gt;
</description>
        <pubDate>Thu, 12 Feb 2015 13:30:00 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/02/12/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/02/12/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 9: Recursive Types, Objects and Dynamic Dispatch</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$
\def\self{\sf self\;}
\def\unroll{\sf unroll\;}
\def\fold{\sf fold\;}
\def\unfold{\sf unfold\;}
\def\fix{\sf fix\;}
\def\real{\sf real\;}
\def\bar{\;|\;}
\def\cart{\sf cart}
\def\polar{\sf polar}
\def\dist{\sf dist}
\def\quadrant{\sf quadrant}
\def\obj{\sf obj}
\def\new{\sf new}
\def\this{\sf this}
\def\case{\sf case}
$
&lt;/div&gt;

&lt;h1 id=&quot;pcf-continued&quot;&gt;PCF (continued)&lt;/h1&gt;

&lt;h2 id=&quot;recursive-types-continued&quot;&gt;Recursive Types (continued)&lt;/h2&gt;

&lt;h3 id=&quot;self-reference&quot;&gt;Self-reference&lt;/h3&gt;
&lt;p&gt;Imagine we want to extend the language with a new feature:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[

\begin{align*}
\tau ::= &amp; \cdots \bar \self(\tau) \\
e ::= &amp; \cdots \bar \self[\tau](x.e) \bar unroll(e)
\end{align*}
 %]]&gt;&lt;/script&gt;

&lt;p&gt;where the first expression is into, and the second elim.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\frac
{\Gamma, x : \self(\tau) \vdash : \tau}
{\Gamma \vdash \self[\tau](x.e) : \self(\tau)}
&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\frac
{\Gamma \vdash e : \self(\tau)}
{\Gamma \vdash \unroll(e) : \tau}
&lt;/script&gt;

&lt;p&gt;Actually, we can implement $\self$ and $\unroll$ with existing language constructs:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align*}
\self(\tau) &amp; \overset{def}{=} \mu\alpha.\alpha \to \tau \\
\self[\tau](x.e) &amp; \overset{def}{=} \fold[\alpha.\alpha \to \tau](\lambda x : \self(\tau).e) \\
\unroll(e) &amp; \overset{def}{=} \unfold(e)(e)
\end{align*} %]]&gt;&lt;/script&gt;

&lt;p&gt;Note that&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\fix[\tau](x.e) &amp; = \unroll(\self[\tau](y [\unroll y / x]\; e)) \\
&amp; \overset{*}{\mapsto} [\self[\tau](y [\unroll y / x]\; e) / y][\unroll y / x]\; e \\
&amp; = [\unroll (\self(y [\unroll y / x]\; e)) / x]\; e \\
&amp; = [\fix (x.e) / x]\; e
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;In Java and C++ (and similar languages), self-references (e.g. &lt;code&gt;this&lt;/code&gt;) are implemented this way.&lt;/p&gt;

&lt;h1 id=&quot;dynamic-dispatch&quot;&gt;Dynamic Dispatch&lt;/h1&gt;
&lt;p&gt;This is how we’re doing &lt;em&gt;object-oriented&lt;/em&gt; programming.&lt;/p&gt;

&lt;h2 id=&quot;notation&quot;&gt;Notation&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\langle e_1, e_2 \rangle, e \cdot l, e \cdot r&lt;/script&gt;

&lt;p&gt;is generalized to&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\langle l \hookrightarrow e_1, r \hookrightarrow e_2\rangle &lt;/script&gt;

&lt;p&gt;is further generalized to (arbitrary labels)&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\langle x \hookrightarrow e_1, y \hookrightarrow e_2\rangle &lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;A class is a particular implementation of an abstract type
    &lt;ul&gt;
      &lt;li&gt;A class is &lt;em&gt;code&lt;/em&gt;. A class is &lt;strong&gt;not a type&lt;/strong&gt;.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;An instance is a particular such particular \this&lt;/li&gt;
  &lt;li&gt;Instance data is the data associated with an instance.&lt;/li&gt;
  &lt;li&gt;An instance type is the type of the instance data, such as $\langle x \hookrightarrow \real, y \hookrightarrow \real \rangle$.&lt;/li&gt;
  &lt;li&gt;A method is a function on class values&lt;/li&gt;
  &lt;li&gt;Dispatch is applying a method to an instance&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;We define a &lt;em&gt;dispatch matrix&lt;/em&gt;. Let $C$ be the set of classes, and $D$ the set of methods. For every type $\tau$, let $\tau^c$ be the type of $c$’s instance data. Let $\rho_d$ be the type of $d$’s result.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\prod_{c \in C} \prod_{d \in D} \tau^c \to \rho_d
&lt;/script&gt;

&lt;h2 id=&quot;example-cartesian-and-polar-points&quot;&gt;Example: Cartesian and Polar Points&lt;/h2&gt;

&lt;p&gt;Let $C = \{\cart, \polar\}$ and $D = \{\dist, \quadrant \}$. Then,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e^{\cart}_{\dist} = \lambda u : \tau^{\cart} . \sqrt{(u \cdot x)^2 + (u \cdot y)^2}&lt;/script&gt;

&lt;p&gt;We introduce $\obj$, with intro form &lt;script type=&quot;math/tex&quot;&gt;\new[c](e)&lt;/script&gt; and elimination form $e \Leftarrow d$.&lt;/p&gt;

&lt;h2 id=&quot;class-based-organization&quot;&gt;Class-based organization&lt;/h2&gt;
&lt;p&gt;We have a class vector ($cv$):&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\prod_{c \in C} \tau^c \to \prod_{d \in D} \rho_d&lt;/script&gt;

&lt;p&gt;$\prod_{d \in D} \rho_d$ is the object (\obj).&lt;/p&gt;

&lt;p&gt;Given a class and instance data, return all the methods.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e \Leftarrow d \overset{def}{=} e \cdot d&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e^c \overset{def}{=} \lambda u : \tau^c . \langle e_{dm} \cdot c \cdot d(u) \rangle_{d \in D}&lt;/script&gt;

&lt;p&gt;where $dm$ refers to the dispatch matrix.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e_{cv} = \langle e \hookrightarrow e^c \rangle_{c \in C}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\new[c](e) = e_{cv} \cdot c(e)&lt;/script&gt;

&lt;h2 id=&quot;method-based-organization&quot;&gt;Method-based organization&lt;/h2&gt;
&lt;p&gt;We have a method vector ($mv$):&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\prod_{d \in D} \sum_{c \in C} \tau^c \to \rho_d&lt;/script&gt;

&lt;p&gt;$\sum_{c \in C} \tau^c$ is the object.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\new[c](e) \overset{def}{=} c \cdot e&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e_d = \lambda \this . (\sum_{c \in C} \tau^c).\case \this \\{
c \cdot u \Rightarrow e_{dm} \cdot c \cdot d(u) \\} &lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e_{mv} \overset{def}{=} \langle d \hookrightarrow e_d \rangle_{d \in D}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e \Rightarrow d \overset{def}{=} e_{mv} \cdot d(e)&lt;/script&gt;

&lt;p&gt;This approach is called “multimethod,” and is used in Cecil and Diesel.&lt;/p&gt;
</description>
        <pubDate>Tue, 10 Feb 2015 13:30:00 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/02/10/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/02/10/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>76-221 Class 9: As You Like It</title>
        <description>&lt;h1 id=&quot;the-odyssey-and-as-you-like-it&quot;&gt;The &lt;em&gt;Odyssey&lt;/em&gt; and &lt;em&gt;As You Like It&lt;/em&gt;&lt;/h1&gt;
&lt;p&gt;The &lt;em&gt;Odyssey&lt;/em&gt; says that to be a person is to contribute to culture and society, to civilization. It holds civilization about nature.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;AYLI&lt;/em&gt;, on the other hand, presents nature (at first glance) as morally superior to civilization. It asks in response to the &lt;em&gt;Odyssey&lt;/em&gt;, “What if civilization is corrupt?” and “What are civilization and nature, anyway?”&lt;/p&gt;

&lt;h1 id=&quot;section&quot;&gt;3.2.5&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;these trees shall be my books&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As Orlando nails his poetry to trees in the forest, he is, in some sense, civilizing nature.&lt;/p&gt;

&lt;h1 id=&quot;section-1&quot;&gt;2.4.22-40&lt;/h1&gt;
&lt;p&gt;According to Silvus, love is when one is driven to crazy actions. This is exemplified by Orlando, Rosalind, etc.&lt;/p&gt;

&lt;h1 id=&quot;section-2&quot;&gt;2.4.40&lt;/h1&gt;
&lt;p&gt;Consider how different seeing a play and reading a play is, and the cues a performance must take from the text. For instance, the line “Oh Phoebe Phoebe Phoebe” could be &lt;em&gt;incorrectly&lt;/em&gt; delivered as sad and anguished, but given the context, should be delivered with fake spontaneity and excitement.&lt;/p&gt;

&lt;h1 id=&quot;section-3&quot;&gt;3.2.13-21&lt;/h1&gt;
&lt;p&gt;The entire monologue is in one sense mocking the life of shepherd, but ultimately is saying how a shepherd’s life is not one for a fool.&lt;/p&gt;

&lt;h1 id=&quot;section-4&quot;&gt;3.2.356-66&lt;/h1&gt;
&lt;p&gt;You have to perform being in love to truly be in love. For instance, flowers and the spectacle of Valentine’s Day.&lt;/p&gt;
</description>
        <pubDate>Tue, 10 Feb 2015 09:00:00 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/76221/2015/02/10/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/76221/2015/02/10/</guid>
        
        
        <category>cmu</category>
        
        <category>76221</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 8: PCF</title>
        <description>&lt;h1 id=&quot;pcf-partial-computable-functions&quot;&gt;PCF (Partial Computable Functions)&lt;/h1&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\tau &amp; ::= \textsf{nat} \;|\; \tau \rightharpoonup \tau \\
e &amp; ::= x \;|\; z \;|\; s(e) \;|\; \lambda x : \tau . e \;|\; ee \;|\; \textsf{ifz}e,e_0,x.e_1) \;|\; \textsf{fix}[\tau](x.e)
\end{align} %]]&gt;&lt;/script&gt;

&lt;h2 id=&quot;static-semantics&quot;&gt;Static Semantics&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;[missing]&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;fixed-point&quot;&gt;Fixed Point&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Fe \cong e&lt;/script&gt;

&lt;h2 id=&quot;definability&quot;&gt;Definability&lt;/h2&gt;
&lt;p&gt;$f$ is definable if there exists some $e_f$ such that&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(n) = m \iff e_f(\bar{n}) \equiv \bar{m} : \textsf{nat}&lt;/script&gt;

&lt;h2 id=&quot;universal-function&quot;&gt;Universal Function&lt;/h2&gt;
&lt;p&gt;We can now have infinite loops through recursion:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e_D \equiv s(e_D) : \textsf{nat}&lt;/script&gt;

&lt;p&gt;This means we can implement a universal function (recall that we couldn’t in Gödel’s T).&lt;/p&gt;

&lt;p&gt;The class of partial computable functions are exactly those in PCF. PCF is known as the &lt;em&gt;E. coli&lt;/em&gt; of programming languages, because its constructs show in up in many, many other programming languages.&lt;/p&gt;

&lt;h2 id=&quot;conservative-extensions&quot;&gt;Conservative Extensions&lt;/h2&gt;
&lt;p&gt;Conservative extensions leave the pre-existing constructs alone. For instance, adding products and sums to $\mathcal{L}(\textsf{num}\;\textsf{str})$ did not disturb existing semantics; it just added more of them. Adding recursion is not a conservative extension, because it changes the existing language. This is why you can’t just dump your favorite features from several different languages into one, and expect the new language to work well.&lt;/p&gt;

&lt;h2 id=&quot;datatypes&quot;&gt;Datatypes&lt;/h2&gt;
&lt;p&gt;$\textsf{nat}$ is no longer a primitive type, but a definable type.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\textsf{datatype}\;\textsf{exp} &amp; = \textsf{Var of variable} \\
&amp; \;|\; \textsf{Lam} \textsf{ of } \textsf{exp} * (\textsf{variable} * \textsf{exp})\\
&amp; \;|\; \textsf{App of } \textsf{exp} * \textsf{exp} \\
&amp; \;|\; \textsf{Unit of unit} \\\\

\textsf{datatype}\;\textsf{nat} &amp; = Z \;|\; S \textsf{ of } \textsf{nat} \\

\textsf{nat} &amp; \cong \textsf{unit} + \textsf{nat}
\end{align} %]]&gt;&lt;/script&gt;

&lt;h2 id=&quot;recursive-types&quot;&gt;Recursive Types&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\tau ::= \cdots \;|\; \mu \alpha.\tau | \alpha&lt;/script&gt;

&lt;p&gt;Now we can have “bad” types: in $\lambda x.\alpha \ldots$, $\alpha$ is an unbound type. Thus, we need typing semantics:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\tau \textsf{ type}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\textsf{unit} \textsf{ type}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\tau_1 \textsf{ type} \;\;\;\; \tau_2 \textsf{ type}}
{\tau_1 \rightharpoonup \tau_2 \textsf{ type}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\alpha \;|\; \alpha \textsf{ type} \vdash \tau \textsf{ type}}
{\mu\alpha.\tau \textsf{ type}}&lt;/script&gt;

&lt;p&gt;which is the same as&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\Gamma, \alpha \textsf{ type} \;\;\;\; \Gamma, \tau \textsf{ type}}
{\Gamma \vdash \mu\alpha.\tau \textsf{ type}}&lt;/script&gt;

&lt;p&gt;All types we can write are closed. They can have bound variables, but no free variables.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mu\alpha.\tau \cong [\mu\alpha.\tau \;/\; \alpha]\; \tau&lt;/script&gt;

&lt;p&gt;We can define type equivalence in terms of $\equiv$ (equi-recursive types), or $\rightleftarrows$ (iso-recursive types / isomorphic). We choose to define types in terms of iso-recursive types, because it’s more straightforward. This is also how ML does it.&lt;/p&gt;

&lt;p&gt;There are two operations that mediate this isomorphism:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e ::= \cdots \;|\; \textsf{unfold}(e) \;|\; \textsf{fold}(e)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\Gamma \vdash e : \mu\alpha.\tau}
{\Gamma \vdash \textsf{unfold}(e) : [\mu\alpha . \tau \;/\; \alpha]\; \tau}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\Gamma \vdash e : [\mu\alpha . \tau \;/\; \alpha]\; \tau}
{\Gamma \vdash \textsf{fold}(e) : \mu\alpha.\tau}&lt;/script&gt;

&lt;p&gt;We need to add the type we expect to obtain from folding to $\textsf{fold}$ to make the typing rules unambiguous:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e ::= \cdots \;|\; \textsf{unfold}(e) \;|\; \textsf{fold}[\alpha . \tau](e)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\Gamma \vdash e : [\mu\alpha . \tau \;/\; \alpha]\; \tau}
{\Gamma \vdash \textsf{fold}[\alpha . \tau](e) : \mu\alpha.\tau}&lt;/script&gt;

&lt;p&gt;We can do programming in this language! We apparently don’t have recursion at first glance, but recursive types are actually a conservative extension that will let us do recursion.&lt;/p&gt;

&lt;h3 id=&quot;values-of-mu-alpha--tau&quot;&gt;Values of $\mu \alpha . \tau$&lt;/h3&gt;
</description>
        <pubDate>Thu, 05 Feb 2015 13:30:00 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/02/05/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/02/05/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>76-221 Class 8: As You Like It</title>
        <description>&lt;p&gt;Since we didn’t have class, the professor, Alan Kennedy, posted some notes:&lt;/p&gt;

&lt;h1 id=&quot;where-we-left-off&quot;&gt;Where We Left Off&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;At the end of last class we were discussing Jaques’ speech about all the world being a stage. We were in the process of dismantling his speech, recognizing that it may be nothing more than a filler while waiting for the return of Orlando with Adam. The negative view of the world that the speech offers is in fact countered by the very positive, generous act of helping an old man. None of Jaques’ stages encounter this kind of selfless act. The speech seems to suggest that there is no variation possible, that the system of 7 ages is rigid and fixed for everybody. Note that none of the characters on stage react to his speech, neither approving it or disapproving. It just runs past them. We left off with the idea that we might look for more flexible ideas of time in the rest of the play. To that end we already have the comments of Touchstone when he pulls out his watch and notes that the world wags on from hour to hour. That too seems a foolish, or perhaps comic or satirical speech. The response to such a speech might be:  Of course. We have also noted that in the Forest of Arden the exiles ‘fleet the time carelessly’, which seems to say that there are different kinds of time, or at least different ways of experiencing it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;whats-jaques-story&quot;&gt;What’s Jaques’ Story?&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;We read his speech and found it wanting. In what ways? It seemed altogether too negative we said. It looked like filler between Orlando’s leaving and his return with Adam. Orlando’s generosity seemed in direct contradiction to the nihilism of the speech. Too negative, but also consistently negative. So consistent that it begins to look like a fixed attitude, and &lt;em&gt;idee fixe&lt;/em&gt; as it’s sometimes called.&lt;/p&gt;

  &lt;p&gt;Jaques gives the game away when he describes his penchant for melancholy, see p.139 lines 10–15. He thrives on melancholy. On p.115 we learn that the old Duke has a similar condition. He is described as being ‘humourous’. This does not mean he makes jokes and laughs a lot. Just the opposite. It means that he suffers from an excess of the one the four ‘humours’, or fluids in the body (humor as in humid). The four essential bodily fluids needed to be balanced for a condition of health. Too much of one produced an imbalance in the personality. So having too much blood made one sanguine (French sang, for blood), or bloody, given to anger and violence. The 4 fluids are black and yellow bile, phlegm and blood. Having too much phlegm made one phlegmatic, a word we still use. Too much black bile made one melancholic, and that is the nature of Jaques’ personality imbalance. It seems more than that, however, he seems to cultivate his melancholy, to enjoy it, perform it. So he is in the final analysis a person who is not at all flexible by nature. By constitution and by personal choice he has fixated himself on a narrow view of the world. He is like the irrational rulers who fix upon one pattern behavior, exile, and don’t shift positions readily.&lt;/p&gt;

  &lt;p&gt;We could note here that Rosalind does not seem to suffer from this kind of personality fixation. She is very willing to adopt a disguise and pretend to be a man in order to keep things moving along. She remains herself even while disguised.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h1 id=&quot;who-is-flexible&quot;&gt;Who Is Flexible?&lt;/h1&gt;
&lt;blockquote&gt;
  &lt;p&gt;Well, the exiled have to be, Orlando seems to be, falling back on primal strength, relying on the body alone rather than a fixed social position. If rigidity is to be associated with power, position, then it is likely to be characteristic of men rather than women; women are exiled from power and subject to the whims of ruling males. So Rosalind looks like a key example of flexibility. She hints at one point, however, that flexibility might be available in other ways. When she puts on male costume in Act i, she has to act like a man in order to offer at least symbolic protection to ‘Aliena’–whose very ‘name’ suggests the outcast status. On p. 121 Celia accuses Rosalind of lacking the love “Which teacheth thee that thou and I are one.” that hints at an extreme degree of flexibility in personality, if one person can in fact be another person. it also suggests that there is a kind of love that is not a sickness, not a disaster. Rosalind puts on a pretense of being somebody else when she dons a disguise. On p. 123 she says:&lt;/p&gt;

  &lt;blockquote&gt;
    &lt;p&gt;We’ll have a swashing and a martial outside,As many other mannish cowards have,&lt;br /&gt;
That do outface it with their semblances.&lt;/p&gt;
  &lt;/blockquote&gt;

  &lt;p&gt;She soon begins to show that ‘semblances’, pretenses, might have positive real consequences.&lt;/p&gt;

  &lt;p&gt;On p. 135 she bucks up her courage:&lt;/p&gt;

  &lt;blockquote&gt;
    &lt;p&gt;But I must comfort the weaker vessel as doublet and hose ought to show itself courageous to petticoat.&lt;/p&gt;
  &lt;/blockquote&gt;

  &lt;p&gt;She takes courage, that is to say, from the pretense at courage. Which suggests that playing at something might produce that something.&lt;/p&gt;

  &lt;p&gt;And of course it is at a point like this that we remind ourselves that all of Shakespeare’s intent lies in producing semblances, pretenses.&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Thu, 05 Feb 2015 09:00:00 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/76221/2015/02/05/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/76221/2015/02/05/</guid>
        
        
        <category>cmu</category>
        
        <category>76221</category>
        
      </item>
    
  </channel>
</rss>
