<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Notes</title>
    <description>Notes on classes at CMU.
</description>
    <link>http://www.tomshen.me/notes/</link>
    <atom:link href="http://www.tomshen.me/notes/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 24 Mar 2015 14:45:06 -0400</pubDate>
    <lastBuildDate>Tue, 24 Mar 2015 14:45:06 -0400</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>15-312 Lecture 18: Representation Independence</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}
\def\a{\alpha}
\def\b{\beta}
\def\t{\tau}

\def\natt{\m{nat}}
\def\boolt{\m{bool}}
\def\unitt{\m{unit}}
\def\voidt{\m{void}}

\def\unit{\langle \rangle}

\def\tt{\m{true}}
\def\ff{\m{false}}

\def\prove{\vdash}

\renewcommand\fun[3]{\lambda #1 : #2 . #3}
\renewcommand\Fun[2]{\Lambda #1 . #2}

\def\typet{\m{type}}
\renewcommand\type[1]{#1 : \typet}

\renewcommand\allt[2]{\forall #1.#2}
\renewcommand\prodt[2]{#1 \times #2}
\renewcommand\pair[2]{\langle #1, #2 \rangle}
\renewcommand\App[2]{#1[#2]}
\renewcommand\subst[3]{[#1 / #2] #3}

\renewcommand\existst[2]{\exists #1.#2}
\renewcommand\pack[4]{\m{pack}~[#1,#2]~\m{as}~\exists #3.#4}
\renewcommand\open[4]{\m{open}~[#1,#2] = #3~\m{in}~#4}

\def\defeq{\overset{def}{=}}
$$
&lt;/div&gt;

&lt;h1 id=&quot;polymorphism-continued&quot;&gt;Polymorphism (continued)&lt;/h1&gt;

&lt;h2 id=&quot;data-asbstraction--existential-types&quot;&gt;Data asbstraction / existential types&lt;/h2&gt;

&lt;p&gt;An existential type is of the form&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\existst{\a}{\t}&lt;/script&gt;

&lt;p&gt;This forces us to be parametric on &lt;script type=&quot;math/tex&quot;&gt;\a&lt;/script&gt;. We introduce&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\pack{\t}{e}{\a}{\t&#39;}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\open{\a}{x}{e}{e&#39;}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx\prove \type{\t} \qquad \ctx\prove e : \subst{\t}{\a}{\t&#39;} \qquad \ctx,\type{\a} \prove \type{\t&#39;}}
{\ctx \prove \pack{\t}{e}{\a}{\t&#39;} : \existst{\a}{\t&#39;}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \prove e_1 : \existst{\a}{\t} \qquad \ctx, \type{\a}, x : \t \prove e_2 : \t&#39; \qquad \ctx \prove \type{\t&#39;}}
{\ctx \prove \open{\a}{x}{e_1}{e_2} : \t&#39;}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;{\tt
sig \\
  type~\tau \\
  val~init : \tau \\
  val~flip : t \to \tau \\
  val~out : t \to \m{bool} \\
end
}&lt;/script&gt;

&lt;p&gt;We actually don’t need explicit existential types, because we can implement them in terms of universal types.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\existst{\a}{\t} &amp; \defeq \allt{\b}{(\allt{\a}{\t \to \b}) \to \b} \\
\pack{\t}{e}{\a}{\t&#39;} &amp; \defeq \Fun{\b}{\fun{f}{(\allt{\a}{\t&#39; \to \b})}{f~\t~e}} \\
\open{\a}{x}{e_1}{e_2} &amp; \defeq \App{e_1}{\t&#39;}(\Fun{\a}{\fun{x}{\tau}{e_2}})
\end{align} %]]&gt;&lt;/script&gt;

&lt;h2 id=&quot;representation-independence--abstraction-theoremhttpwwwandrewcmueducourse15-312notesmar-20pdf&quot;&gt;&lt;a href=&quot;http://www.andrew.cmu.edu/course/15-312/notes/mar-20.pdf&quot;&gt;Representation Independence / Abstraction Theorem&lt;/a&gt;&lt;/h2&gt;

&lt;h3 id=&quot;equivalence&quot;&gt;Equivalence&lt;/h3&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\alpha&lt;/script&gt;-equivalence is when two terms are exactly the same, except for variable names. This is the strictest form of equivalence.&lt;/p&gt;

&lt;p&gt;Trivial equivalence is when everything is said to be equivalent. This is pretty useless.&lt;/p&gt;

&lt;p&gt;We will discuss &lt;em&gt;contexual&lt;/em&gt; and &lt;em&gt;logical&lt;/em&gt; equivalence, which are the same.&lt;/p&gt;

&lt;p&gt;Two terms are contextually equivalent if any program we embed those terms into cannot tell the difference between the two terms. This is pretty well motivated–we want to know if this is the case all the time. However, it’s hard to work with, since in theory, to show it, we have to check all possible inputs.&lt;/p&gt;

&lt;p&gt;Contexual: &lt;script type=&quot;math/tex&quot;&gt;e \cong e&#39; : \t&lt;/script&gt;&lt;br /&gt;
Logical: &lt;script type=&quot;math/tex&quot;&gt;e \sim e&#39; : \t&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;(Special case of) Reynold’s Abstraction Theorem: If &lt;script type=&quot;math/tex&quot;&gt;\prove e : \t&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;e \sim e : \t&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Logical relation:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
e \sim e&#39; : \boolt &amp; \iff (e \mapsto^* \tt \wedge e&#39; \mapsto^* \tt) \vee (e \mapsto^* \ff \wedge e&#39; \mapsto^* \ff) \\
e \sim e&#39; : \unitt &amp; \iff \m{yes} \\
e \sim e&#39; : \natt &amp; \iff \exists n . e \mapsto^* \bar{n} \wedge e&#39; \mapsto \bar{n} \\
e \sim e&#39; : \t_1 \to \t_2 &amp; \iff \forall v, v&#39; . \m{if}~v \sim v&#39; : \t_1, \m{then}~e~v\sim e&#39;~v&#39; : \t_2 \\
e \sim e&#39; : \t_1 \times \t_2 &amp; \iff e \cdot l \sim e&#39; \cdot l : \tau_1 \vee e \cdot r \sim e&#39; \cdot r : \t_2 \\
e \sim e&#39; : \allt{\a}{\t} &amp; \iff \forall \t_1, \t_2 . \forall R : \t_1 \leftrightarrow \t_2 . \App{e}{\t_1} \sim \App{e&#39;}{\t_2} : \subst{R}{\a}{\t} \\
e \sim e&#39; : R &amp; \iff e~R~e&#39;
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;We’re using quasi-types:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;q ::= \boolt \mid \natt \mid \unitt \mid q \to q \mid q \times q \mid \allt{\a}{q} \mid R&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;R \subseteq \{ e\mid e : \t_1 \} \times \{ e \mid e : \t_2 \}&lt;/script&gt;

&lt;p&gt;such that &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; is closed under equivalence. Thus, reflexivity is no longer obvious, which makes the abstraction theorem so useful.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;M_1 = \pack{\boolt}{\pair{\ff}{\pair{\natt}{\lambda x . x}}}{\a}{\a \times (\a \to \a) \times \a \to \boolt}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;M_2 = \pack{\natt}{\pair{\bar{0}}{\pair{\m{succ}}{\m{odd?}}}}{\a}{\a \times (\a \to \a) \times \a \to \boolt}&lt;/script&gt;

&lt;p&gt;We can prove that &lt;script type=&quot;math/tex&quot;&gt;M_1 \sim M_2 : \existst{\a}{\a \times (\a \to \a) \times \a \to \boolt}.&lt;/script&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 24 Mar 2015 13:27:21 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/03/24/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/03/24/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 17: Polymorphism</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}
\def\a{\alpha}
\def\t{\tau}

\def\natt{\m{nat}}
\def\boolt{\m{bool}}
\def\unitt{\m{unit}}
\def\voidt{\m{void}}

\def\unit{\langle \rangle}

\def\prove{\vdash}

\renewcommand\fun[3]{\lambda #1 : #2 . #3}
\renewcommand\Fun[2]{\Lambda #1 . #2}

\def\typet{\m{type}}
\renewcommand\type[1]{#1~\typet}

\renewcommand\allt[2]{\forall(#1.#2)}
\renewcommand\prodt[2]{#1 \times #2}
\renewcommand\pair[2]{\langle #1, #2 \rangle}
\renewcommand\App[2]{#1[#2]}
\renewcommand\subst[3]{[#1 / #2] #3}
$$
&lt;/div&gt;

&lt;h1 id=&quot;polymorphism-continued&quot;&gt;Polymorphism (continued)&lt;/h1&gt;

&lt;h2 id=&quot;type-safety&quot;&gt;Type Safety&lt;/h2&gt;

&lt;p&gt;Preservation and progress do hold. See &lt;em&gt;PFPL&lt;/em&gt; for more details.&lt;/p&gt;

&lt;p&gt;To prove preservation for&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\App{(\Fun{\alpha}{e})}{\tau} \to \subst{\tau}{\alpha}{e}}&lt;/script&gt;

&lt;p&gt;we need a substitution lemma (type substitution).&lt;/p&gt;

&lt;h2 id=&quot;language-constructs&quot;&gt;Language Constructs&lt;/h2&gt;

&lt;p&gt;Recall natural numbers from the untyped lambda calculus:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\bar{0} = \lambda z . \lambda s . z&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\overline{n+1} = \lambda z . \lambda s . s ~ (\bar{n} ~ z ~ s)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\natt: b \to (b \to b) \to b&lt;/script&gt;

&lt;p&gt;We need to fix $b$ to be a specific type, which works in an untyped language (type is just &lt;script type=&quot;math/tex&quot;&gt;\m{dyn}&lt;/script&gt;) but not in the typed lambda calculus.&lt;/p&gt;

&lt;p&gt;With polymorphism, we can make this work:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\natt &amp; = \allt{\alpha}{\alpha \to (\alpha \to \alpha) \to \alpha} \\
\bar{0} &amp; = \Fun{\alpha}{\fun{z}{\alpha}{\fun{s}{\alpha \to \alpha}{z}}} \\
\overline{n+1} &amp; = \Fun{\alpha}{\fun{z}{\alpha}{\fun{s}{\alpha \to \alpha}{s~(\App{\bar{n}}{\alpha}~z~s)}}} \\
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;We can also implement other constructs we’ve seen in this class:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\boolt &amp; = \allt{\alpha}{\alpha \to \alpha \to \a} \\
\overline{\m{true}} &amp; = \Fun{\alpha}{\fun{x}{\a}{\fun{y}{\a}{x}}}
\end{align} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\prod{\tau_1}{\tau_2} &amp; = \allt{\a}{(\tau_1 \to \tau_2 \to \a) \to \a} \\
\overline{\pair{e}{e&#39;}} &amp; = \Fun{\a}{\fun{f}{\t_1 \to \t_2 \to \a}{f~e~e&#39;}} \\
\m{outl}_{\t_1,t_2}~e &amp; = \App{e}{\t_1}(\fun{x}{\t_1}{\fun{y}{\t_2}{x}})
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;System-F also has sum types, though it does &lt;em&gt;not&lt;/em&gt; have recursive types, because all programs terminate.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\unitt &amp; = \allt{\a}{\a \to \a} \\
\overline{\unit} &amp; = \Fun{\a}{\fun{x}{\a}{x}} \\
\voidt &amp; = \allt{\a}{\a} \\
\overline{\m{abort}_\t~e} &amp; = \App{e}{\t}
\end{align} %]]&gt;&lt;/script&gt;

&lt;h2 id=&quot;natural-numbers&quot;&gt;Natural Numbers&lt;/h2&gt;
&lt;p&gt;We claim that our definition of natural numbers &lt;em&gt;are the natural numbers&lt;/em&gt;: there is nothing else in the type. Similarly, for &lt;script type=&quot;math/tex&quot;&gt;\unitt&lt;/script&gt;, if &lt;script type=&quot;math/tex&quot;&gt;e : \unitt&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;e \cong \Fun{\a}{\fun{x}{\a}{x}}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Proving this rigorously takes an additional semester of math. But, in short, this proof relies on &lt;em&gt;parametricity&lt;/em&gt;. Since we can’t branch on type, we have parametric polymorphism. Consider&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e \cong \Fun{\alpha}{\fun{x}{\a}{\_}}&lt;/script&gt;

&lt;p&gt;Because we can’t branch on &lt;script type=&quot;math/tex&quot;&gt;\a&lt;/script&gt;, and because $\a$ is unknown, the only way to produce a value of type &lt;script type=&quot;math/tex&quot;&gt;\a&lt;/script&gt; is to fill in the blank with &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;If the language allowed for non-terminating programs (recursion), then for &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt; to have type &lt;script type=&quot;math/tex&quot;&gt;\alpha&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;e \cong \bot&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\Fun{\a}{\bot}&lt;/script&gt;, or &lt;script type=&quot;math/tex&quot;&gt;\Fun{\alpha}{\fun{x}{\a}{\bot}}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;The Parametricity Theorem is also called the Abstraction Theorem, which is an important part of modular programming. It basically says that we can have a program composed of separate pieces that can possibly work.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Crary claims that the Abstraction Theorem is the most important theorem in computer science.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;impredicative-types&quot;&gt;Impredicative Types&lt;/h2&gt;

&lt;p&gt;In &lt;script type=&quot;math/tex&quot;&gt;\allt{\a}{\t}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\a&lt;/script&gt; ranges over a collection (possibly not a set) of types that includes &lt;script type=&quot;math/tex&quot;&gt;\allt{\a}{\t}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;In ML, we have &lt;em&gt;predicative&lt;/em&gt; types. There are monotypes (&lt;script type=&quot;math/tex&quot;&gt;\tau ::= \a \mid \t \to \t&lt;/script&gt;) and polytypes (&lt;script type=&quot;math/tex&quot;&gt;\sigma ::= \t \mid \allt{\a}{\sigma}&lt;/script&gt;). Note that the &lt;script type=&quot;math/tex&quot;&gt;\forall&lt;/script&gt; ranges over monotypes, not polytypes. This lets ML hide all quanitifies, and it uses prenex quantification to put all the quantifies at the front of the type.&lt;/p&gt;

&lt;h2 id=&quot;value-restriction&quot;&gt;Value Restriction&lt;/h2&gt;
&lt;p&gt;[&lt;em&gt;I’m not sure I understand this explanation.&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;Why does ML blow up if you have &lt;code&gt;val x = rev nil&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Consider&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val x = (print &quot;hello&quot;; nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we let this have the type &lt;code&gt;&#39;a list&lt;/code&gt;, then &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; would be a value. Whenever &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; is used, “hello” will be printed. Thus, we can introduce unexpected side effects to our program.&lt;/p&gt;

&lt;p&gt;This is commonly, &lt;em&gt;incorrectly&lt;/em&gt; believed to be to preserve type safety. (For what it’s worth, &lt;a href=&quot;http://mlton.org/ValueRestriction&quot;&gt;MLTon claims this&lt;/a&gt;.) The concern is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val r = ref NONE;
val () = r := SOME 12;
val x = case !(r : (int -&amp;gt; int) option ref) of
            NONE =&amp;gt; ...
          | SOME f =&amp;gt; f 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, a new reference &lt;script type=&quot;math/tex&quot;&gt;r&lt;/script&gt; is being generated each time, so while the behavior is unexpected, it does not break type safety. The reason it’s believed this breaks type safety is that it’s incorrectly believed there should be a rule&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \mapsto e&#39;}
{\Fun{\a}{e} \mapsto \Fun{\a}{e&#39;}}&lt;/script&gt;
</description>
        <pubDate>Thu, 19 Mar 2015 13:30:50 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/03/19/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/03/19/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 16: Aliasing, Free References, Polymorphism (System F)</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\newcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\newcommand\ok[1]{#1~~\m{ok}}
\newcommand\oks[1]{#1~~\m{ok}_{\sig}}
\def\natt{\m{nat}}
\def\gap{\hspace{1cm}}
\def\valt{\m{val}}
\newcommand\val[1]{#1~\valt}
\newcommand\vals[1]{#1~\valt_{\scriptscriptstyle\sig}}
\newcommand\valsx[2]{#1~\valt_{\scriptscriptstyle\sig, #2}}
\def\gt{\mapsto}
\def\gts{\gt_{\scriptscriptstyle\sig}}
\newcommand\gtsx[1]{\gt_{\scriptscriptstyle\sig, #1}}
\def\defeq{\overset{def}{=}}

\def\prove{\vdash}
\def\provesig{\prove_{\scriptscriptstyle\sig}}
\def\provee{\prove_{\emptyset}}
\newcommand\provesigx[1]{\prove_{\scriptscriptstyle \sig,#1}}

\def\cmdt{\m{cmd}}
\newcommand\cmd[1]{\cmdt~(#1)}

\newcommand\ret[1]{\m{ret}~(#1)}

\newcommand\bnd[3]{\m{bnd}~#1 \leftarrow #2; #3}
\newcommand\bind[3]{\{ #1 \leftarrow #2; #3 \}}

\newcommand\final[1]{#1~\m{final}_{\scriptscriptstyle\sig}}
\newcommand\finalx[2]{#1~\m{final}_{\scriptscriptstyle\sig,#2}}

\def\midd{~||~}

\newcommand\do[1]{\m{do}~#1}

\newcommand\ifelse[3]{\m{if}~(#1)~#2~\m{else}~#3}
\newcommand\while[2]{\m{while}~(#1)~#2}

\newcommand\ifz[4]{\m{ifz}(#1;#2;#3.#4)}
\newcommand\fix[3]{\m{fix}~#1:#2~#3}

\newcommand\dcl[3]{\m{dcl}~#1 := #2~\m{in}~#3}
\newcommand\dcla[3]{\m{dcl}(#1; #2.#3)}
\newcommand\dclt[4]{\m{dcl}_{#1}~#2 := #3~\m{in}~#4}

\newcommand\get[1]{@#1}
\newcommand\geta[1]{\m{get}[#1]}

\newcommand\set[2]{#1 := #2}
\newcommand\seta[2]{\m{set}[#1](#2)}

\newcommand\fun[3]{\lambda #1 : #2 . #3}

\def\qquad{~~~~}

\newcommand\mobile[1]{#1~\m{mobile}}
\def\voidt{\m{void}}
\def\unitt{\langle \rangle}

\newcommand\reft[1]{\m{ref}(#1)}
\newcommand\ref[1]{\&amp;amp;#1}
\newcommand\getref[1]{*#1}
\newcommand\setref[2]{#1 := #2}
\newcommand\newref[2]{\m{newref}_{#1} #2}

\newcommand\state[3]{\nu (#1) \{ #2 \midd #3 \}}
\newcommand\statesig[2]{\nu \sig \{ #1 \midd #2 \}}
$$
&lt;/div&gt;

&lt;h1 id=&quot;modernized-algol-continued&quot;&gt;Modernized Algol (continued)&lt;/h1&gt;

&lt;h2 id=&quot;references-continued&quot;&gt;References (continued)&lt;/h2&gt;

&lt;h3 id=&quot;aliasing&quot;&gt;Aliasing&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
e \mathrel{+}= e&#39; &amp; \defeq \bind{x}{\getref{e}}{\bind{y}{\getref{e&#39;}}{\setref{e}{(x+y)}}}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Two references that govern the same underlying assignable are said to be &lt;em&gt;aliases&lt;/em&gt;. The possibility of aliasing complicates reasoning about the correctness of code that uses references, for we must always consider for any two references whether or not they might be aliases.&lt;/p&gt;

&lt;h2 id=&quot;free-assignables&quot;&gt;Free Assignables&lt;/h2&gt;

&lt;p&gt;In order to be able to have mutable data structures, we need assignables that can live outside the scopes of their declarations. We call these &lt;em&gt;scope-free&lt;/em&gt; or &lt;em&gt;free&lt;/em&gt; assignables.&lt;/p&gt;

&lt;p&gt;We change &lt;script type=&quot;math/tex&quot;&gt;\m{dcl}&lt;/script&gt; to add assignables to the state.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\statesig{m}{\mu}&lt;/script&gt;

&lt;p&gt;represents a state where the assignables &lt;script type=&quot;math/tex&quot;&gt;m \midd \mu&lt;/script&gt; are bound. &lt;script type=&quot;math/tex&quot;&gt;\nu&lt;/script&gt; is purely for notational purposes.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\vals{e}}
{\statesig{\dclt{\tau}{a}{e}{m}}{\mu} \gt \state{\sig,a \sim \tau}{m}{(\mu, a \hookrightarrow e)}}&lt;/script&gt;

&lt;p&gt;We don’t need a mobility condition for&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig{e : \tau} \qquad \ctx \provesigx{a \sim \tau}{m \sim \tau&#39;}}
{\ctx \provesig{\dclt{\tau}{a}{e}{m \sim \tau&#39;}}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\newref{\tau}{e} \defeq \dclt{\tau}{a}{e}{\ref{a}}&lt;/script&gt;

&lt;p&gt;&lt;em&gt;[backpatching to implement recursion]&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;preservation&quot;&gt;Preservation&lt;/h3&gt;

&lt;p&gt;If &lt;script type=&quot;math/tex&quot;&gt;\statesig{m}{\mu} \gt \statesig{m&#39;}{\mu&#39;}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\provesig{m \sim \tau}&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;\provesig{\mu : \sig}&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;\prove_{\scriptscriptstyle\sig&#39;} m&#39; \sim \tau&lt;/script&gt;,  &lt;script type=&quot;math/tex&quot;&gt;\prove_{\scriptscriptstyle\sig&#39;} \mu&#39; : \sig&#39;&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;\sig&#39;&lt;/script&gt; extends &lt;script type=&quot;math/tex&quot;&gt;\sig&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Note that in languages with &lt;script type=&quot;math/tex&quot;&gt;\m{free}&lt;/script&gt; (such as C), it is not always the case that &lt;script type=&quot;math/tex&quot;&gt;\sig&#39;&lt;/script&gt; extends &lt;script type=&quot;math/tex&quot;&gt;\sig&lt;/script&gt;. We would need a lot more sophistication in order to have a working type system. Most languages with &lt;script type=&quot;math/tex&quot;&gt;\m{free}&lt;/script&gt; are just broken.&lt;/p&gt;

&lt;h1 id=&quot;polymorphism&quot;&gt;Polymorphism&lt;/h1&gt;

&lt;p&gt;We will be discussing a language called System F, also known as polymorphic lambda calculus. We will have bare type variables.&lt;/p&gt;

&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}

\def\prove{\vdash}

\renewcommand\fun[3]{\lambda #1 : #2 . #3}
\renewcommand\Fun[2]{\Lambda #1 . #2}

\def\typet{\m{type}}
\renewcommand\type[1]{#1~\typet}

\renewcommand\allt[2]{\forall(#1.#2)}
\renewcommand\App[2]{#1[#2]}
\renewcommand\subst[3]{[#1 / #2] #3}
$$
&lt;/div&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\tau &amp; ::= \alpha \mid \tau \to \tau \mid \allt{\alpha}{\tau} \\
e &amp; ::= x \mid \fun{x}{\tau}{e} \mid ee \mid \Fun{\alpha}{e} \mid \App{e}{\tau}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Note the lack of explicit product and sum types. System F’s typing is actually more powerful than ML because you can include $\forall$ in types. (ML forces you to have all quantifiers at the beginning of the type, but saves you from having to write them explicitly.)&lt;/p&gt;

&lt;h2 id=&quot;statics&quot;&gt;Statics&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx(x)=\tau}
{\ctx \prove x : \tau}&lt;/script&gt;

&lt;p&gt;&lt;em&gt;[missing judgements]&lt;/em&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx,\alpha : \typet \prove e : \tau}
{\ctx \prove \Fun{\alpha}{e} : \allt{\alpha}{\tau}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \prove e : \allt{\alpha}{\tau&#39;} \qquad \ctx \prove \tau : \typet}
{\ctx \prove \App{e}{\tau} : \subst{\tau}{\alpha}{\tau&#39;}}&lt;/script&gt;

&lt;p&gt;&lt;em&gt;[missing judgements for &lt;script type=&quot;math/tex&quot;&gt;\typet&lt;/script&gt;]&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;dynamics&quot;&gt;Dynamics&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;[missing rules for usual evaluation]&lt;/em&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \to e&#39;}
{\App{e}{\tau} \to \App{e&#39;}{\tau}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\App{(\Fun{\alpha}{e})}{\tau} \to \subst{\tau}{\alpha}{e}}&lt;/script&gt;
</description>
        <pubDate>Tue, 17 Mar 2015 13:28:49 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/03/17/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/03/17/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 15: Benign effects, Mobile Types, References</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\newcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\newcommand\ok[1]{#1~~\m{ok}}
\newcommand\oks[1]{#1~~\m{ok}_{\sig}}
\def\natt{\m{nat}}
\def\gap{\hspace{1cm}}
\def\valt{\m{val}}
\newcommand\val[1]{#1~\valt}
\newcommand\vals[1]{#1~\valt_{\scriptscriptstyle\sig}}
\newcommand\valsx[2]{#1~\valt_{\scriptscriptstyle\sig, #2}}
\def\gt{\mapsto}
\def\gts{\gt_{\scriptscriptstyle\sig}}
\newcommand\gtsx[1]{\gt_{\scriptscriptstyle\sig, #1}}
\def\defeq{\overset{def}{=}}

\def\prove{\vdash}
\def\provesig{\prove_{\scriptscriptstyle\sig}}
\def\provee{\prove_{\emptyset}}
\newcommand\provesigx[1]{\prove_{\scriptscriptstyle \sig,#1}}

\def\cmdt{\m{cmd}}
\newcommand\cmd[1]{\cmdt~(#1)}

\newcommand\ret[1]{\m{ret}~(#1)}

\newcommand\bnd[3]{\m{bnd}~#1 \leftarrow #2; #3}
\newcommand\bind[3]{\{ #1 \leftarrow #2; #3 \}}

\newcommand\final[1]{#1~\m{final}_{\scriptscriptstyle\sig}}
\newcommand\finalx[2]{#1~\m{final}_{\scriptscriptstyle\sig,#2}}

\def\midd{~||~}

\newcommand\do[1]{\m{do}~#1}

\newcommand\ifelse[3]{\m{if}~(#1)~#2~\m{else}~#3}
\newcommand\while[2]{\m{while}~(#1)~#2}

\newcommand\ifz[4]{\m{ifz}(#1;#2;#3.#4)}
\newcommand\fix[3]{\m{fix}~#1:#2~#3}

\newcommand\dcl[3]{\m{dcl}~#1 := #2~\m{in}~#3}
\newcommand\dcla[3]{\m{dcl}(#1; #2.#3)}
\newcommand\dclt[4]{\m{dcl}_{#1}~#2 := #3~\m{in}~#4}

\newcommand\get[1]{@#1}
\newcommand\geta[1]{\m{get}[#1]}

\newcommand\set[2]{#1 := #2}
\newcommand\seta[2]{\m{set}[#1](#2)}

\newcommand\fun[3]{\lambda #1 : #2 . #3}

\def\qquad{~~~~}

\newcommand\mobile[1]{#1~\m{mobile}}
\def\voidt{\m{void}}
\def\unitt{\langle \rangle}

\newcommand\reft[1]{\m{ref}(#1)}
\newcommand\ref[1]{\&amp;amp;#1}
\newcommand\getref[1]{*#1}
\newcommand\setref[2]{#1 := #2}
$$
&lt;/div&gt;

&lt;h1 id=&quot;modernized-algol-continued&quot;&gt;Modernized Algol (continued)&lt;/h1&gt;

&lt;h2 id=&quot;syntactic-sugar&quot;&gt;Syntactic Sugar&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\{\bind{x}{m_1}{m_2}\} &amp; \defeq \bnd{x}{\cmd{m_1}}{m_2} \\
\{ m_1 ; m_2 \} &amp; \defeq \{ \bind{\_}{m_1}{m_2} \} \\
\while{m_1}{m_2} &amp; \defeq \do{(
    \fix{\m{loop}}
        {\cmdt}
        {\cmd{(\ifelse{m_1}
                      {\ret{\bar{0}}}
                      {\{m_2 ; \do{\m{loop}}\}}
        )}}
)}
\end{align} %]]&gt;&lt;/script&gt;

&lt;h2 id=&quot;factorial&quot;&gt;Factorial&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\m{fact} \defeq \fun
{x}
{\natt}
{\cmd{(
    \dcl{r}{1}{\\\dcl{a}{x}{\\ \{\while{\get{a}}{
    \{ \\
        \bnd{y}{\get{r}}{\\\bnd{z}{\get{a}}{\\\set{r}{(x-z+\bar{1})*y ; \\\set{a}{z - \bar{1}}}}}
    \\\}\\
    }; \get{r}\}}}
)}} \\
\m{fact} : \natt \to \cmdt
&lt;/script&gt;

&lt;h2 id=&quot;benign-effects&quot;&gt;Benign effects&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Benign effects&lt;/em&gt; do not change the visible state of the program. For $\m{fact}$, we’d like to produce a function with type $\natt \to \natt$. Even though it indeed only has benign effects, we can’t guarantee that. We can’t hide side effects, but we also can’t hide benign effects.&lt;/p&gt;

&lt;p&gt;Haskell is pure because it does not let you hide any effects, including benign ones. So, if there is an effect, it’s in the type (via monads). SML is impure because it lets you hide benign effects, but you can also hide any other effect.&lt;/p&gt;

&lt;h2 id=&quot;extending-the-language&quot;&gt;Extending the Language&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\tau &amp; ::= \cdots \mid \cmd{\tau} \\
m &amp; ::= \cdots \mid \dclt{\tau}{a}{e}{m}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Signatures now include types for assignables.&lt;/p&gt;

&lt;h3 id=&quot;proposed-incorrect-type-system&quot;&gt;Proposed (incorrect) type system&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ctx \provesig e : \tau&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ctx \provesig m \sim \tau&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig m \sim \tau}
{\ctx \provesig \cmd{m} : \cmd{\tau}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e : \tau}
{\ctx \provesig \ret{e} \sim \tau}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e : \cmd{\tau} \qquad \ctx, x : \tau \provesig m \sim \tau&#39;}
{\ctx \provesig \bind{x}{e}{m} \sim \tau&#39;}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e : \cmd{\tau} \qquad \ctx, x : \tau \provesig m \sim \tau&#39;}
{\ctx \provesig \dclt{\tau}{a}{e}{m} \sim \tau&#39;}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\ctx \provesigx{a \sim \tau} \get{a} \sim \tau}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesigx{a \sim \tau} e : \tau}
{\ctx \provesigx{a \sim \tau} \set{a}{e} \sim \tau}&lt;/script&gt;

&lt;p&gt;Why is this incorrect?&lt;/p&gt;

&lt;h3 id=&quot;mobile-types&quot;&gt;Mobile types&lt;/h3&gt;

&lt;p&gt;Consider the program&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\dcl{a}{\bar{0}}{\ret{\fun{x}{\natt}{\cmd{\set{a}{x}}}}}&lt;/script&gt;

&lt;p&gt;It steps to&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ret{\fun{x}{\natt}{\cmd{\set{a}{x}}}}&lt;/script&gt;

&lt;p&gt;but $a$ is not in scope.&lt;/p&gt;

&lt;p&gt;In the typing judgment for $\m{dcl}$, $\tau’$ needs to be mobile. Alternatively, we can require that the type for $\m{ret}$ must be mobile. Natural numbers are mobile, but functions are not, because they can refer to assignables.&lt;/p&gt;

&lt;p&gt;More precisely, &lt;script type=&quot;math/tex&quot;&gt;\tau&lt;/script&gt; is &lt;em&gt;mobile&lt;/em&gt; if &lt;script type=&quot;math/tex&quot;&gt;\forall e,\sig . \provesig e : \tau \wedge \vals{e}&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;\prove_{\emptyset} e : \tau&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\val{e}_{\emptyset}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Note that if successor for natural numbers ($\m{s}$) is lazy, then natural numbers are &lt;em&gt;not&lt;/em&gt; mobile.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\mobile{\tau_1} \qquad \mobile{\tau_2}}
{\mobile{\tau_1 + \tau_2}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\voidt}&lt;/script&gt;

&lt;p&gt;The typing rules are still incorrect. Consider the program&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\dcl{a}{\cmd{\ret{\bar{0}}}}{\dcl{b}{\bar{0}}{\{
    \set{a}{\cmd{\get{b}}}; \ret \unitt
\}}}&lt;/script&gt;

&lt;p&gt;Here, assignables are escaping through the store. We need $\tau$ to be mobile as well in the typing judgment for $\m{dcl}$.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;p&gt;References are a language concept that correspond to the implementation concept pointers. References are not mobile (since they are nothing but assignables).&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\tau &amp; ::= \cdots \mid \reft{\tau} \\
e &amp; ::= \cdots \mid \ref{\tau} \\
m &amp; ::= \cdots \mid \getref{e} \mid \setref{e}{e}
\end{align} %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;statics&quot;&gt;Statics&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\ctx \provesigx{a \sim \tau} \ref{\tau} : \reft{\tau}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e : \ref{\tau}}
{\ctx \provesig \getref{e} \sim \tau}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e_1 : \reft{\tau} \qquad \ctx \provesig e_2 : \tau}
{\ctx \provesig \setref{e_1}{e_2} : \tau}&lt;/script&gt;

&lt;h3 id=&quot;operational-semantics&quot;&gt;Operational Semantics&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\valsx{\ref{a}}{a}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \gts e&#39;}
{\getref{e} \midd \mu \gts \getref{e&#39;} \midd \mu}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\getref{\ref{a}} \midd \mu \gts \get{a} \midd \mu}&lt;/script&gt;

&lt;p&gt;&lt;em&gt;[for $\setref{e_1}{e_2}$, evaluate $e_1$ and $e_2$]&lt;/em&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\vals{e_2}}
{\setref{\ref{a}}{e_2} \gts \set{a}{e_2} \midd \mu}&lt;/script&gt;
</description>
        <pubDate>Tue, 03 Mar 2015 13:28:18 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/03/03/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/03/03/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>76-221 Class 15: Gulliver&#39;s Travels</title>
        <description>&lt;h2 id=&quot;language-of-objects-p-172&quot;&gt;Language of objects (p. 172)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;“Women,” “Vulgar,” and “Illiterate” are “constant irreconcileable enemies to Science”&lt;/li&gt;
  &lt;li&gt;opposing this language is pretty reasonable&lt;/li&gt;
  &lt;li&gt;strange that the illiterate would oppose a new language&lt;/li&gt;
  &lt;li&gt;but even the illiterate realize how terrible this is&lt;/li&gt;
  &lt;li&gt;implies that women talk too much, though this is Swift criticizing Gulliver and this society&lt;/li&gt;
  &lt;li&gt;speak with &lt;em&gt;tongues&lt;/em&gt;, with the body
    &lt;ul&gt;
      &lt;li&gt;p. 191: “my tongue is in the Mouth of my Friend” when using a translator, also French kissing&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;language is &lt;em&gt;abstract&lt;/em&gt; (more than just objects) and &lt;em&gt;physical&lt;/em&gt; (tongues)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;struldbrugs&quot;&gt;Struldbrugs&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;immortal humans who also age indefinitely&lt;/li&gt;
  &lt;li&gt;nature is directional, towards death&lt;/li&gt;
  &lt;li&gt;turning cucumbers back to sunbeams is thus unnatural&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;houyhnhnms&quot;&gt;Houyhnhnms&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;portrayed as perfectly rational , and thus people&lt;/li&gt;
  &lt;li&gt;yet, Yahoos feel more like people&lt;/li&gt;
  &lt;li&gt;have capacity for misrepresentation and genocide&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;p-221&quot;&gt;p. 221&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;no word for lying&lt;/li&gt;
  &lt;li&gt;deficient language&lt;/li&gt;
  &lt;li&gt;Gulliver defends Master, has gone over to their side&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;p-251&quot;&gt;p. 251&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;no Letters, no literature&lt;/li&gt;
  &lt;li&gt;yet, have poetry, which is possibly written, and possibly emotional (irrational)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;p-218-9&quot;&gt;p. 218-9&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Gulliver is a “perfect Yahoo”&lt;/li&gt;
  &lt;li&gt;yet, wants hides of Yahoos for clothing and shoes&lt;/li&gt;
  &lt;li&gt;Master lies, willing to hide Gulliver’s true nature&lt;/li&gt;
  &lt;li&gt;Gulliver hates Yahoos because he hates himself&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;p-249&quot;&gt;p. 249&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Houyhnhnms domesticated and bred the Yahoos
    &lt;ul&gt;
      &lt;li&gt;stupid, because asses are better workers anyways&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;now, they want to commit genocide by castrating them, yet consider this solution to avoid taking of lives&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;p-258&quot;&gt;p. 258&lt;/h3&gt;
&lt;p&gt;Gulliver kills and skins Yahoo children because their skins are softer, and he needs them for his canoe.&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Mar 2015 09:00:00 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/76221/2015/03/03/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/76221/2015/03/03/</guid>
        
        
        <category>cmu</category>
        
        <category>76221</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 14: Modernized Algol</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\newcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\newcommand\ok[1]{#1~~\m{ok}}
\newcommand\oks[1]{#1~~\m{ok}_{\sig}}
\def\natt{\m{nat}}
\def\gap{\hspace{1cm}}
\def\valt{\m{val}}
\newcommand\val[1]{#1~\valt}
\newcommand\vals[1]{#1~\valt_{\scriptscriptstyle\sig}}
\newcommand\valsx[2]{#1~\valt_{\scriptscriptstyle\sig, #2}}
\def\gt{\mapsto}
\def\gts{\gt_{\scriptscriptstyle\sig}}
\newcommand\gtsx[1]{\gt_{\scriptscriptstyle\sig, #1}}
\def\defeq{\overset{def}{=}}

\def\prove{\vdash}
\def\provesig{\prove_{\scriptscriptstyle\sig}}
\def\provee{\prove_{\emptyset}}
\newcommand\provesigx[1]{\prove_{\scriptscriptstyle \sig,#1}}

\def\cmdt{\m{cmd}}
\newcommand\cmd[1]{\cmdt~#1}

\newcommand\ret[1]{\m{ret}~#1}

\newcommand\bnd[3]{\m{bnd}~#1 \leftarrow #2; #3}
\newcommand\bind[3]{\{ #1 \leftarrow #2; #3 \}}

\newcommand\final[1]{#1~\m{final}_{\scriptscriptstyle\sig}}
\newcommand\finalx[2]{#1~\m{final}_{\scriptscriptstyle\sig,#2}}

\def\midd{~||~}

\newcommand\do[1]{\m{do}~#1}

\newcommand\ifelse[3]{\m{if}~(#1)~#2~\m{else}~#3}

\newcommand\ifz[4]{\m{ifz}(#1;#2;#3.#4)}

\newcommand\dcl[3]{\m{dcl}~#1 := #2~\m{in}~#3}
\newcommand\dcla[3]{\m{dcl}(#1; #2.#3)}

\newcommand\get[1]{@#1}
\newcommand\geta[1]{\m{get}[#1]}

\newcommand\set[2]{#1 := #2}
\newcommand\seta[2]{\m{set}[#1](#2)}
$$
&lt;/div&gt;

&lt;h1 id=&quot;modernized-algol-continued&quot;&gt;Modernized Algol (continued)&lt;/h1&gt;

&lt;h2 id=&quot;safety&quot;&gt;Safety&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\forall a \in \sig . \exists e . \mu(a) = e \wedge \val{e}_{\emptyset} \wedge \prove_{\emptyset} e : \natt}
{\mu : \sig}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\provesig \ok{m} \gap \mu : \sig}
{m \midd \oks{\mu}}&lt;/script&gt;

&lt;h3 id=&quot;progress&quot;&gt;Progress&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;If $\provesig e : \tau$, then either $\vals{e}$ or $e \gts e’$.&lt;/li&gt;
  &lt;li&gt;If $\provesig \ok{m}$, then either $m \midd \final{\mu}$ or $m \midd \mu \gts m’ \midd u’$ and $\mu : \sig$.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We will consider the $\m{dcl}$ case in the proof of 2.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e : \natt \gap \ctx \provesigx{a} \ok{m}}
{\ctx \provesig \dcl{a}{e}{\ok{m}}}&lt;/script&gt;

&lt;p&gt;Suppose $\mu : \sig$. We want to show that $\dcl{a}{e}{m \midd \mu}$ or $\exists m’, \mu’ . \dcl{a}{e}{m \midd \mu} \gts m’ \midd \mu’$. By Progress 1 (or, if we’re proving (1) and (2) simultaneously, by the induction hypothesis), $\vals{e}$ or $e \gts e’$.&lt;/p&gt;

&lt;p&gt;Suppose $e \gts e’$. Then, $\dcl{a}{e}{m \midd \mu} \gts \dcl{a}{e’}{m \midd \mu}$.&lt;/p&gt;

&lt;p&gt;Suppose $\vals{e}$. Recall that&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\vals{e} \gap m \midd (\mu, a \hookrightarrow e) \gtsx{a} m&#39; \midd (\mu&#39;, a \hookrightarrow e&#39;)}
{\dcl{a}{e}{m} \midd \mu \gts \dcl{a}{e&#39;}{m&#39;} \midd \mu&#39;}&lt;/script&gt;

&lt;p&gt;We claim that $\mu, a \hookrightarrow e : \sig,a$. Note that it is implicit that $a$ is distinct from assignables in $\mu$. We want to show that&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists e&#39; . (\mu, a \hookrightarrow e)(a) = e&#39; \wedge \val{e&#39;}_{\emptyset} \wedge \provee e&#39;: \natt&lt;/script&gt;

&lt;p&gt;It is sufficient to show that &lt;script type=&quot;math/tex&quot;&gt;\val{e}_{\emptyset} \wedge \provee e : \natt&lt;/script&gt;. By canonical forms, &lt;script type=&quot;math/tex&quot;&gt;e = \bar{n}&lt;/script&gt; for some &lt;script type=&quot;math/tex&quot;&gt;n \in \mathbb{N}&lt;/script&gt;. Therefore, &lt;script type=&quot;math/tex&quot;&gt;\provee \bar{n} : \natt&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\val{\bar{n}}_{\emptyset}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Thus, we have shown that $\mu, a \hookrightarrow e : \sig,a$, and we can apply our induction hypothesis.&lt;/p&gt;

&lt;p&gt;By the induction hypothesis, either $\finalx{m \midd (\mu, a \hookrightarrow e)}{a}$ or $m \midd (\mu, a \hookrightarrow e) \gtsx{a} m’ \midd \hat{\mu}$. By a lemma (or by preservation), $\hat{\mu} = (\mu’, a \hookrightarrow e’)$.&lt;/p&gt;

&lt;p&gt;In the second case, $\dcl{a}{e}{m \midd \mu} \gts \dcl{a}{e’}{m’ \midd \mu’}$.&lt;/p&gt;

&lt;p&gt;In the first case, by inversion, &lt;script type=&quot;math/tex&quot;&gt;m = \ret{e&#39;}&lt;/script&gt;, where &lt;script type=&quot;math/tex&quot;&gt;\valsx{e&#39;}{a}&lt;/script&gt;. Thus, &lt;script type=&quot;math/tex&quot;&gt;\dcl{a}{e}{m \midd \mu} \gts m \midd \mu&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Thus, we have proved the $\m{dcl}$ case for Progress.&lt;/p&gt;

&lt;h3 id=&quot;preservation&quot;&gt;Preservation&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;\provesig e : \tau&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;e \gts e&#39;&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;\provesig e&#39; : \tau&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;\provesig \ok{m}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\mu : \sig&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;m \midd \mu \gts m&#39; \midd \mu&#39;&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;\provesig \ok{m&#39;}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\mu&#39; : \sig&lt;/script&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The proof of Preservation 1 is identical to the proof for Preservation for PCF, except with extra $\sig$s throughout.&lt;/p&gt;

&lt;p&gt;The proof of Preservation 2 is by induction on the derivation of &lt;script type=&quot;math/tex&quot;&gt;m \midd \mu \gts m&#39; \midd \mu&#39;&lt;/script&gt;. The $\m{dcl}$ case is proven on p. 331 of &lt;em&gt;PFPL&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;extending-the-language&quot;&gt;Extending the Language&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\tau &amp; ::= \cdots \mid \cmd{\tau}
\end{align} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ctx \provesig e : \tau&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ctx \provesig m \sim \tau&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig m \sim \tau}
{\ctx \provesig \cmd{m} : \cmd{\tau}}&lt;/script&gt;
</description>
        <pubDate>Thu, 26 Feb 2015 13:27:18 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/02/26/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/02/26/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>76-221 Class 14: Gulliver&#39;s Travels</title>
        <description>&lt;p&gt;Rather than focusing on the political satire in &lt;em&gt;Gulliver’s Travels&lt;/em&gt;, we’re doing a more critical/perceptive reading. There are many little things in the book that are easily missed. For instance, the fire is started by a maid who is distracted reading a romance novel and thus knocks over a candle. The execution scene is a little strange, as we talked about in the last class.&lt;/p&gt;

&lt;p&gt;On p. 115, we see Gulliver’s “open mindedness” at work. He thinks he’s bigger than he is, and acts like a child to try to prove himself. He actually recognizes that what he’s doing is similar to someone pretending to be someone of higher station, which finds distasteful, but continues his behavior. We can interpret this as either hypocrisy, or &lt;em&gt;less&lt;/em&gt; generously, as sheer forgetfulness.&lt;/p&gt;

&lt;p&gt;Consider the discussion of terrible life of the immortal &lt;em&gt;struldbrugs&lt;/em&gt;. Because they still age, they end up decrepit and useless. Perhaps Swift is commenting on the naturalness of death.&lt;/p&gt;
</description>
        <pubDate>Thu, 26 Feb 2015 09:00:00 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/76221/2015/02/26/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/76221/2015/02/26/</guid>
        
        
        <category>cmu</category>
        
        <category>76221</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 13: Modernized Algol</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\newcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\newcommand\ok[1]{#1~~\m{ok}}
\def\natt{\m{nat}}
\def\gap{\hspace{1cm}}
\def\valt{\m{val}}
\newcommand\val[1]{#1~\valt}
\newcommand\vals[1]{#1~\valt_{\scriptscriptstyle\sig}}
\newcommand\valsx[2]{#1~\valt_{\scriptscriptstyle\sig, #2}}
\def\gt{\mapsto}
\def\gts{\gt_{\scriptscriptstyle\sig}}
\newcommand\gtsx[1]{\gt_{\scriptscriptstyle\sig, #1}}
\def\defeq{\overset{def}{=}}

\def\prove{\vdash}
\def\provesig{\prove_{\scriptscriptstyle\sig}}
\newcommand\provesigx[1]{\prove_{\scriptscriptstyle \sig,#1}}

\def\cmdt{\m{cmd}}
\newcommand\cmd[1]{\cmdt~#1}

\newcommand\ret[1]{\m{ret}~#1}

\newcommand\bnd[3]{\m{bnd}~#1 \leftarrow #2; #3}
\newcommand\bind[3]{\{ #1 \leftarrow #2; #3 \}}

\newcommand\final[1]{#1~\m{final}_{\scriptscriptstyle\sig}}

\def\midd{~||~}

\newcommand\do[1]{\m{do}~#1}

\newcommand\ifelse[3]{\m{if}~(#1)~#2~\m{else}~#3}

\newcommand\ifz[4]{\m{ifz}(#1;#2;#3.#4)}

\newcommand\dcl[3]{\m{dcl}~#1 := #2~\m{in}~#3}
\newcommand\dcla[3]{\m{dcl}(#1; #2.#3)}

\newcommand\get[1]{@#1}
\newcommand\geta[1]{\m{get}[#1]}

\newcommand\set[2]{#1 := #2}
\newcommand\seta[2]{\m{set}[#1](#2)}
$$
&lt;/div&gt;

&lt;h1 id=&quot;imperative-languages&quot;&gt;Imperative Languages&lt;/h1&gt;
&lt;p&gt;We’re going to discuss Algol, which inspired Pascal, which inspired C. In particular, we’re going talk about &lt;em&gt;Modernized Algol&lt;/em&gt;, which isn’t a real language.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Expressions&lt;/em&gt; are &lt;em&gt;pure&lt;/em&gt;: they have no side effects. Expressions are often referred to as terms.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Commands&lt;/em&gt; are &lt;em&gt;impure&lt;/em&gt;: they may have &lt;em&gt;side effects&lt;/em&gt;; they do something to the world. Side effects can involve changes to the store (modifying memory), or input and output. Commands are often referred to as, rather confusingly, expressions.&lt;/p&gt;

&lt;h1 id=&quot;modernized-algol&quot;&gt;Modernized Algol&lt;/h1&gt;
&lt;p&gt;A lot of justifications for why things in this language are the way they are will be by &lt;em&gt;lax logic&lt;/em&gt;.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\tau &amp; ::= \cdots \mid \cmdt \\
e &amp; ::= \cdots \mid \cmd{m} \\
m &amp; ::= \ret{e} \mid \bnd{x}{e}{m} \mid \dcl{a}{e}{m} \mid \get{a} \mid \set{a}{e}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;$m$ is a &lt;em&gt;command&lt;/em&gt;. $a$ is an &lt;em&gt;assignable&lt;/em&gt;. It’s commonly referred to as a variable, which is incorrect, because it’s not given meaning through substitution.&lt;/p&gt;

&lt;p&gt;Note that $\m{bnd}$ is not the same as $\m{let}$. With a $\m{bnd}$ command, once $e$ becomes a value, we know it’s a encapsulated command, so we execute it. With a $\m{let}$ expression, we substitute the value of $e$ in for $x$.&lt;/p&gt;

&lt;p&gt;The abstract syntax for some of the commands are:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\dcla{e}{a}{m} \gap \geta{a} \gap \seta{a}{e}&lt;/script&gt;

&lt;h2 id=&quot;static-semantics&quot;&gt;Static Semantics&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ctx \provesig e : \tau&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\sig&lt;/script&gt; is a &lt;em&gt;signature&lt;/em&gt;. In this language, it is a set of assignables.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx, x : \tau \provesig e : \tau&#39;}
{\ctx \provesig \lambda x : \tau . e : \tau \rightharpoonup \tau&#39;}
&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ctx \provesig \ok{m}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig \ok{m}}
{\ctx \provesig \cmd{m} : \cmdt}
&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e : \natt}
{\ctx \provesig \ok{\ret{e}}}
&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e : \cmdt \gap \Gamma, x : \natt \provesig \ok{m}}
{\ctx \provesig \ok{\bnd{x}{e}{m}}}
&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e : \natt \gap \ctx \provesigx{a} \ok{m}}
{\ctx \provesig \dcl{a}{e}{\ok{m}}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{a \in \sig}
{\ctx \provesig \ok{\get{a}}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{a \in \sig \gap \ctx \provesig e : \natt}
{\ctx \provesig \ok{\set{a}{e}}}&lt;/script&gt;

&lt;p&gt;Note that there is an implicit assumption that $a \not\in \sig$. Note also that this assignment is not persistent. In an implementation, $a$ would reside on the stack, and this is commonly referred to as &lt;em&gt;stack discipline&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;operational-semantics&quot;&gt;Operational Semantics&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vals{e}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e \gts e&#39;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;m \midd \mu \gts m&#39; \midd \mu&#39;&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\mu&lt;/script&gt; is a &lt;em&gt;state&lt;/em&gt;, representing memory where assignables are mapped to values. $m$ is a command.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\final{m \midd \mu}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}{\vals{\cmd{m}}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\vals{e}}
{\ret{e} \midd \final{\mu}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \gts e&#39;}
{\ret{e} \midd \mu \gts \ret{e&#39;} \midd \mu}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \gts e&#39;}
{\bnd{x}{e}{m} \midd \mu \gts \bnd{x}{e&#39;}{m \midd \mu}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{m_1 \midd \mu \gts m_1&#39; \midd \mu&#39;}
{\bnd{x}{\cmd{m_1}}{m_2} \midd \mu \gts \bnd{x}{\cmd{m_1&#39;}}{m_2} \midd \mu}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\vals{e}}
{\bnd{x}{\cmd{(\ret{e})}}{m} \midd \mu \gts [e/x]~m \midd \mu}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \gts e&#39;}
{\dcl{a}{e}{m} \midd \mu \gts \dcl{a}{e&#39;}{m} \midd \mu}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\vals{e} \gap m \midd (\mu, a \hookrightarrow e) \gtsx{a} m&#39; \midd (\mu&#39;, a \hookrightarrow e&#39;)}
{\dcl{a}{e}{m} \midd \mu \gts \dcl{a}{e&#39;}{m&#39;} \midd \mu&#39;}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\vals{e_1} \gap \valsx{e_2}{a}}
{\dcl{a}{e_1}{\ret{e_2}} \midd \mu \gts \ret{e_2} \midd \mu}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\get{a} \midd (\mu, a \hookrightarrow e) \gtsx{a} \ret{e} \midd (\mu, a \hookrightarrow e)}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e_1 \gtsx{a} e_1&#39;}
{\set{a}{e} \midd \mu \gts \set{a}{e_1&#39;} \midd \mu}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\vals{e_1}}
{\set{a}{e_1} \midd (\mu, a \hookrightarrow e_2) \gts \ret{e_1} \midd (\mu, a \hookrightarrow e_1)}&lt;/script&gt;

&lt;h2 id=&quot;syntactic-sugar&quot;&gt;Syntactic Sugar&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\bind{x}{m}{m&#39;} &amp; \defeq \bnd{x}{\cmd{m}}{m&#39;} \\
\do{e} &amp; \defeq \bnd{x}{e}{\ret{x}} \\
\ifelse{m}{m_1}{m_2} &amp; \defeq \bind{x}{m}{\do{(\ifz{x}{\cmd{m_1}}{\_}{\cmd{m_2}})}}
\end{align} %]]&gt;&lt;/script&gt;
</description>
        <pubDate>Tue, 24 Feb 2015 13:30:41 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/02/24/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/02/24/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>76-221 Class 13: Gulliver&#39;s Travels</title>
        <description>&lt;p&gt;Occasionally, irrationality is part of being human. Swift was an early proponent of the idea that the main thing that differentiates from animals is language.&lt;/p&gt;

&lt;h2 id=&quot;p-62&quot;&gt;p. 62&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;lots of unnecessary detail&lt;/li&gt;
  &lt;li&gt;joke is that he doesn’t need to defend her, because he is 12 times larger than her&lt;/li&gt;
  &lt;li&gt;too much association with the Lilliputians&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;p-80&quot;&gt;p. 80&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;long, overly-detailed passages as a game&lt;/li&gt;
  &lt;li&gt;playing with the reader&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pp-21-2&quot;&gt;pp. 21-2&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Swift is fond of puns&lt;/li&gt;
  &lt;li&gt;“Master Mr. Bates” to “Mr. Bates” to, finally, “Master Bates”&lt;/li&gt;
  &lt;li&gt;purpose of language is not communication
    &lt;ul&gt;
      &lt;li&gt;part of who we are&lt;/li&gt;
      &lt;li&gt;like why a monkey swings on his tail&lt;/li&gt;
      &lt;li&gt;something for us to play with&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;p-71&quot;&gt;p. 71&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;a “real boat” is real because it’s his size&lt;/li&gt;
  &lt;li&gt;shows he is getting out of his fictional mindset&lt;/li&gt;
  &lt;li&gt;Swift is showing that the body insists when it is denied&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pp-82-3&quot;&gt;pp. 82-3&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Worries that Brobdingnags would dash him against the ground, just as he was earlier considering dashing the Lilliputians against the ground
    &lt;ul&gt;
      &lt;li&gt;He doesn’t explicitly recognize this connection&lt;/li&gt;
      &lt;li&gt;to be human is to make connections, to have narrative history&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;p-110&quot;&gt;p. 110&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;beauty is relative, but still necessary&lt;/li&gt;
  &lt;li&gt;it’s all a matter of perspective&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;p-111&quot;&gt;p. 111&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;right after passage on beauty (or lack thereof)&lt;/li&gt;
  &lt;li&gt;grotesque&lt;/li&gt;
  &lt;li&gt;fountain of blood from neck stump compared to fountain in Palace of Versailles
    &lt;ul&gt;
      &lt;li&gt;quite an inappropriate comparison&lt;/li&gt;
      &lt;li&gt;misfit&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;neither the actual beheading nor the fountain of blood bothered him, but the bouncing of the head startled him&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Aside: William Boroughs claimed the above two passages inspired &lt;em&gt;Naked Lunch.&lt;/em&gt; He claims they present an argument against capital punishment.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 24 Feb 2015 09:00:00 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/76221/2015/02/24/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/76221/2015/02/24/</guid>
        
        
        <category>cmu</category>
        
        <category>76221</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 12: The Untyped Lambda Calculus</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\newcommand{\m}[1]{\textsf{#1}}
\def\okt{\m{ok}}
\newcommand\ok[1]{#1\;\okt}
\def\ctx{\Gamma}
\def\defeq{\overset{def}{=}}
\def\succ{\m{succ}}
\def\plus{\m{plus}}
\def\times{\m{times}}
\def\zero{\bar{0}}
\def\ifz{\m{ifz}}
\def\pred{\m{pred}}
\newcommand\pair[2]{\langle #1, #2 \rangle}
\def\yc{\m{Y}}
$$
&lt;/div&gt;

&lt;h1 id=&quot;the-untyped-lambda-calculus&quot;&gt;The Untyped $\lambda$-Calculus&lt;/h1&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;u = x \mid \lambda x . t \mid uu&lt;/script&gt;

&lt;p&gt;Since this is untyped, $\ok{u}$ and&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ok{u} \in \ctx}
{\Gamma \vdash \ok{u}}
&lt;/script&gt;

&lt;p&gt;We have the rules you’d expect for the $\okt$ judgement, and for equivalence. &lt;em&gt;[They were illegible. See PFPL 17.1]&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;church-encoding&quot;&gt;Church encoding&lt;/h2&gt;
&lt;p&gt;Church numerals are (the best-known) special case of Church encoding. We will use $\bar{0}$ to represent numbers in the language, rather than the real world.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\bar{0} \defeq \lambda b . \lambda s . b&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\bar{1} \equiv \lambda b . \lambda s . s(b)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\overline{n + 1} \defeq \lambda b . \lambda s . s(\bar{n} \; b \; s)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\succ \defeq \lambda f . \lambda b . \lambda s . s(f \; b \; s)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\succ&#39; \defeq \lambda f . \lambda b . \lambda s . f(s \; b) s&lt;/script&gt;

&lt;p&gt;We can prove, for any $n \in \mathbb{N}$, &lt;script type=&quot;math/tex&quot;&gt;\succ(\bar{n}) \equiv \succ&#39;(\bar{n}) \equiv \overline{n+1}&lt;/script&gt; by induction on $n$.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align*}
\plus &amp; = \lambda m . \lambda n . \lambda b . \lambda s . n \; (m \; b \; s) \; s \\
&amp; = \lambda m . \lambda n . m \; n \; \succ \\
\times &amp; = \lambda m . \lambda n . m \; \zero \; (\plus n)
\end{align*} %]]&gt;&lt;/script&gt;

&lt;p&gt;To define $\ifz$, we need to be able to find the predecessor of something:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ifz\{e, e_0, x. e_s\} = e \; e_0 \; (\lambda \_ . [\pred \; e / x] e_s)&lt;/script&gt;

&lt;p&gt;We define $\pred$ as&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\pred(\zero) &amp; \equiv \zero \\
\pred(\overline{n+1}) &amp; \equiv \bar{n}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Returning to Church encodings, we need to represent numbers as their iterators. This is necessary to be able to obtain the predecessor of a value. First, we define pairs&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\pair{u_1}{u_2} &amp; \defeq \lambda f . f \; u_1 \; u_2 \\
u \cdot l &amp; \defeq u \; (\lambda x . \lambda y . x) \\
u \cdot r &amp; \defeq u \; (\lambda x . \lambda y . y)
\end{align} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\pred&#39; &amp; = \lambda n . n \; \pair{\zero}{\zero} \; (\lambda p . \pair{p \cdot r}{\succ \; (p \cdot r)}) \\
\pred &amp; = \lambda n . \pred&#39; \; (n) \cdot l
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;To implement $\m{fix}$, we define the $\yc$ combinator.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\yc \defeq \lambda f . (\lambda x . f \; (x \; x)) \; (\lambda x . f \; (x \; x))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\yc \; F &amp; \equiv (\lambda x . F \; (x \; x)) \; (\lambda x . F \; (x \; x)) \\
&amp; \equiv F \; ((\lambda x . F \; (x \; x)) \; (\lambda x . F \; (x \; x))) \\
&amp; \equiv F \; (\lambda f . (\lambda x . f \; (x \; x)) (\lambda x . f \; (x \; x))) \; F \\
&amp; \equiv F \; (\yc \; F)
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Thus, we have all the computational power of PCF (and computation in general) in a much more compact language.&lt;/p&gt;

&lt;h2 id=&quot;scotts-theorem&quot;&gt;Scott’s Theorem&lt;/h2&gt;
&lt;p&gt;There exists no effectively computable (computable in the $\lambda$-calculus) algorithm for testing the equivalence of two lambda terms.&lt;/p&gt;

&lt;p&gt;Scott’s Theorem is a special case of &lt;em&gt;Rice’s Theorem&lt;/em&gt;, which states that there exists no effective computable algorithm that can test any (nontrivial, behavioral) property of lambda terms.&lt;/p&gt;

&lt;p&gt;A property $A$ is &lt;em&gt;trivial&lt;/em&gt; if $\forall u . A(u)$ or $\forall u . \neg A(u)$.&lt;/p&gt;

&lt;p&gt;A property $A$ is &lt;em&gt;behavioral&lt;/em&gt; if $u \equiv u’ \supset A(u) \iff A(u’)$.&lt;/p&gt;
</description>
        <pubDate>Thu, 19 Feb 2015 13:30:00 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/02/19/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/02/19/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
  </channel>
</rss>
