<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Notes</title>
    <description>Notes on classes at CMU.
</description>
    <link>http://www.tomshen.me/notes/</link>
    <atom:link href="http://www.tomshen.me/notes/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Tue, 17 Mar 2015 14:51:07 -0400</pubDate>
    <lastBuildDate>Tue, 17 Mar 2015 14:51:07 -0400</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>15-312 Lecture 16: Aliasing, Free References, Polymorphism (System F)</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\newcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\newcommand\ok[1]{#1~~\m{ok}}
\newcommand\oks[1]{#1~~\m{ok}_{\sig}}
\def\natt{\m{nat}}
\def\gap{\hspace{1cm}}
\def\valt{\m{val}}
\newcommand\val[1]{#1~\valt}
\newcommand\vals[1]{#1~\valt_{\scriptscriptstyle\sig}}
\newcommand\valsx[2]{#1~\valt_{\scriptscriptstyle\sig, #2}}
\def\gt{\mapsto}
\def\gts{\gt_{\scriptscriptstyle\sig}}
\newcommand\gtsx[1]{\gt_{\scriptscriptstyle\sig, #1}}
\def\defeq{\overset{def}{=}}

\def\prove{\vdash}
\def\provesig{\prove_{\scriptscriptstyle\sig}}
\def\provee{\prove_{\emptyset}}
\newcommand\provesigx[1]{\prove_{\scriptscriptstyle \sig,#1}}

\def\cmdt{\m{cmd}}
\newcommand\cmd[1]{\cmdt~(#1)}

\newcommand\ret[1]{\m{ret}~(#1)}

\newcommand\bnd[3]{\m{bnd}~#1 \leftarrow #2; #3}
\newcommand\bind[3]{\{ #1 \leftarrow #2; #3 \}}

\newcommand\final[1]{#1~\m{final}_{\scriptscriptstyle\sig}}
\newcommand\finalx[2]{#1~\m{final}_{\scriptscriptstyle\sig,#2}}

\def\midd{~||~}

\newcommand\do[1]{\m{do}~#1}

\newcommand\ifelse[3]{\m{if}~(#1)~#2~\m{else}~#3}
\newcommand\while[2]{\m{while}~(#1)~#2}

\newcommand\ifz[4]{\m{ifz}(#1;#2;#3.#4)}
\newcommand\fix[3]{\m{fix}~#1:#2~#3}

\newcommand\dcl[3]{\m{dcl}~#1 := #2~\m{in}~#3}
\newcommand\dcla[3]{\m{dcl}(#1; #2.#3)}
\newcommand\dclt[4]{\m{dcl}_{#1}~#2 := #3~\m{in}~#4}

\newcommand\get[1]{@#1}
\newcommand\geta[1]{\m{get}[#1]}

\newcommand\set[2]{#1 := #2}
\newcommand\seta[2]{\m{set}[#1](#2)}

\newcommand\fun[3]{\lambda #1 : #2 . #3}

\def\qquad{~~~~}

\newcommand\mobile[1]{#1~\m{mobile}}
\def\voidt{\m{void}}
\def\unitt{\langle \rangle}

\newcommand\reft[1]{\m{ref}(#1)}
\newcommand\ref[1]{\&amp;amp;#1}
\newcommand\getref[1]{*#1}
\newcommand\setref[2]{#1 := #2}
\newcommand\newref[2]{\m{newref}_{#1} #2}

\newcommand\state[3]{\nu (#1) \{ #2 \midd #3 \}}
\newcommand\statesig[2]{\nu \sig \{ #1 \midd #2 \}}
$$
&lt;/div&gt;

&lt;h1 id=&quot;modernized-algol-continued&quot;&gt;Modernized Algol (continued)&lt;/h1&gt;

&lt;h2 id=&quot;references-continued&quot;&gt;References (continued)&lt;/h2&gt;

&lt;h3 id=&quot;aliasing&quot;&gt;Aliasing&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
e \mathrel{+}= e&#39; &amp; \defeq \bind{x}{\getref{e}}{\bind{y}{\getref{e&#39;}}{\setref{e}{(x+y)}}}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Two references that govern the same underlying assignable are said to be &lt;em&gt;aliases&lt;/em&gt;. The possibility of aliasing complicates reasoning about the correctness of code that uses references, for we must always consider for any two references whether or not they might be aliases.&lt;/p&gt;

&lt;h2 id=&quot;free-assignables&quot;&gt;Free Assignables&lt;/h2&gt;

&lt;p&gt;In order to be able to have mutable data structures, we need assignables that can live outside the scopes of their declarations. We call these &lt;em&gt;scope-free&lt;/em&gt; or &lt;em&gt;free&lt;/em&gt; assignables.&lt;/p&gt;

&lt;p&gt;We change &lt;script type=&quot;math/tex&quot;&gt;\m{dcl}&lt;/script&gt; to add assignables to the state.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\statesig{m}{\mu}&lt;/script&gt;

&lt;p&gt;represents a state where the assignables &lt;script type=&quot;math/tex&quot;&gt;m \midd \mu&lt;/script&gt; are bound. &lt;script type=&quot;math/tex&quot;&gt;\nu&lt;/script&gt; is purely for notational purposes.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\vals{e}}
{\statesig{\dclt{\tau}{a}{e}{m}}{\mu} \gt \state{\sig,a \sim \tau}{m}{(\mu, a \hookrightarrow e)}}&lt;/script&gt;

&lt;p&gt;We don’t need a mobility condition for&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig{e : \tau} \qquad \ctx \provesigx{a \sim \tau}{m \sim \tau&#39;}}
{\ctx \provesig{\dclt{\tau}{a}{e}{m \sim \tau&#39;}}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\newref{\tau}{e} \defeq \dclt{\tau}{a}{e}{\ref{a}}&lt;/script&gt;

&lt;p&gt;&lt;em&gt;[backpatching to implement recursion]&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;preservation&quot;&gt;Preservation&lt;/h3&gt;

&lt;p&gt;If &lt;script type=&quot;math/tex&quot;&gt;\statesig{m}{\mu} \gt \statesig{m&#39;}{\mu&#39;}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\provesig{m \sim \tau}&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;\provesig{\mu : \sig}&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;\prove_{\scriptscriptstyle\sig&#39;} m&#39; \sim \tau&lt;/script&gt;,  &lt;script type=&quot;math/tex&quot;&gt;\prove_{\scriptscriptstyle\sig&#39;} \mu&#39; : \sig&#39;&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;\sig&#39;&lt;/script&gt; extends &lt;script type=&quot;math/tex&quot;&gt;\sig&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Note that in languages with &lt;script type=&quot;math/tex&quot;&gt;\m{free}&lt;/script&gt; (such as C), it is not always the case that &lt;script type=&quot;math/tex&quot;&gt;\sig&#39;&lt;/script&gt; extends &lt;script type=&quot;math/tex&quot;&gt;\sig&lt;/script&gt;. We would need a lot more sophistication in order to have a working type system. Most languages with &lt;script type=&quot;math/tex&quot;&gt;\m{free}&lt;/script&gt; are just broken.&lt;/p&gt;

&lt;h1 id=&quot;polymorphism&quot;&gt;Polymorphism&lt;/h1&gt;

&lt;p&gt;We will be discussing a language called System F, also known as polymorphic lambda calculus. We will have bare type variables.&lt;/p&gt;

&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}

\def\prove{\vdash}

\renewcommand\fun[3]{\lambda #1 : #2 . #3}
\renewcommand\Fun[2]{\Lambda #1 . #2}

\def\typet{\m{type}}
\renewcommand\type[1]{#1~\typet}

\renewcommand\allt[2]{\forall(#1.#2)}
\renewcommand\App[2]{#1[#2]}
\renewcommand\subst[3]{[#1 / #2] #3}
$$
&lt;/div&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\tau &amp; ::= \alpha \mid \tau \to \tau \mid \allt{\alpha}{\tau} \\
e &amp; ::= x \mid \fun{x}{\tau}{e} \mid ee \mid \Fun{\alpha}{e} \mid \App{e}{\tau}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Note the lack of explicit product and sum types. System F’s typing is actually more powerful than ML because you can include $\forall$ in types. (ML forces you to have all quantifiers at the beginning of the type, but saves you from having to write them explicitly.)&lt;/p&gt;

&lt;h2 id=&quot;statics&quot;&gt;Statics&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx(x)=\tau}
{\ctx \prove x : \tau}&lt;/script&gt;

&lt;p&gt;&lt;em&gt;[missing judgements]&lt;/em&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx,\alpha : \typet \prove e : \tau}
{\ctx \prove \Fun{\alpha}{e} : \allt{\alpha}{\tau}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \prove e : \allt{\alpha}{\tau&#39;} \qquad \ctx \prove \tau : \typet}
{\ctx \prove \App{e}{\tau} : \subst{\tau}{\alpha}{\tau&#39;}}&lt;/script&gt;

&lt;p&gt;&lt;em&gt;[missing judgements for &lt;script type=&quot;math/tex&quot;&gt;\typet&lt;/script&gt;]&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;dynamics&quot;&gt;Dynamics&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;[missing rules for usual evaluation]&lt;/em&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \to e&#39;}
{\App{e}{\tau} \to \App{e&#39;}{\tau}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\App{(\Fun{\alpha}{e})}{\tau} \to \subst{\tau}{\alpha}{e}}&lt;/script&gt;
</description>
        <pubDate>Tue, 17 Mar 2015 13:28:49 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/03/17/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/03/17/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 15: Benign effects, Mobile Types, References</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\newcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\newcommand\ok[1]{#1~~\m{ok}}
\newcommand\oks[1]{#1~~\m{ok}_{\sig}}
\def\natt{\m{nat}}
\def\gap{\hspace{1cm}}
\def\valt{\m{val}}
\newcommand\val[1]{#1~\valt}
\newcommand\vals[1]{#1~\valt_{\scriptscriptstyle\sig}}
\newcommand\valsx[2]{#1~\valt_{\scriptscriptstyle\sig, #2}}
\def\gt{\mapsto}
\def\gts{\gt_{\scriptscriptstyle\sig}}
\newcommand\gtsx[1]{\gt_{\scriptscriptstyle\sig, #1}}
\def\defeq{\overset{def}{=}}

\def\prove{\vdash}
\def\provesig{\prove_{\scriptscriptstyle\sig}}
\def\provee{\prove_{\emptyset}}
\newcommand\provesigx[1]{\prove_{\scriptscriptstyle \sig,#1}}

\def\cmdt{\m{cmd}}
\newcommand\cmd[1]{\cmdt~(#1)}

\newcommand\ret[1]{\m{ret}~(#1)}

\newcommand\bnd[3]{\m{bnd}~#1 \leftarrow #2; #3}
\newcommand\bind[3]{\{ #1 \leftarrow #2; #3 \}}

\newcommand\final[1]{#1~\m{final}_{\scriptscriptstyle\sig}}
\newcommand\finalx[2]{#1~\m{final}_{\scriptscriptstyle\sig,#2}}

\def\midd{~||~}

\newcommand\do[1]{\m{do}~#1}

\newcommand\ifelse[3]{\m{if}~(#1)~#2~\m{else}~#3}
\newcommand\while[2]{\m{while}~(#1)~#2}

\newcommand\ifz[4]{\m{ifz}(#1;#2;#3.#4)}
\newcommand\fix[3]{\m{fix}~#1:#2~#3}

\newcommand\dcl[3]{\m{dcl}~#1 := #2~\m{in}~#3}
\newcommand\dcla[3]{\m{dcl}(#1; #2.#3)}
\newcommand\dclt[4]{\m{dcl}_{#1}~#2 := #3~\m{in}~#4}

\newcommand\get[1]{@#1}
\newcommand\geta[1]{\m{get}[#1]}

\newcommand\set[2]{#1 := #2}
\newcommand\seta[2]{\m{set}[#1](#2)}

\newcommand\fun[3]{\lambda #1 : #2 . #3}

\def\qquad{~~~~}

\newcommand\mobile[1]{#1~\m{mobile}}
\def\voidt{\m{void}}
\def\unitt{\langle \rangle}

\newcommand\reft[1]{\m{ref}(#1)}
\newcommand\ref[1]{\&amp;amp;#1}
\newcommand\getref[1]{*#1}
\newcommand\setref[2]{#1 := #2}
$$
&lt;/div&gt;

&lt;h1 id=&quot;modernized-algol-continued&quot;&gt;Modernized Algol (continued)&lt;/h1&gt;

&lt;h2 id=&quot;syntactic-sugar&quot;&gt;Syntactic Sugar&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\{\bind{x}{m_1}{m_2}\} &amp; \defeq \bnd{x}{\cmd{m_1}}{m_2} \\
\{ m_1 ; m_2 \} &amp; \defeq \{ \bind{\_}{m_1}{m_2} \} \\
\while{m_1}{m_2} &amp; \defeq \do{(
    \fix{\m{loop}}
        {\cmdt}
        {\cmd{(\ifelse{m_1}
                      {\ret{\bar{0}}}
                      {\{m_2 ; \do{\m{loop}}\}}
        )}}
)}
\end{align} %]]&gt;&lt;/script&gt;

&lt;h2 id=&quot;factorial&quot;&gt;Factorial&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;
\m{fact} \defeq \fun
{x}
{\natt}
{\cmd{(
    \dcl{r}{1}{\\\dcl{a}{x}{\\ \{\while{\get{a}}{
    \{ \\
        \bnd{y}{\get{r}}{\\\bnd{z}{\get{a}}{\\\set{r}{(x-z+\bar{1})*y ; \\\set{a}{z - \bar{1}}}}}
    \\\}\\
    }; \get{r}\}}}
)}} \\
\m{fact} : \natt \to \cmdt
&lt;/script&gt;

&lt;h2 id=&quot;benign-effects&quot;&gt;Benign effects&lt;/h2&gt;
&lt;p&gt;&lt;em&gt;Benign effects&lt;/em&gt; do not change the visible state of the program. For $\m{fact}$, we’d like to produce a function with type $\natt \to \natt$. Even though it indeed only has benign effects, we can’t guarantee that. We can’t hide side effects, but we also can’t hide benign effects.&lt;/p&gt;

&lt;p&gt;Haskell is pure because it does not let you hide any effects, including benign ones. So, if there is an effect, it’s in the type (via monads). SML is impure because it lets you hide benign effects, but you can also hide any other effect.&lt;/p&gt;

&lt;h2 id=&quot;extending-the-language&quot;&gt;Extending the Language&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\tau &amp; ::= \cdots \mid \cmd{\tau} \\
m &amp; ::= \cdots \mid \dclt{\tau}{a}{e}{m}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Signatures now include types for assignables.&lt;/p&gt;

&lt;h3 id=&quot;proposed-incorrect-type-system&quot;&gt;Proposed (incorrect) type system&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ctx \provesig e : \tau&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ctx \provesig m \sim \tau&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig m \sim \tau}
{\ctx \provesig \cmd{m} : \cmd{\tau}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e : \tau}
{\ctx \provesig \ret{e} \sim \tau}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e : \cmd{\tau} \qquad \ctx, x : \tau \provesig m \sim \tau&#39;}
{\ctx \provesig \bind{x}{e}{m} \sim \tau&#39;}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e : \cmd{\tau} \qquad \ctx, x : \tau \provesig m \sim \tau&#39;}
{\ctx \provesig \dclt{\tau}{a}{e}{m} \sim \tau&#39;}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\ctx \provesigx{a \sim \tau} \get{a} \sim \tau}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesigx{a \sim \tau} e : \tau}
{\ctx \provesigx{a \sim \tau} \set{a}{e} \sim \tau}&lt;/script&gt;

&lt;p&gt;Why is this incorrect?&lt;/p&gt;

&lt;h3 id=&quot;mobile-types&quot;&gt;Mobile types&lt;/h3&gt;

&lt;p&gt;Consider the program&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\dcl{a}{\bar{0}}{\ret{\fun{x}{\natt}{\cmd{\set{a}{x}}}}}&lt;/script&gt;

&lt;p&gt;It steps to&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ret{\fun{x}{\natt}{\cmd{\set{a}{x}}}}&lt;/script&gt;

&lt;p&gt;but $a$ is not in scope.&lt;/p&gt;

&lt;p&gt;In the typing judgment for $\m{dcl}$, $\tau’$ needs to be mobile. Alternatively, we can require that the type for $\m{ret}$ must be mobile. Natural numbers are mobile, but functions are not, because they can refer to assignables.&lt;/p&gt;

&lt;p&gt;More precisely, &lt;script type=&quot;math/tex&quot;&gt;\tau&lt;/script&gt; is &lt;em&gt;mobile&lt;/em&gt; if &lt;script type=&quot;math/tex&quot;&gt;\forall e,\sig . \provesig e : \tau \wedge \vals{e}&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;\prove_{\emptyset} e : \tau&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\val{e}_{\emptyset}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Note that if successor for natural numbers ($\m{s}$) is lazy, then natural numbers are &lt;em&gt;not&lt;/em&gt; mobile.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\mobile{\tau_1} \qquad \mobile{\tau_2}}
{\mobile{\tau_1 + \tau_2}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\voidt}&lt;/script&gt;

&lt;p&gt;The typing rules are still incorrect. Consider the program&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\dcl{a}{\cmd{\ret{\bar{0}}}}{\dcl{b}{\bar{0}}{\{
    \set{a}{\cmd{\get{b}}}; \ret \unitt
\}}}&lt;/script&gt;

&lt;p&gt;Here, assignables are escaping through the store. We need $\tau$ to be mobile as well in the typing judgment for $\m{dcl}$.&lt;/p&gt;

&lt;h2 id=&quot;references&quot;&gt;References&lt;/h2&gt;
&lt;p&gt;References are a language concept that correspond to the implementation concept pointers. References are not mobile (since they are nothing but assignables).&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\tau &amp; ::= \cdots \mid \reft{\tau} \\
e &amp; ::= \cdots \mid \ref{\tau} \\
m &amp; ::= \cdots \mid \getref{e} \mid \setref{e}{e}
\end{align} %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;statics&quot;&gt;Statics&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\ctx \provesigx{a \sim \tau} \ref{\tau} : \reft{\tau}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e : \ref{\tau}}
{\ctx \provesig \getref{e} \sim \tau}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e_1 : \reft{\tau} \qquad \ctx \provesig e_2 : \tau}
{\ctx \provesig \setref{e_1}{e_2} : \tau}&lt;/script&gt;

&lt;h3 id=&quot;operational-semantics&quot;&gt;Operational Semantics&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\valsx{\ref{a}}{a}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \gts e&#39;}
{\getref{e} \midd \mu \gts \getref{e&#39;} \midd \mu}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\getref{\ref{a}} \midd \mu \gts \get{a} \midd \mu}&lt;/script&gt;

&lt;p&gt;&lt;em&gt;[for $\setref{e_1}{e_2}$, evaluate $e_1$ and $e_2$]&lt;/em&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\vals{e_2}}
{\setref{\ref{a}}{e_2} \gts \set{a}{e_2} \midd \mu}&lt;/script&gt;
</description>
        <pubDate>Tue, 03 Mar 2015 13:28:18 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/03/03/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/03/03/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>76-221 Class 15: Gulliver&#39;s Travels</title>
        <description>&lt;h2 id=&quot;language-of-objects-p-172&quot;&gt;Language of objects (p. 172)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;“Women,” “Vulgar,” and “Illiterate” are “constant irreconcileable enemies to Science”&lt;/li&gt;
  &lt;li&gt;opposing this language is pretty reasonable&lt;/li&gt;
  &lt;li&gt;strange that the illiterate would oppose a new language&lt;/li&gt;
  &lt;li&gt;but even the illiterate realize how terrible this is&lt;/li&gt;
  &lt;li&gt;implies that women talk too much, though this is Swift criticizing Gulliver and this society&lt;/li&gt;
  &lt;li&gt;speak with &lt;em&gt;tongues&lt;/em&gt;, with the body
    &lt;ul&gt;
      &lt;li&gt;p. 191: “my tongue is in the Mouth of my Friend” when using a translator, also French kissing&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;language is &lt;em&gt;abstract&lt;/em&gt; (more than just objects) and &lt;em&gt;physical&lt;/em&gt; (tongues)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;struldbrugs&quot;&gt;Struldbrugs&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;immortal humans who also age indefinitely&lt;/li&gt;
  &lt;li&gt;nature is directional, towards death&lt;/li&gt;
  &lt;li&gt;turning cucumbers back to sunbeams is thus unnatural&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;houyhnhnms&quot;&gt;Houyhnhnms&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;portrayed as perfectly rational , and thus people&lt;/li&gt;
  &lt;li&gt;yet, Yahoos feel more like people&lt;/li&gt;
  &lt;li&gt;have capacity for misrepresentation and genocide&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;p-221&quot;&gt;p. 221&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;no word for lying&lt;/li&gt;
  &lt;li&gt;deficient language&lt;/li&gt;
  &lt;li&gt;Gulliver defends Master, has gone over to their side&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;p-251&quot;&gt;p. 251&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;no Letters, no literature&lt;/li&gt;
  &lt;li&gt;yet, have poetry, which is possibly written, and possibly emotional (irrational)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;p-218-9&quot;&gt;p. 218-9&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Gulliver is a “perfect Yahoo”&lt;/li&gt;
  &lt;li&gt;yet, wants hides of Yahoos for clothing and shoes&lt;/li&gt;
  &lt;li&gt;Master lies, willing to hide Gulliver’s true nature&lt;/li&gt;
  &lt;li&gt;Gulliver hates Yahoos because he hates himself&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;p-249&quot;&gt;p. 249&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Houyhnhnms domesticated and bred the Yahoos
    &lt;ul&gt;
      &lt;li&gt;stupid, because asses are better workers anyways&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;now, they want to commit genocide by castrating them, yet consider this solution to avoid taking of lives&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;p-258&quot;&gt;p. 258&lt;/h3&gt;
&lt;p&gt;Gulliver kills and skins Yahoo children because their skins are softer, and he needs them for his canoe.&lt;/p&gt;
</description>
        <pubDate>Tue, 03 Mar 2015 09:00:00 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/76221/2015/03/03/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/76221/2015/03/03/</guid>
        
        
        <category>cmu</category>
        
        <category>76221</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 14: Modernized Algol</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\newcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\newcommand\ok[1]{#1~~\m{ok}}
\newcommand\oks[1]{#1~~\m{ok}_{\sig}}
\def\natt{\m{nat}}
\def\gap{\hspace{1cm}}
\def\valt{\m{val}}
\newcommand\val[1]{#1~\valt}
\newcommand\vals[1]{#1~\valt_{\scriptscriptstyle\sig}}
\newcommand\valsx[2]{#1~\valt_{\scriptscriptstyle\sig, #2}}
\def\gt{\mapsto}
\def\gts{\gt_{\scriptscriptstyle\sig}}
\newcommand\gtsx[1]{\gt_{\scriptscriptstyle\sig, #1}}
\def\defeq{\overset{def}{=}}

\def\prove{\vdash}
\def\provesig{\prove_{\scriptscriptstyle\sig}}
\def\provee{\prove_{\emptyset}}
\newcommand\provesigx[1]{\prove_{\scriptscriptstyle \sig,#1}}

\def\cmdt{\m{cmd}}
\newcommand\cmd[1]{\cmdt~#1}

\newcommand\ret[1]{\m{ret}~#1}

\newcommand\bnd[3]{\m{bnd}~#1 \leftarrow #2; #3}
\newcommand\bind[3]{\{ #1 \leftarrow #2; #3 \}}

\newcommand\final[1]{#1~\m{final}_{\scriptscriptstyle\sig}}
\newcommand\finalx[2]{#1~\m{final}_{\scriptscriptstyle\sig,#2}}

\def\midd{~||~}

\newcommand\do[1]{\m{do}~#1}

\newcommand\ifelse[3]{\m{if}~(#1)~#2~\m{else}~#3}

\newcommand\ifz[4]{\m{ifz}(#1;#2;#3.#4)}

\newcommand\dcl[3]{\m{dcl}~#1 := #2~\m{in}~#3}
\newcommand\dcla[3]{\m{dcl}(#1; #2.#3)}

\newcommand\get[1]{@#1}
\newcommand\geta[1]{\m{get}[#1]}

\newcommand\set[2]{#1 := #2}
\newcommand\seta[2]{\m{set}[#1](#2)}
$$
&lt;/div&gt;

&lt;h1 id=&quot;modernized-algol-continued&quot;&gt;Modernized Algol (continued)&lt;/h1&gt;

&lt;h2 id=&quot;safety&quot;&gt;Safety&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\forall a \in \sig . \exists e . \mu(a) = e \wedge \val{e}_{\emptyset} \wedge \prove_{\emptyset} e : \natt}
{\mu : \sig}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\provesig \ok{m} \gap \mu : \sig}
{m \midd \oks{\mu}}&lt;/script&gt;

&lt;h3 id=&quot;progress&quot;&gt;Progress&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;If $\provesig e : \tau$, then either $\vals{e}$ or $e \gts e’$.&lt;/li&gt;
  &lt;li&gt;If $\provesig \ok{m}$, then either $m \midd \final{\mu}$ or $m \midd \mu \gts m’ \midd u’$ and $\mu : \sig$.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We will consider the $\m{dcl}$ case in the proof of 2.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e : \natt \gap \ctx \provesigx{a} \ok{m}}
{\ctx \provesig \dcl{a}{e}{\ok{m}}}&lt;/script&gt;

&lt;p&gt;Suppose $\mu : \sig$. We want to show that $\dcl{a}{e}{m \midd \mu}$ or $\exists m’, \mu’ . \dcl{a}{e}{m \midd \mu} \gts m’ \midd \mu’$. By Progress 1 (or, if we’re proving (1) and (2) simultaneously, by the induction hypothesis), $\vals{e}$ or $e \gts e’$.&lt;/p&gt;

&lt;p&gt;Suppose $e \gts e’$. Then, $\dcl{a}{e}{m \midd \mu} \gts \dcl{a}{e’}{m \midd \mu}$.&lt;/p&gt;

&lt;p&gt;Suppose $\vals{e}$. Recall that&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\vals{e} \gap m \midd (\mu, a \hookrightarrow e) \gtsx{a} m&#39; \midd (\mu&#39;, a \hookrightarrow e&#39;)}
{\dcl{a}{e}{m} \midd \mu \gts \dcl{a}{e&#39;}{m&#39;} \midd \mu&#39;}&lt;/script&gt;

&lt;p&gt;We claim that $\mu, a \hookrightarrow e : \sig,a$. Note that it is implicit that $a$ is distinct from assignables in $\mu$. We want to show that&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\exists e&#39; . (\mu, a \hookrightarrow e)(a) = e&#39; \wedge \val{e&#39;}_{\emptyset} \wedge \provee e&#39;: \natt&lt;/script&gt;

&lt;p&gt;It is sufficient to show that &lt;script type=&quot;math/tex&quot;&gt;\val{e}_{\emptyset} \wedge \provee e : \natt&lt;/script&gt;. By canonical forms, &lt;script type=&quot;math/tex&quot;&gt;e = \bar{n}&lt;/script&gt; for some &lt;script type=&quot;math/tex&quot;&gt;n \in \mathbb{N}&lt;/script&gt;. Therefore, &lt;script type=&quot;math/tex&quot;&gt;\provee \bar{n} : \natt&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\val{\bar{n}}_{\emptyset}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Thus, we have shown that $\mu, a \hookrightarrow e : \sig,a$, and we can apply our induction hypothesis.&lt;/p&gt;

&lt;p&gt;By the induction hypothesis, either $\finalx{m \midd (\mu, a \hookrightarrow e)}{a}$ or $m \midd (\mu, a \hookrightarrow e) \gtsx{a} m’ \midd \hat{\mu}$. By a lemma (or by preservation), $\hat{\mu} = (\mu’, a \hookrightarrow e’)$.&lt;/p&gt;

&lt;p&gt;In the second case, $\dcl{a}{e}{m \midd \mu} \gts \dcl{a}{e’}{m’ \midd \mu’}$.&lt;/p&gt;

&lt;p&gt;In the first case, by inversion, &lt;script type=&quot;math/tex&quot;&gt;m = \ret{e&#39;}&lt;/script&gt;, where &lt;script type=&quot;math/tex&quot;&gt;\valsx{e&#39;}{a}&lt;/script&gt;. Thus, &lt;script type=&quot;math/tex&quot;&gt;\dcl{a}{e}{m \midd \mu} \gts m \midd \mu&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Thus, we have proved the $\m{dcl}$ case for Progress.&lt;/p&gt;

&lt;h3 id=&quot;preservation&quot;&gt;Preservation&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;\provesig e : \tau&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;e \gts e&#39;&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;\provesig e&#39; : \tau&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;If &lt;script type=&quot;math/tex&quot;&gt;\provesig \ok{m}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\mu : \sig&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;m \midd \mu \gts m&#39; \midd \mu&#39;&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;\provesig \ok{m&#39;}&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\mu&#39; : \sig&lt;/script&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The proof of Preservation 1 is identical to the proof for Preservation for PCF, except with extra $\sig$s throughout.&lt;/p&gt;

&lt;p&gt;The proof of Preservation 2 is by induction on the derivation of &lt;script type=&quot;math/tex&quot;&gt;m \midd \mu \gts m&#39; \midd \mu&#39;&lt;/script&gt;. The $\m{dcl}$ case is proven on p. 331 of &lt;em&gt;PFPL&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;extending-the-language&quot;&gt;Extending the Language&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\tau &amp; ::= \cdots \mid \cmd{\tau}
\end{align} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ctx \provesig e : \tau&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ctx \provesig m \sim \tau&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig m \sim \tau}
{\ctx \provesig \cmd{m} : \cmd{\tau}}&lt;/script&gt;
</description>
        <pubDate>Thu, 26 Feb 2015 13:27:18 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/02/26/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/02/26/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>76-221 Class 14: Gulliver&#39;s Travels</title>
        <description>&lt;p&gt;Rather than focusing on the political satire in &lt;em&gt;Gulliver’s Travels&lt;/em&gt;, we’re doing a more critical/perceptive reading. There are many little things in the book that are easily missed. For instance, the fire is started by a maid who is distracted reading a romance novel and thus knocks over a candle. The execution scene is a little strange, as we talked about in the last class.&lt;/p&gt;

&lt;p&gt;On p. 115, we see Gulliver’s “open mindedness” at work. He thinks he’s bigger than he is, and acts like a child to try to prove himself. He actually recognizes that what he’s doing is similar to someone pretending to be someone of higher station, which finds distasteful, but continues his behavior. We can interpret this as either hypocrisy, or &lt;em&gt;less&lt;/em&gt; generously, as sheer forgetfulness.&lt;/p&gt;

&lt;p&gt;Consider the discussion of terrible life of the immortal &lt;em&gt;struldbrugs&lt;/em&gt;. Because they still age, they end up decrepit and useless. Perhaps Swift is commenting on the naturalness of death.&lt;/p&gt;
</description>
        <pubDate>Thu, 26 Feb 2015 09:00:00 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/76221/2015/02/26/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/76221/2015/02/26/</guid>
        
        
        <category>cmu</category>
        
        <category>76221</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 13: Modernized Algol</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\newcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\newcommand\ok[1]{#1~~\m{ok}}
\def\natt{\m{nat}}
\def\gap{\hspace{1cm}}
\def\valt{\m{val}}
\newcommand\val[1]{#1~\valt}
\newcommand\vals[1]{#1~\valt_{\scriptscriptstyle\sig}}
\newcommand\valsx[2]{#1~\valt_{\scriptscriptstyle\sig, #2}}
\def\gt{\mapsto}
\def\gts{\gt_{\scriptscriptstyle\sig}}
\newcommand\gtsx[1]{\gt_{\scriptscriptstyle\sig, #1}}
\def\defeq{\overset{def}{=}}

\def\prove{\vdash}
\def\provesig{\prove_{\scriptscriptstyle\sig}}
\newcommand\provesigx[1]{\prove_{\scriptscriptstyle \sig,#1}}

\def\cmdt{\m{cmd}}
\newcommand\cmd[1]{\cmdt~#1}

\newcommand\ret[1]{\m{ret}~#1}

\newcommand\bnd[3]{\m{bnd}~#1 \leftarrow #2; #3}
\newcommand\bind[3]{\{ #1 \leftarrow #2; #3 \}}

\newcommand\final[1]{#1~\m{final}_{\scriptscriptstyle\sig}}

\def\midd{~||~}

\newcommand\do[1]{\m{do}~#1}

\newcommand\ifelse[3]{\m{if}~(#1)~#2~\m{else}~#3}

\newcommand\ifz[4]{\m{ifz}(#1;#2;#3.#4)}

\newcommand\dcl[3]{\m{dcl}~#1 := #2~\m{in}~#3}
\newcommand\dcla[3]{\m{dcl}(#1; #2.#3)}

\newcommand\get[1]{@#1}
\newcommand\geta[1]{\m{get}[#1]}

\newcommand\set[2]{#1 := #2}
\newcommand\seta[2]{\m{set}[#1](#2)}
$$
&lt;/div&gt;

&lt;h1 id=&quot;imperative-languages&quot;&gt;Imperative Languages&lt;/h1&gt;
&lt;p&gt;We’re going to discuss Algol, which inspired Pascal, which inspired C. In particular, we’re going talk about &lt;em&gt;Modernized Algol&lt;/em&gt;, which isn’t a real language.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Expressions&lt;/em&gt; are &lt;em&gt;pure&lt;/em&gt;: they have no side effects. Expressions are often referred to as terms.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Commands&lt;/em&gt; are &lt;em&gt;impure&lt;/em&gt;: they may have &lt;em&gt;side effects&lt;/em&gt;; they do something to the world. Side effects can involve changes to the store (modifying memory), or input and output. Commands are often referred to as, rather confusingly, expressions.&lt;/p&gt;

&lt;h1 id=&quot;modernized-algol&quot;&gt;Modernized Algol&lt;/h1&gt;
&lt;p&gt;A lot of justifications for why things in this language are the way they are will be by &lt;em&gt;lax logic&lt;/em&gt;.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\tau &amp; ::= \cdots \mid \cmdt \\
e &amp; ::= \cdots \mid \cmd{m} \\
m &amp; ::= \ret{e} \mid \bnd{x}{e}{m} \mid \dcl{a}{e}{m} \mid \get{a} \mid \set{a}{e}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;$m$ is a &lt;em&gt;command&lt;/em&gt;. $a$ is an &lt;em&gt;assignable&lt;/em&gt;. It’s commonly referred to as a variable, which is incorrect, because it’s not given meaning through substitution.&lt;/p&gt;

&lt;p&gt;Note that $\m{bnd}$ is not the same as $\m{let}$. With a $\m{bnd}$ command, once $e$ becomes a value, we know it’s a encapsulated command, so we execute it. With a $\m{let}$ expression, we substitute the value of $e$ in for $x$.&lt;/p&gt;

&lt;p&gt;The abstract syntax for some of the commands are:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\dcla{e}{a}{m} \gap \geta{a} \gap \seta{a}{e}&lt;/script&gt;

&lt;h2 id=&quot;static-semantics&quot;&gt;Static Semantics&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ctx \provesig e : \tau&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\sig&lt;/script&gt; is a &lt;em&gt;signature&lt;/em&gt;. In this language, it is a set of assignables.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx, x : \tau \provesig e : \tau&#39;}
{\ctx \provesig \lambda x : \tau . e : \tau \rightharpoonup \tau&#39;}
&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ctx \provesig \ok{m}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig \ok{m}}
{\ctx \provesig \cmd{m} : \cmdt}
&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e : \natt}
{\ctx \provesig \ok{\ret{e}}}
&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e : \cmdt \gap \Gamma, x : \natt \provesig \ok{m}}
{\ctx \provesig \ok{\bnd{x}{e}{m}}}
&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \provesig e : \natt \gap \ctx \provesigx{a} \ok{m}}
{\ctx \provesig \dcl{a}{e}{\ok{m}}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{a \in \sig}
{\ctx \provesig \ok{\get{a}}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{a \in \sig \gap \ctx \provesig e : \natt}
{\ctx \provesig \ok{\set{a}{e}}}&lt;/script&gt;

&lt;p&gt;Note that there is an implicit assumption that $a \not\in \sig$. Note also that this assignment is not persistent. In an implementation, $a$ would reside on the stack, and this is commonly referred to as &lt;em&gt;stack discipline&lt;/em&gt;.&lt;/p&gt;

&lt;h2 id=&quot;operational-semantics&quot;&gt;Operational Semantics&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\vals{e}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e \gts e&#39;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;m \midd \mu \gts m&#39; \midd \mu&#39;&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\mu&lt;/script&gt; is a &lt;em&gt;state&lt;/em&gt;, representing memory where assignables are mapped to values. $m$ is a command.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\final{m \midd \mu}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}{\vals{\cmd{m}}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\vals{e}}
{\ret{e} \midd \final{\mu}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \gts e&#39;}
{\ret{e} \midd \mu \gts \ret{e&#39;} \midd \mu}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \gts e&#39;}
{\bnd{x}{e}{m} \midd \mu \gts \bnd{x}{e&#39;}{m \midd \mu}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{m_1 \midd \mu \gts m_1&#39; \midd \mu&#39;}
{\bnd{x}{\cmd{m_1}}{m_2} \midd \mu \gts \bnd{x}{\cmd{m_1&#39;}}{m_2} \midd \mu}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\vals{e}}
{\bnd{x}{\cmd{(\ret{e})}}{m} \midd \mu \gts [e/x]~m \midd \mu}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \gts e&#39;}
{\dcl{a}{e}{m} \midd \mu \gts \dcl{a}{e&#39;}{m} \midd \mu}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\vals{e} \gap m \midd (\mu, a \hookrightarrow e) \gtsx{a} m&#39; \midd (\mu&#39;, a \hookrightarrow e&#39;)}
{\dcl{a}{e}{m} \midd \mu \gts \dcl{a}{e&#39;}{m&#39;} \midd \mu&#39;}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\vals{e_1} \gap \valsx{e_2}{a}}
{\dcl{a}{e_1}{\ret{e_2}} \midd \mu \gts \ret{e_2} \midd \mu}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\get{a} \midd (\mu, a \hookrightarrow e) \gtsx{a} \ret{e} \midd (\mu, a \hookrightarrow e)}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e_1 \gtsx{a} e_1&#39;}
{\set{a}{e} \midd \mu \gts \set{a}{e_1&#39;} \midd \mu}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\vals{e_1}}
{\set{a}{e_1} \midd (\mu, a \hookrightarrow e_2) \gts \ret{e_1} \midd (\mu, a \hookrightarrow e_1)}&lt;/script&gt;

&lt;h2 id=&quot;syntactic-sugar&quot;&gt;Syntactic Sugar&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\bind{x}{m}{m&#39;} &amp; \defeq \bnd{x}{\cmd{m}}{m&#39;} \\
\do{e} &amp; \defeq \bnd{x}{e}{\ret{x}} \\
\ifelse{m}{m_1}{m_2} &amp; \defeq \bind{x}{m}{\do{(\ifz{x}{\cmd{m_1}}{\_}{\cmd{m_2}})}}
\end{align} %]]&gt;&lt;/script&gt;
</description>
        <pubDate>Tue, 24 Feb 2015 13:30:41 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/02/24/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/02/24/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>76-221 Class 13: Gulliver&#39;s Travels</title>
        <description>&lt;p&gt;Occasionally, irrationality is part of being human. Swift was an early proponent of the idea that the main thing that differentiates from animals is language.&lt;/p&gt;

&lt;h2 id=&quot;p-62&quot;&gt;p. 62&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;lots of unnecessary detail&lt;/li&gt;
  &lt;li&gt;joke is that he doesn’t need to defend her, because he is 12 times larger than her&lt;/li&gt;
  &lt;li&gt;too much association with the Lilliputians&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;p-80&quot;&gt;p. 80&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;long, overly-detailed passages as a game&lt;/li&gt;
  &lt;li&gt;playing with the reader&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pp-21-2&quot;&gt;pp. 21-2&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Swift is fond of puns&lt;/li&gt;
  &lt;li&gt;“Master Mr. Bates” to “Mr. Bates” to, finally, “Master Bates”&lt;/li&gt;
  &lt;li&gt;purpose of language is not communication
    &lt;ul&gt;
      &lt;li&gt;part of who we are&lt;/li&gt;
      &lt;li&gt;like why a monkey swings on his tail&lt;/li&gt;
      &lt;li&gt;something for us to play with&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;p-71&quot;&gt;p. 71&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;a “real boat” is real because it’s his size&lt;/li&gt;
  &lt;li&gt;shows he is getting out of his fictional mindset&lt;/li&gt;
  &lt;li&gt;Swift is showing that the body insists when it is denied&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;pp-82-3&quot;&gt;pp. 82-3&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Worries that Brobdingnags would dash him against the ground, just as he was earlier considering dashing the Lilliputians against the ground
    &lt;ul&gt;
      &lt;li&gt;He doesn’t explicitly recognize this connection&lt;/li&gt;
      &lt;li&gt;to be human is to make connections, to have narrative history&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;p-110&quot;&gt;p. 110&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;beauty is relative, but still necessary&lt;/li&gt;
  &lt;li&gt;it’s all a matter of perspective&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;p-111&quot;&gt;p. 111&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;right after passage on beauty (or lack thereof)&lt;/li&gt;
  &lt;li&gt;grotesque&lt;/li&gt;
  &lt;li&gt;fountain of blood from neck stump compared to fountain in Palace of Versailles
    &lt;ul&gt;
      &lt;li&gt;quite an inappropriate comparison&lt;/li&gt;
      &lt;li&gt;misfit&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;neither the actual beheading nor the fountain of blood bothered him, but the bouncing of the head startled him&lt;/li&gt;
&lt;/ul&gt;

&lt;blockquote&gt;
  &lt;p&gt;Aside: William Boroughs claimed the above two passages inspired &lt;em&gt;Naked Lunch.&lt;/em&gt; He claims they present an argument against capital punishment.&lt;/p&gt;
&lt;/blockquote&gt;
</description>
        <pubDate>Tue, 24 Feb 2015 09:00:00 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/76221/2015/02/24/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/76221/2015/02/24/</guid>
        
        
        <category>cmu</category>
        
        <category>76221</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 12: The Untyped Lambda Calculus</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\newcommand{\m}[1]{\textsf{#1}}
\def\okt{\m{ok}}
\newcommand\ok[1]{#1\;\okt}
\def\ctx{\Gamma}
\def\defeq{\overset{def}{=}}
\def\succ{\m{succ}}
\def\plus{\m{plus}}
\def\times{\m{times}}
\def\zero{\bar{0}}
\def\ifz{\m{ifz}}
\def\pred{\m{pred}}
\newcommand\pair[2]{\langle #1, #2 \rangle}
\def\yc{\m{Y}}
$$
&lt;/div&gt;

&lt;h1 id=&quot;the-untyped-lambda-calculus&quot;&gt;The Untyped $\lambda$-Calculus&lt;/h1&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;u = x \mid \lambda x . t \mid uu&lt;/script&gt;

&lt;p&gt;Since this is untyped, $\ok{u}$ and&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ok{u} \in \ctx}
{\Gamma \vdash \ok{u}}
&lt;/script&gt;

&lt;p&gt;We have the rules you’d expect for the $\okt$ judgement, and for equivalence. &lt;em&gt;[They were illegible. See PFPL 17.1]&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;church-encoding&quot;&gt;Church encoding&lt;/h2&gt;
&lt;p&gt;Church numerals are (the best-known) special case of Church encoding. We will use $\bar{0}$ to represent numbers in the language, rather than the real world.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\bar{0} \defeq \lambda b . \lambda s . b&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\bar{1} \equiv \lambda b . \lambda s . s(b)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\overline{n + 1} \defeq \lambda b . \lambda s . s(\bar{n} \; b \; s)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\succ \defeq \lambda f . \lambda b . \lambda s . s(f \; b \; s)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\succ&#39; \defeq \lambda f . \lambda b . \lambda s . f(s \; b) s&lt;/script&gt;

&lt;p&gt;We can prove, for any $n \in \mathbb{N}$, &lt;script type=&quot;math/tex&quot;&gt;\succ(\bar{n}) \equiv \succ&#39;(\bar{n}) \equiv \overline{n+1}&lt;/script&gt; by induction on $n$.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align*}
\plus &amp; = \lambda m . \lambda n . \lambda b . \lambda s . n \; (m \; b \; s) \; s \\
&amp; = \lambda m . \lambda n . m \; n \; \succ \\
\times &amp; = \lambda m . \lambda n . m \; \zero \; (\plus n)
\end{align*} %]]&gt;&lt;/script&gt;

&lt;p&gt;To define $\ifz$, we need to be able to find the predecessor of something:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ifz\{e, e_0, x. e_s\} = e \; e_0 \; (\lambda \_ . [\pred \; e / x] e_s)&lt;/script&gt;

&lt;p&gt;We define $\pred$ as&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\pred(\zero) &amp; \equiv \zero \\
\pred(\overline{n+1}) &amp; \equiv \bar{n}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Returning to Church encodings, we need to represent numbers as their iterators. This is necessary to be able to obtain the predecessor of a value. First, we define pairs&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\pair{u_1}{u_2} &amp; \defeq \lambda f . f \; u_1 \; u_2 \\
u \cdot l &amp; \defeq u \; (\lambda x . \lambda y . x) \\
u \cdot r &amp; \defeq u \; (\lambda x . \lambda y . y)
\end{align} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\pred&#39; &amp; = \lambda n . n \; \pair{\zero}{\zero} \; (\lambda p . \pair{p \cdot r}{\succ \; (p \cdot r)}) \\
\pred &amp; = \lambda n . \pred&#39; \; (n) \cdot l
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;To implement $\m{fix}$, we define the $\yc$ combinator.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\yc \defeq \lambda f . (\lambda x . f \; (x \; x)) \; (\lambda x . f \; (x \; x))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\yc \; F &amp; \equiv (\lambda x . F \; (x \; x)) \; (\lambda x . F \; (x \; x)) \\
&amp; \equiv F \; ((\lambda x . F \; (x \; x)) \; (\lambda x . F \; (x \; x))) \\
&amp; \equiv F \; (\lambda f . (\lambda x . f \; (x \; x)) (\lambda x . f \; (x \; x))) \; F \\
&amp; \equiv F \; (\yc \; F)
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Thus, we have all the computational power of PCF (and computation in general) in a much more compact language.&lt;/p&gt;

&lt;h2 id=&quot;scotts-theorem&quot;&gt;Scott’s Theorem&lt;/h2&gt;
&lt;p&gt;There exists no effectively computable (computable in the $\lambda$-calculus) algorithm for testing the equivalence of two lambda terms.&lt;/p&gt;

&lt;p&gt;Scott’s Theorem is a special case of &lt;em&gt;Rice’s Theorem&lt;/em&gt;, which states that there exists no effective computable algorithm that can test any (nontrivial, behavioral) property of lambda terms.&lt;/p&gt;

&lt;p&gt;A property $A$ is &lt;em&gt;trivial&lt;/em&gt; if $\forall u . A(u)$ or $\forall u . \neg A(u)$.&lt;/p&gt;

&lt;p&gt;A property $A$ is &lt;em&gt;behavioral&lt;/em&gt; if $u \equiv u’ \supset A(u) \iff A(u’)$.&lt;/p&gt;
</description>
        <pubDate>Thu, 19 Feb 2015 13:30:00 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/02/19/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/02/19/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 11: Dynamic Languages as Typed Languages</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\newcommand{\m}[1]{\textsf{#1}}
\def\ok{\m{ok}}
\def\num{\m{num}}
\def\fun{\m{fun}}
\def\dyn{\m{dyn}}
\def\nat{\m{nat}}
\def\new{\m{new}}
\def\cast{\m{cast}}
\def\err{\m{ err}}
\def\inst{\m{inst}}
\def\bool{\m{bool}}
\def\true{\m{true}}
\def\false{\m{false}}
$$
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Delivered by Bob Harper&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;dpcf-continued&quot;&gt;DPCF (continued)&lt;/h1&gt;
&lt;p&gt;Recall that DPCF is “dynamic PCF” (looks like PCF without types). There are two classes of values:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;numbers $\num[n]$, where $\num$ is a class of numbers&lt;/li&gt;
  &lt;li&gt;functions $\fun(x.d)$, where $\fun$ is a class of functions&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Recall that classes are not types. So, the classes are $\num$ and $\fun$, but both their types are $\ok$. So, while dynamic languages are often said to have “runtime type checking,” this is not quite correct. What we actually have is runtime &lt;em&gt;class&lt;/em&gt; checking:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;$d \m{ is_num } n$.&lt;/li&gt;
  &lt;li&gt;$d \m{ is_fun } x.d’$.&lt;/li&gt;
  &lt;li&gt;$d \m{ isnt_num}$.&lt;/li&gt;
  &lt;li&gt;$d \m{ isnt_fun}$.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;which requires space, requires time, and can fail.&lt;/p&gt;

&lt;h1 id=&quot;hybrid-pcf&quot;&gt;Hybrid PCF&lt;/h1&gt;
&lt;p&gt;We can define a hybrid PCF as PCF $+$ $\dyn$, which is a subset of $FPC$ with recursive types. This lets us have “dynamic” typing while still being able to perform program transformations.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\tau ::= \nat \mid \tau_1 \rightharpoonup \tau_2 \mid \dyn&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\new[c](e) : \dyn \m{ if } \begin{cases}
e : \nat &amp; \m{if } c = \num \\
e : \dyn \rightharpoonup \dyn &amp; \m{if } c= \fun
\end{cases} %]]&gt;&lt;/script&gt;

&lt;p&gt;e.g. &lt;script type=&quot;math/tex&quot;&gt;\new[\num](7) : \dyn&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\num[\fun](7)\;X&lt;/script&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\cast[c](e) : \begin{cases}
\nat &amp; \m{if } c = \num \\
\dyn \rightharpoonup \dyn &amp; \m{if } c = \fun
\end{cases} \text{ where $e : \dyn$} %]]&gt;&lt;/script&gt;

&lt;p&gt;e.g. &lt;script type=&quot;math/tex&quot;&gt;\cast[\fun](\new[\num](\_))\err&lt;/script&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\inst[c](e) : \bool \text{ where $e : \dyn$}&lt;/script&gt;

&lt;p&gt;e.g. &lt;script type=&quot;math/tex&quot;&gt;\inst[\num](\new[\num](\_)) = \true&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;Note that if&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x_1 : \ok, \ldots, x_n : \ok \vdash_{DPCF} d : \ok&lt;/script&gt;

&lt;p&gt;then&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x_1 : \dyn,\ldots,x_n : \dyn \vdash_{HPCF} d^+ : \dyn&lt;/script&gt;

&lt;p&gt;and the behavior is preserved.&lt;/p&gt;

&lt;p&gt;Ultimately, it makes much more sense to use a static language with type inference than a dynamic language. In either case, you can write code without explicit types. But with the static language, the compiler can perform transformations and guarantee (useful) type safety.&lt;/p&gt;

&lt;h1 id=&quot;dpcf-subseteq-hpcf-subseteq-fpc&quot;&gt;&lt;script type=&quot;math/tex&quot;&gt;DPCF \subseteq HPCF \subseteq FPC&lt;/script&gt;&lt;/h1&gt;
&lt;p&gt;(dynamic typing $\subseteq$ static typing $\subseteq$ FPC)&lt;/p&gt;

&lt;p&gt;Dynamic typing is not in opposition to static typing, because it is a subset of static typing. However, HPCF is an entirely artificial construct. It’s simply a way to show the power of FPC. FPC has many other useful features.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;FPC = \lambda \{ 0 ~ 1 + \times \to \mu \}&lt;/script&gt;
</description>
        <pubDate>Tue, 17 Feb 2015 13:30:00 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/02/17/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/02/17/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>76-221 Class 11: Gulliver&#39;s Travels</title>
        <description>&lt;p&gt;The prevailing idea of what it means to be a person at the time &lt;em&gt;Gulliver’s Travels&lt;/em&gt; was written was:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;chain of being: God to angels to humans (rational animals)&lt;/li&gt;
  &lt;li&gt;hierarchy&lt;/li&gt;
  &lt;li&gt;animals are without spirit or reason&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Is Gulliver a rational animal? We can consider him rational because he’s clearly a thinking being. But, we can also consider him an animal, and sometimes even irrational:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;talks about “making water” (p. 27)&lt;/li&gt;
  &lt;li&gt;traveling repeatedly despite the trouble he always runs into&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Compare &lt;em&gt;Gulliver’s Travels&lt;/em&gt; to the &lt;em&gt;Odyssey&lt;/em&gt;:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;emphasis on travel versus homecoming&lt;/li&gt;
  &lt;li&gt;hospitality
    &lt;ul&gt;
      &lt;li&gt;because strangers may be gods in the &lt;em&gt;Odyssey&lt;/em&gt;&lt;/li&gt;
      &lt;li&gt;why is hospitality so common in &lt;em&gt;Gulliver’s Travels&lt;/em&gt;?&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Cross-culture assimilation is part of human nature. But Gulliver takes it perhaps too far: he pretends to be a Lilliputian, and looks down on nobles of lower rank in their society. When he “makes water,” he sees it from their perspective: as a “torrent.”&lt;/p&gt;

&lt;p&gt;Violence is very much a part of Gulliver’s society, at least directed at smaller beings. He thinks nothing of dashing small animals against the ground. But, honor holds him back from doing so to the similarly small Lilliputians: assimilation!&lt;/p&gt;

&lt;p&gt;Is Gulliver a reliable narrator? While reading, it is easy for us to “believe in” the Lilliputians. &lt;/p&gt;
</description>
        <pubDate>Tue, 17 Feb 2015 00:09:00 -0500</pubDate>
        <link>http://www.tomshen.me/notes/cmu/76221/2015/02/17/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/76221/2015/02/17/</guid>
        
        
        <category>cmu</category>
        
        <category>76221</category>
        
      </item>
    
  </channel>
</rss>
