<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Notes</title>
    <description>Notes on classes at CMU.
</description>
    <link>http://www.tomshen.me/notes/</link>
    <atom:link href="http://www.tomshen.me/notes/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 23 Apr 2015 14:45:08 -0400</pubDate>
    <lastBuildDate>Thu, 23 Apr 2015 14:45:08 -0400</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>15-312 Lecture 26: Proofs as Programs</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\renewcommand\defeq{\overset{def}{=}}

\renewcommand{\true}[1]{#1~\m{true}}

\renewcommand{\intro}[1]{#1\text{-I}}
\renewcommand{\elim}[1]{#1\text{-E}}

\renewcommand{\pair}[2]{\langle #1, #2 \rangle}
\renewcommand{\proj}[2]{#1.#2}
\renewcommand{\inl}[1]{\m{inl}~#1}
\renewcommand{\inr}[1]{\m{inr}~#1}
\renewcommand{\case}[5]{\m{case}(#1;#2.#3;#4.#5)}
\renewcommand{\unit}{()}
\renewcommand{\abort}[1]{\m{abort}~#1}
$$
&lt;/div&gt;

&lt;p&gt;We’ll be talking about&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;propositions as types&lt;/li&gt;
  &lt;li&gt;proofs as programs&lt;/li&gt;
  &lt;li&gt;the Curry-Howard Isomorphism&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;propositions-as-types&quot;&gt;Propositions as types&lt;/h1&gt;

&lt;h2 id=&quot;propositions&quot;&gt;Propositions&lt;/h2&gt;

&lt;p&gt;What is the meaning of a logical proposition? e.g.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\|x\| = 121, \|x\| = 0&lt;/script&gt;

&lt;p&gt;&lt;em&gt;Denotation&lt;/em&gt; is the assignment of mathematic expressions, and is the truth value.&lt;/p&gt;

&lt;p&gt;So, &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; &lt;strong&gt;is&lt;/strong&gt; &lt;script type=&quot;math/tex&quot;&gt;121&lt;/script&gt;. But, this means that &lt;script type=&quot;math/tex&quot;&gt;\|x\| = 121&lt;/script&gt; is the same as&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall n &gt; 2 . \forall x,y,z \in \mathbb{N}. x^n + y^n \neq z^n,&lt;/script&gt;

&lt;p&gt;since both are true.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Sense&lt;/em&gt; is &lt;em&gt;[missing]&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;We want both denotation and sense. To resolve this, we want to focus on the proofs.&lt;/p&gt;

&lt;h2 id=&quot;judgments&quot;&gt;Judgments&lt;/h2&gt;

&lt;p&gt;We define a judgment &lt;script type=&quot;math/tex&quot;&gt;\true{A}&lt;/script&gt;. We also assume we have &lt;em&gt;atomic propositions&lt;/em&gt; that we know the proofs for, such as &lt;script type=&quot;math/tex&quot;&gt;11 \times 11 = 121&lt;/script&gt;.&lt;/p&gt;

&lt;h3 id=&quot;introduction&quot;&gt;Introduction&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \true{A} \qquad
    \true{B}
}{
    \true{A \wedge B}
}(\intro{\wedge})&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \true{A}
}{
    \true{A \vee B}
}(\intro{\vee}1)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \true{B}
}{
    \true{A \vee B}
}(\intro{\vee}2)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{

}{
    \true{T}
}(\intro{T})&lt;/script&gt;

&lt;p&gt;(&lt;script type=&quot;math/tex&quot;&gt;\supset&lt;/script&gt; is implication)&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \true{A} \vdash \true{B}
}{
    \true{A \supset B}
}(\intro{\supset})&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg A \defeq A \supset F&lt;/script&gt;

&lt;h3 id=&quot;elimination&quot;&gt;Elimination&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \true{A \wedge B}
}{
    \true{A}
}(\elim{\wedge}1)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \true{A \wedge B}
}{
    \true{B}
}(\elim{\wedge}2)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \true{A \vee B} \qquad
    \true{A} \vdash \true{C} \qquad
    \true{B} \vdash \true{C}
}{
    \true{C}
}(\elim{\vee})&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \true{F}
}{
    \true{C}
}(\elim{F})&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \true{A \supset B} \qquad
    \true{A}
}{
    \true{B}
}(\elim{\supset})&lt;/script&gt;

&lt;h2 id=&quot;intuitionistic--constructive-logic&quot;&gt;Intuitionistic / Constructive Logic&lt;/h2&gt;
&lt;p&gt;We’ve just defined the basics of constructive logic. Note that we cannot prove that, in general,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{

}{
    \true{A \vee \neg A}
}.&lt;/script&gt;

&lt;p&gt;In other words, we do not have the &lt;em&gt;law of excluded middle&lt;/em&gt;. Similarly, we cannot prove&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \true{\neg \neg A} \qquad
    \true{A}
}{
    \neg \neg A \supset \true{A}
},&lt;/script&gt;

&lt;p&gt;which is &lt;em&gt;double negation elimination&lt;/em&gt;, since it is equivalent to the law of excluded middle. This is important since this is how we do proof by contradiction.&lt;/p&gt;

&lt;p&gt;You may think that classical logic is “better,” since we have these (pretty handy) theorems. But, you lose the distinction between &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\neg \neg A&lt;/script&gt;. Thus, &lt;strong&gt;intuitionistic logic has more expressive power.&lt;/strong&gt; Additionally, intuitionistic logic has a useful computational interpretation.&lt;/p&gt;

&lt;h1 id=&quot;proofs-as-programs&quot;&gt;Proofs as programs&lt;/h1&gt;

&lt;p&gt;We represent “&lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is a &lt;em&gt;proof term&lt;/em&gt; for &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;” with &lt;script type=&quot;math/tex&quot;&gt;M : A&lt;/script&gt;.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    M : A \qquad
    N : B
}{
    \pair{M}{N} : A \wedge B
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    M : A \wedge B
}{
    \proj{M}{l} : A
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    M : A \wedge B
}{
    \proj{M}{r} : B
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    x : A \vdash M : B
}{
    \lambda x : A.M : A \supset B
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    M : A \supset B \qquad
    N : A
}{
    MN : B
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    M : A
}{
    \inl{M} : A \vee B
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    M : B
}{
    \inr{M} : A \vee B
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    M : A \vee B \qquad
    x : A \vdash N : C \qquad
    y : B \vdash O : C
}{
    \case{M}{x}{N}{y}{O} : C
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{

}{
    \unit : T
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    M : F
}{
    \abort{M} : C
}&lt;/script&gt;

&lt;p&gt;So, a proof of &lt;script type=&quot;math/tex&quot;&gt;\true{(A \supset B) \supset (\neg B \supset \neg A)}&lt;/script&gt; would be&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\lambda f : A \supset B . \lambda y : \neg B . \lambda x : A . g(f x)&lt;/script&gt;

&lt;p&gt;This is the &lt;em&gt;Curry-Howard Isomorphism&lt;/em&gt;!&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Propositions&lt;/th&gt;
      &lt;th&gt;Types&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;A \wedge B&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;A \times B&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;A \vee B&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;A + B&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;A \supset B&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;A \to B&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\unit&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\m{void}&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\forall x . A&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\pi x . A&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Note that recursive types don’t work out well, since it’s then possible to prove any proposition.&lt;/p&gt;
</description>
        <pubDate>Thu, 23 Apr 2015 13:32:05 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/04/23/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/04/23/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 25: Concurrency &amp; Interaction (continued)</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
$$
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Delivered by Bob Harper&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;asynchronous-process-calculus&quot;&gt;Asynchronous Process Calculus&lt;/h1&gt;
&lt;p&gt;Previously, we discussed sychronous process calculus. But, how is a process supposed to know that some other process has received a message it sent? There must be some sort of back channel between these processes that sends a “notification.”&lt;/p&gt;

&lt;p&gt;We only have receive events:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;E ::= \cdots \mid ?a(x.P) \mid O | E_1 + E_2&lt;/script&gt;

&lt;p&gt;Thus, an event will always be of the form&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;?a_1(x_1.P_1) | \cdots | ?a_n(x_n.P_n)&lt;/script&gt;

&lt;p&gt;This is like &lt;code&gt;select&lt;/code&gt; in CML and Unix sockets.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P ::= \$E \mid !a(v) \mid \nu a \sim \tau.P \mid 1 \mid P_1 \parallel P_2&lt;/script&gt;

&lt;p&gt;We acknowledge receipt by sending &lt;script type=&quot;math/tex&quot;&gt;\langle \rangle&lt;/script&gt;. We arrange to have backchannels through our own programming.&lt;/p&gt;

&lt;p&gt;What about types on channels?&lt;/p&gt;

&lt;p&gt;You can choose your own by specifying &lt;script type=&quot;math/tex&quot;&gt;\tau&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;\nu a \sim \tau.P&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Or, we choose a specific type, via &lt;em&gt;polyadic &lt;script type=&quot;math/tex&quot;&gt;\pi&lt;/script&gt;-calculus&lt;/em&gt;. We declare channels with &lt;script type=&quot;math/tex&quot;&gt;\nu a .P&lt;/script&gt;. No type is specified, and instead you send a tuple of things and pattern match.&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\nu a \sim \pi . P&lt;/script&gt;. We can only send channels. Data is represented by processes. Milner numerals are process calculus versions of Church numerals.&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\pi \cong \sum_{n \in \mathbb{N}} \pi~\m{chan} \times \cdots \times \pi~\m{chan}&lt;/script&gt;&lt;br /&gt;
(n times)&lt;/p&gt;

&lt;p&gt;Note that &lt;script type=&quot;math/tex&quot;&gt;\pi&lt;/script&gt; is a recursive type, and that consitutent types are channel references, which admit both send and receive. Recall that &lt;script type=&quot;math/tex&quot;&gt;\Lambda&lt;/script&gt; (the &lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt;-calculus) is universal with respect to &lt;script type=&quot;math/tex&quot;&gt;\m{nat} \rightharpoonup \m{nat}&lt;/script&gt;, because &lt;script type=&quot;math/tex&quot;&gt;\lambda \cong (\lambda \to \lambda)&lt;/script&gt;, so we can encode the Y combinator and have recursion. The &lt;script type=&quot;math/tex&quot;&gt;\pi&lt;/script&gt;-calculus is also universal with respect to &lt;script type=&quot;math/tex&quot;&gt;\m{nat} \rightharpoonup \m{nat}&lt;/script&gt;, because we can encode &lt;script type=&quot;math/tex&quot;&gt;\Lambda&lt;/script&gt; into &lt;script type=&quot;math/tex&quot;&gt;\Pi&lt;/script&gt;. This only works because we have the recursive type.&lt;/p&gt;

&lt;h1 id=&quot;encoding-lambda&quot;&gt;Encoding &lt;script type=&quot;math/tex&quot;&gt;\Lambda&lt;/script&gt;&lt;/h1&gt;
&lt;p&gt;Key ideas:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt;-terms have names–channels&lt;/li&gt;
  &lt;li&gt;channels name servers taht can be contacted to obtain their value by passing a backchannel to a continuation (stack, &lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt;-term)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Define $M@k$, where $k$ is a channel reference.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$x @ k \triangleq !!(x;k)$, where $x$ is going to be a $\lambda$-term&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;(\lambda x . M) @ k \triangleq \$(??(k; \langle x, k&#39;\rangle. M @ k))&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
(M~N)@k \triangleq \nu m .(M @ (\&amp;m)) \parallel \nu a . (!m(\langle \&amp; a, k \rangle); *\$(?a.(n.(N~e~n)))) %]]&gt;&lt;/script&gt;, where &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
!m(\langle \&amp; a, k \rangle %]]&gt;&lt;/script&gt; informs &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; of its argument’s location (server) and where to deliver result, and &lt;script type=&quot;math/tex&quot;&gt;*\$(?a.(n.(N~e~n)))&lt;/script&gt; is the “&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; server”&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;[This is tricky and low level. We aren’t really expected to understand it]&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;consolidated-message-passing&quot;&gt;Consolidated Message Passing&lt;/h1&gt;
&lt;p&gt;We currently have $a!v$ and $a?v$, but instead, we could label our payloads with a header: $!(a.v)$ and $?(a.v)$. &lt;strong&gt;Globally unique identifiers are just reimplementing &lt;script type=&quot;math/tex&quot;&gt;\alpha&lt;/script&gt;-conversion.&lt;/strong&gt; A channel is a dynamic class, and a message is just a value of type &lt;script type=&quot;math/tex&quot;&gt;\m{clsfd}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;a \sim \tau&lt;/script&gt; is a class classifying values of type &lt;script type=&quot;math/tex&quot;&gt;\tau&lt;/script&gt;. Channels have nothing to do with concurrency (inherently, at least).&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P ::= !v \mid ?(x.P) \mid P_1 \parallel P_2 \mid 1&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Concurrency is non-deterministic composition.&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 21 Apr 2015 13:29:18 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/04/21/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/04/21/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 24: Concurrency &amp; Interaction (continued)</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
$$
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Delivered by Bob Harper&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Recall that we defined processes:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt; P ::= \$E \mid P_1 \parallel P_2 \mid \bot \mid *P &lt;/script&gt;

&lt;p&gt;and events:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt; E ::= ?a.P \mid !a.P \mid E_1 + E_2 \mid 0 &lt;/script&gt;

&lt;p&gt;We have a labeled transition system &lt;script type=&quot;math/tex&quot;&gt;P \overset{\alpha}{\mapsto} P&#39;&lt;/script&gt; where&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt; \alpha ::= a? \mid a! \mid \varepsilon &lt;/script&gt;

&lt;p&gt;and &lt;script type=&quot;math/tex&quot;&gt;\overline{a?} \triangleq a!&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\overline{a!} \triangleq a?&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt; \overline{\varepsilon} \triangleq \varepsilon&lt;/script&gt;. (&lt;script type=&quot;math/tex&quot;&gt;P \mapsto P&#39;&lt;/script&gt; means &lt;script type=&quot;math/tex&quot;&gt;P \overset{\varepsilon}{\mapsto} P&#39;&lt;/script&gt;).&lt;/p&gt;

&lt;p&gt;We used iteration (&lt;script type=&quot;math/tex&quot;&gt;*P \equiv P \parallel *P&lt;/script&gt;) to replace recursive definitions, using a system with &lt;em&gt;sparks:&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;spark: &lt;script type=&quot;math/tex&quot;&gt;\$(!x;1)&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;activator: &lt;script type=&quot;math/tex&quot;&gt;*\$(?x; P(\$(!x;1)))&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; becomes &lt;script type=&quot;math/tex&quot;&gt;*\$(?x; P(\$(!x;1))) \mid \$(!x;1)&lt;/script&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Note that channel &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; is dedicated to the implementation &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt;. But, shouldn’t the channel &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; be private to the definition? Thus, we introduce a new process (called a &lt;em&gt;channel&lt;/em&gt;):&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P ::= \cdots \mid \nu (a.P)&lt;/script&gt;

&lt;p&gt;Note that the bound channel &lt;script type=&quot;math/tex&quot;&gt;\alpha&lt;/script&gt;-varies, and&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{P =_\alpha P&#39;}
{P \equiv P&#39;}&lt;/script&gt;

&lt;p&gt;which is sorta similar to &lt;script type=&quot;math/tex&quot;&gt;\m{dcl}(e; a.m)&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;The name of the bound channel is an “unguessable secret.”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LTS&lt;/strong&gt;: &lt;script type=&quot;math/tex&quot;&gt;P \overset{\alpha}{\underset{\Sigma}{\mapsto}} P&#39;&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;\vdash_\Sigma \alpha~\m{action}&lt;/script&gt;.&lt;/p&gt;

&lt;h1 id=&quot;communication-generalizes-syncrhonization&quot;&gt;Communication (generalizes syncrhonization)&lt;/h1&gt;

&lt;p&gt;We want to communicate the values of a type. &lt;script type=&quot;math/tex&quot;&gt;\Sigma : a \sim \tau&lt;/script&gt; means that &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; carries values of type &lt;script type=&quot;math/tex&quot;&gt;\tau&lt;/script&gt;. To do so, we redefine our events:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;E ::= ?a(x.P) \mid !a(e; p)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;E ::= \m{rcv}[a](x.P) \mid \m{snd}[a](e;P)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\Gamma, x: \tau \vdash_{\Sigma, a \sim \tau} P~\m{process}}
{\Gamma \vdash_{\Sigma, a \sim \tau} ?a(x.P)~\m{event}}&lt;/script&gt;

&lt;p&gt;Note that they are no longer symmetric, since receiving binds, while sending does not.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\alpha ::= a!e \mid a?e \mid \varepsilon&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e~\m{val}_{\Sigma, a \sim \tau}}
{\$(!a(e;P) + E) \overset{a!e}{\underset{\Sigma, a \sim \tau}{\mapsto}} P}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\vdash_{\Sigma, a \sim \tau} e : \tau ~~~~ e~\m{val}_{\Sigma, a \sim \tau}}
{\$(?a(x.P) + E) \overset{a?e}{\underset{\Sigma, a \sim \tau}{\mapsto}} [e/x]P}&lt;/script&gt;

&lt;p&gt;We have to change &lt;script type=&quot;math/tex&quot;&gt;\nu(a.P)&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;\nu(a \sim \tau.P)&lt;/script&gt;, or &lt;script type=&quot;math/tex&quot;&gt;\m{new}[\tau](a.P)&lt;/script&gt;.&lt;/p&gt;

&lt;h1 id=&quot;channel-references&quot;&gt;Channel References&lt;/h1&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\tau ::= \cdots \mid \tau~\m{chan}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
e ::= \cdots \mid \&amp;a %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
(\&amp;a)~\m{val}_{\Sigma, a \sim \tau} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\Gamma, \vdash_{\Sigma, a \sim \tau} \&amp;a : \tau~\m{chan} %]]&gt;&lt;/script&gt;

&lt;p&gt;We define new events, called a &lt;em&gt;dynamic&lt;/em&gt; receives and sends:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;E ::= \cdots \mid ??(e; x.P) \mid !!(e_1;e_2;P)&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;e_1&lt;/script&gt; evaluate to channels, and &lt;script type=&quot;math/tex&quot;&gt;e_2&lt;/script&gt; is the message to send.&lt;/p&gt;

&lt;p&gt;Our old receives and sends are &lt;em&gt;static&lt;/em&gt;, because the channels are specified.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\Gamma \vdash_\Sigma e : \tau~\m{chan} ~~~~ \Gamma, x:\tau \vdash_\Sigma P~\m{process}}
{\Gamma \vdash_\Sigma ??(e; x. P)~\m{event}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\Gamma \vdash_\Sigma e_1 : \tau~\m{chan} ~~~~ \Gamma \vdash_\Sigma e_2 : \tau ~~~~ \Gamma, x:\tau \vdash_\Sigma P~\m{process}}
{\Gamma \vdash_\Sigma !!(e_1; e_2; P)~\m{event}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \underset{\Sigma}{\mapsto} e&#39;}
{??(e;P) \overset{\varepsilon}{\underset{\Sigma}{\mapsto}} ??(e&#39;;P)}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\frac
{}
{??(\&amp;a ;P) \overset{\varepsilon}{\underset{\Sigma, a \sim \tau}{\mapsto}} ?a(x.P)} %]]&gt;&lt;/script&gt;

&lt;p&gt;So, the dynamic receive evaluates to the static receive once we get to the channel we have a reference to, and similarly for dynamic sends.&lt;/p&gt;

&lt;p&gt;Consider&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\nu b (\nu a (P \parallel Q) \parallel R)&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;P&lt;/script&gt; could have &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\$(!b(\&amp;a ; P&#39;)) %]]&gt;&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; could have &lt;script type=&quot;math/tex&quot;&gt;\$(?b(x.\$(!!(x;\m{fact}(5);R&#39;))))&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;This leads to issues (&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\overset{b!\&amp;a}{\underset{\Sigma}{\mapsto^*}} %]]&gt;&lt;/script&gt;) [&lt;em&gt;I wasn’t paying attention for a few minutes&lt;/em&gt;] that lead us to need a new principle, called &lt;em&gt;scope extrusion&lt;/em&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\nu b (\nu a (P \parallel Q) \parallel R) \equiv \nu b \nu a (P \parallel Q \parallel R)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P \equiv \nu \Sigma\{ \$(E_1) \otimes \cdots \otimes \$(E_n) \}&lt;/script&gt;

&lt;p&gt;which looks very similar to Modernized Algol (except with &lt;script type=&quot;math/tex&quot;&gt;a_1 \hookrightarrow e_1&lt;/script&gt;). In fact, we could say that &lt;script type=&quot;math/tex&quot;&gt;a \hookrightarrow e&lt;/script&gt; means &lt;script type=&quot;math/tex&quot;&gt;\$(?\m{get}(\_) + ?\m{set}(\_))&lt;/script&gt;. [&lt;em&gt;see PFPL for filled in blanks&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Memory is nothing more than a bunch of processes.&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 14 Apr 2015 13:22:10 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/04/14/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/04/14/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 23: Concurrency &amp; Interaction</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}
\def\a{\alpha}
\def\b{\beta}
\def\t{\tau}
$$
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Delivered by Bob Harper&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We’re going to discuss &lt;strong&gt;abstract process calculus&lt;/strong&gt;, which is derived from &lt;script type=&quot;math/tex&quot;&gt;\pi&lt;/script&gt;-calculus. The key idea is &lt;em&gt;interacting automata&lt;/em&gt;. We will introduce concurrency to Modernized Algol, creating &lt;em&gt;Concurrent Algol&lt;/em&gt;, thus applying process calculus to a “real” programming language.&lt;/p&gt;

&lt;p&gt;What is concurrency? It’s unrelated to parallelism. Instead, it’s really about &lt;em&gt;composition&lt;/em&gt;, and non-determinism (Bob Harper prefers &lt;em&gt;indeterminacy&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Our starting point is consideration of processes as automata. One example is Milner’s vending machine. We have an automata for the vending machine &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt;, and an automata for the person using it &lt;script type=&quot;math/tex&quot;&gt;U&lt;/script&gt;. They interact concurrently (&lt;script type=&quot;math/tex&quot;&gt;V \| U&lt;/script&gt;), since the person loses money as they put it into the machine, and when the machine dispenses a drink, the person gains a drink.&lt;/p&gt;

&lt;h1 id=&quot;process-notation&quot;&gt;Process Notation&lt;/h1&gt;
&lt;p&gt;We have a primitive called &lt;script type=&quot;math/tex&quot;&gt;\m{await}(E)&lt;/script&gt;, for awaiting events. It can also be represented with &lt;script type=&quot;math/tex&quot;&gt;\$E&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;?a.P&lt;/script&gt; represents receiving events. &lt;script type=&quot;math/tex&quot;&gt;P&lt;/script&gt; represents a process. &lt;script type=&quot;math/tex&quot;&gt;!a.P&lt;/script&gt; represents sending events. Note these are symmetric, in the sense that we could switch their meanings. &lt;script type=&quot;math/tex&quot;&gt;E_1 + E_2&lt;/script&gt; represents a binary sum, or a binary choice, between events. &lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt; represents the null choice, or no choice.&lt;/p&gt;

&lt;p&gt;We can represent &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;U&lt;/script&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;V = \$(?2p.\$(!tea.V + ?2p.(\$(!coffee.V))))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;U = \$(!2p . \$(!2p . \$(?coffee.U)))&lt;/script&gt;

&lt;p&gt;Note that these are cursive, so some equation solving is required. We want a fixed point.&lt;/p&gt;

&lt;h1 id=&quot;structural-congruence&quot;&gt;Structural Congruence&lt;/h1&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;P \equiv P&#39;&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;E \equiv E&#39;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Structural congruence&lt;/strong&gt; is an equivalence relation that is compaible with all the constructs of the language. The idea is to treat processes and events modulo structural congruence. &lt;script type=&quot;math/tex&quot;&gt;\alpha&lt;/script&gt;-equivalence is structural equivalence. We want the order of events to not matter.&lt;/p&gt;

&lt;p&gt;We have commutivity: &lt;script type=&quot;math/tex&quot;&gt;E_1 + E_2 \equiv E_2 + E_1&lt;/script&gt;, associativity: &lt;script type=&quot;math/tex&quot;&gt;E_1 + (E_2 + E_3) \equiv (E_1 + E_2) + E_3&lt;/script&gt;, and unit &lt;script type=&quot;math/tex&quot;&gt;E + 0 \equiv E \equiv 0 + E&lt;/script&gt;. Thus, we have a commutative monoid (additivity).&lt;/p&gt;

&lt;h1 id=&quot;composition&quot;&gt;Composition&lt;/h1&gt;
&lt;p&gt;We’re going to think about of our processors as get/set servers for assignables. &lt;script type=&quot;math/tex&quot;&gt;P_1 \parallel P_2&lt;/script&gt; (or “tensor” &lt;script type=&quot;math/tex&quot;&gt;P_1 \otimes P_2&lt;/script&gt;) represents concurrrent composition. 1 represents inert composition. The order of processes doesn’t matter. This is another commutative monoid (multiplicative).&lt;/p&gt;

&lt;p&gt;The main missing thing is distributivity, so we don’t have a ring.&lt;/p&gt;

&lt;h1 id=&quot;normal-form&quot;&gt;Normal Form&lt;/h1&gt;
&lt;p&gt;Every process is sturcturally congruent to one of the form&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\$E_1 \parallel \cdots \parallel \$E_n&lt;/script&gt;

&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;n \geq 0&lt;/script&gt;. That is, it’s a bunch of automata in “a big pot of (matzoh ball) soup.” The multiplicative structure corresponds to “Brownian motion,” letting “the soup boil.”&lt;/p&gt;

&lt;h1 id=&quot;dynamicsinteraction-between-processes&quot;&gt;Dynamics—interaction between processes&lt;/h1&gt;
&lt;p&gt;We have a labelled transition system:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
P \mapsto^{\epsilon} P&#39; &amp; \alpha  ::= a? &amp; \text{receive action} \\
P \mapsto^{\alpha} P&#39; &amp; |  a! &amp; \text{send action} \\
&amp; |  \epsilon &amp; \text{null action}
\end{align} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;V \overset{2p?}{\mapsto} V&#39; \overset{2p?}{\mapsto} V&#39;&#39; \overset{coffee!}{\mapsto} V&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;V&#39; \overset{tea!}{\mapsto} V&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;U \overset{2p!}{\mapsto} U&#39; \overset{2p!}{\mapsto} \ \overset{coffee?}{\mapsto} U&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{P_1 \equiv P_1&#39; \overset{\alpha}{\mapsto} P_2&#39; \equiv P_2}
{P_1 \overset{\alpha}{\mapsto} P_2}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\$(a.P + E) \overset{a?}{\mapsto} P&lt;/script&gt;

&lt;p&gt;Note that &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; is lost. A non-deterministic choice is made.&lt;/p&gt;

&lt;p&gt;The framing principle is that a process takes the same action regardless of “who’s watching.” Thus, if you have several processors, you can have two of them interact in parallel without affecting the others.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    P_1
    \overset{\alpha}{\mapsto}
    P_1&#39;
}{
    P_1 \parallel P_2 \overset{\alpha}{\mapsto} P_1&#39; \parallel P_2
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    P_1 \overset{\alpha}{\mapsto} P_1&#39; ~~~~
    P_2 \overset{\overline{\alpha}}{\mapsto} P_2&#39;
}{
    P_1 \parallel P_2 \mapsto P_1&#39; \parallel P_2&#39;
}&lt;/script&gt;

&lt;p&gt;This rule allows for interaction. Thus, the user can get a coffee at the same time the vending machine sends a coffee.&lt;/p&gt;

&lt;h1 id=&quot;replication&quot;&gt;Replication&lt;/h1&gt;
&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;*P \equiv *P \parallel P&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;*P&lt;/script&gt; is any number of copies of &lt;script type=&quot;math/tex&quot;&gt;P&lt;/script&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;accept recursive definitions as given&lt;/li&gt;
  &lt;li&gt;reduce to replication &amp;amp; synchronization&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The activator waits for the assert to arrive, and activates &lt;script type=&quot;math/tex&quot;&gt;P&lt;/script&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A = *\$(?a.P(\$(!a.1))) \equiv A&#39; \parallel A&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A&#39; = \$(?a.P(\$(!a.1)))&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\$(!a.1)&lt;/script&gt; is the “spark” to activate the next &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;.&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Apr 2015 13:30:34 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/04/09/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/04/09/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 22: Exceptions, Continuations</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}
\def\a{\alpha}
\def\b{\beta}
\def\t{\tau}
\def\emp{\cdotp}

\def\natt{\m{nat}}
\def\unit{\m{unit}}
\def\exn{\m{exn}}
\def\prove{\vdash}
\def\typet{\m{type}}

\def\fail{\m{fail}}
\renewcommand\catch[2]{\m{catch}~#1~\m{ow}~#2}

\renewcommand\raiset[2]{\m{raise}_{#1}~#2}
\renewcommand\raise[1]{\m{raise}~#1}
\renewcommand\handle[3]{\m{handle}~#1~\m{ow}~#2.#3}

\def\defeq{\overset{def}{=}}

\renewcommand\ifz[4]{\m{ifz}(#1 ; #2 ; #3 . #4)}

\renewcommand\clsfdt{\m{clsfd}}
\renewcommand\classt[1]{\m{class}(#1)}
\renewcommand\newcls[1]{\m{newcls}[#1]}
\renewcommand\mk[2]{\m{mk}(#1;#2)}
\renewcommand\isofcls[5]{\m{isofcls}(#1;#2;#3.#4;#5)}
$$
&lt;/div&gt;

&lt;h1 id=&quot;control-operators-continued&quot;&gt;Control Operators (continued)&lt;/h1&gt;

&lt;h2 id=&quot;exceptions-continued&quot;&gt;Exceptions (continued)&lt;/h2&gt;

&lt;p&gt;We introduced classified terms, which are exceptions in ML.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\t &amp; ::= \cdots \mid \clsfdt \mid \classt{\t} \\
e &amp; ::= \cdots \mid \newcls{\t} \mid \mk{e}{e} \mid \isofcls{e}{e}{x}{e}{e}
\end{align} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
\ctx \prove e : \classt{\t} \qquad \ctx \prove e&#39;:\t
}{
\ctx \prove \mk{e}{e&#39;} : \clsfdt
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
\ctx \prove e_0 : \classt{\t} \qquad \ctx \prove e_1 : \clsfdt \qquad \ctx, x : \t \prove e_2 : \t&#39; \qquad \ctx \prove e_3 : \t&#39;
}{
\ctx \prove \isofcls{e_0}{e_1}{x}{e_2}{e_3} : \t&#39;
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
\ctx \prove \t : \typet
}{
\newcls{\t} : \classt{\t}
}&lt;/script&gt;

&lt;p&gt;This system is more powerful than ML’s exceptions. Here’s a way to implement it in ML (or any language with first-class functions and references), though it would probably be more efficient as a primitive.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;n&quot;&gt;signature&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CLSFD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sig&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clsfd&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clsfd&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;isofcls&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clsfd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;structure&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Clsfd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CLSFD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clsfd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unit&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;option&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NONE&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;option&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SOME&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isofcls&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;option&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NONE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NONE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SOME&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Thus, we can see &lt;script type=&quot;math/tex&quot;&gt;\clsfdt&lt;/script&gt; as an abstract data type, with multiple possible implementations. One thing that must be true across all implementations is that classes must be dynamically generated.&lt;/p&gt;

&lt;h3 id=&quot;static-exceptions&quot;&gt;Static Exceptions&lt;/h3&gt;
&lt;p&gt;Crary claims static exceptions (such as those in Java) don’t work. In our terminology, static exceptions are those that have classes that can be determined statically. In theory, this lets us reason about exceptions that a piece of code may raise.&lt;/p&gt;

&lt;p&gt;However, if you have type abstraction, this doesn’t work. If &lt;code&gt;new&lt;/code&gt; returns a static class, then if you have two classes with different &lt;code&gt;&#39;a&lt;/code&gt;s, they would still have the same classes, which breaks type safety. &lt;em&gt;[My understanding of Crary’s explanation is questionable.]&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;continuations&quot;&gt;Continuations&lt;/h2&gt;

&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand\contt[1]{#1~\m{cont}}
\renewcommand\letcc[3]{\m{letcc}_{#1}~#2~\m{in}~#3}
\renewcommand\throw[3]{\m{throw}_{#1}~#2~\m{to}~#3}
\renewcommand\cont[1]{\m{cont}(#1)}
$$
&lt;/div&gt;

&lt;p&gt;We’re going to talk about first-class continuations. They give you the ability to capture the “sequel” of the evaluation of the program.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\t &amp; ::= \cdots \mid \contt{\t} \\
e &amp; ::= \cdots \mid \letcc{\t}{x}{e} \mid \throw{\t}{e}{e} \mid \cont{k}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\contt{\t}&lt;/script&gt; can be thought of as a function that does something, but never returns anything we care about.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
\ctx, x : \contt{\t} \prove e: \t
}{
\ctx \prove \letcc{\t}{x}{e} : \t
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
\ctx \prove e : \t \qquad \ctx \prove e&#39; : \contt{\t}
}{
\ctx \prove \throw{\t&#39;}{e}{e&#39;} : \t&#39;
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[

k &gt; \letcc{\t}{x}{e} \mapsto k &gt; [\cont{k} / x] c \\
k &gt; \throw{\t}{e_1}{e_2} \mapsto k; \throw{\t}{\square}{e_2} &gt; e_1 \\
k; \throw{\t}{\square}{e_2} &lt; v \mapsto k; \throw{\t}{v}{\square} &gt; e_2 \\
k; \throw{\t}{v}{\square} &lt; \cont{k&#39;} \mapsto k&#39; &lt; v \\
 %]]&gt;&lt;/script&gt;

&lt;p&gt;Continuations let us have non-local exits. SML/NJ (but not Standard ML) has &lt;code&gt;callcc: (&#39;a cont -&amp;gt; &#39;a) -&amp;gt; &#39;a&lt;/code&gt; and &lt;code&gt;throw: &#39;a * &#39;a cont -&amp;gt; &#39;b&lt;/code&gt;. C has &lt;code&gt;setjmp&lt;/code&gt; and &lt;code&gt;longjmp&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Consider a function that computes the product of a list of &lt;code&gt;nat&lt;/code&gt;s. We might want to exit early if any of them are 0, since there’s no point in computing the product any further.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;λl : nat list .
    letcc exit in
        (fix product : nat list -&amp;gt; nat =
            λl . case l of
                nil =&amp;gt; 1
            | 0 :: _ =&amp;gt; throw 0 to exit
            | n :: t =&amp;gt; n * product t)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can use continuations for “time travel,” without the “paradoxes” that might result if had state.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;n&quot;&gt;datatype&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Large&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Small&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;guessSize&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;letcc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Small&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;Large&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;disp&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Small&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Large&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&amp;#39;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;largedisp&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;&lt;code&gt;compose (f : τ&#39; -&amp;gt; τ) (k: τ cont) : τ&#39; cont =
    letcc k&#39;&#39; in throw f (letcc k&#39; in throw k&#39; to k&#39;&#39;) to k
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &lt;code&gt;k&#39;&#39;: τ&#39; cont cont&lt;/code&gt;. We can use &lt;code&gt;compose&lt;/code&gt; to implement coroutines in user space.&lt;/p&gt;

&lt;h2 id=&quot;comparing-exceptions-and-continuations&quot;&gt;Comparing Exceptions and Continuations&lt;/h2&gt;

&lt;p&gt;Neither continuations nor exceptions are more powerful than the other. The two features are incomparable. You &lt;em&gt;can&lt;/em&gt; implement exceptions with continuations and references.&lt;/p&gt;

&lt;p&gt;Exceptions actually expand the computing power of a language, because you can implement a loop, which you can’t do with just continuations. In that sense, exceptions are “more powerful.”&lt;/p&gt;

&lt;p&gt;On the other hand, with continuations, we expand the logical scope from constructive logic to classical logic. You can prove anything with loops, but that isn’t &lt;em&gt;that&lt;/em&gt; useful from a logical perspective.&lt;/p&gt;
</description>
        <pubDate>Tue, 07 Apr 2015 13:29:45 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/04/07/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/04/07/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 21: Stack Machines, Unraveling, Exceptions</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}
\def\a{\alpha}
\def\b{\beta}
\def\t{\tau}
\def\emp{\cdotp}

\def\natt{\m{nat}}
\def\unit{\m{unit}}
\def\exn{\m{exn}}

\def\fail{\m{fail}}
\renewcommand\catch[2]{\m{catch}~#1~\m{ow}~#2}

\renewcommand\raiset[2]{\m{raise}_{#1}~#2}
\renewcommand\raise[1]{\m{raise}~#1}
\renewcommand\handle[3]{\m{handle}~#1~\m{ow}~#2.#3}

\def\defeq{\overset{def}{=}}

\renewcommand\ifz[4]{\m{ifz}(#1 ; #2 ; #3 . #4)}
$$
&lt;/div&gt;

&lt;h1 id=&quot;control-operators-continued&quot;&gt;Control Operators (continued)&lt;/h1&gt;

&lt;h2 id=&quot;stack-machines-continued&quot;&gt;Stack machines (continued)&lt;/h2&gt;

&lt;p&gt;Refactoring the syntax a bit:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
k &amp; ::= \emp \mid k;~f \\
f &amp; ::= s~\square \mid \ifz{\square}{e_0}{x}{e_1} \mid \cdots \\
S &amp; ::= k &gt; e \mid k &lt; e
\end{align} %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;soundness--completeness-continued&quot;&gt;Soundness &amp;amp; Completeness (continued)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Lemma.&lt;/strong&gt; If &lt;script type=&quot;math/tex&quot;&gt;e \Downarrow v&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\forall k. k &gt; e \mapsto^* k &lt; v %]]&gt;&lt;/script&gt;.&lt;/p&gt;

&lt;h2 id=&quot;unraveling-reraveling&quot;&gt;Unraveling (Reraveling)&lt;/h2&gt;

&lt;p&gt;For any state &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;s^*&lt;/script&gt; is a term.&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;(k &gt; e)^* \defeq k[e]&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
(k &lt; e)^* \defeq k[e] %]]&gt;&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\emp[e] \defeq e&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;(k; s \square)[e] \defeq k[s(e)]&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;(k; \ifz{\square}{e_0}{x}{e_1})[e] = k[\ifz{e}{e_0}{x}{e_1}]&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;(k; \square e_2)[e] = k[e~e_2]&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;(k; v_1 \square)[e] = k[v_1~e]&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lemma.&lt;/strong&gt; If &lt;script type=&quot;math/tex&quot;&gt;s \mapsto s&#39;&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;s^* \mapsto^* s&#39;^*&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Proof.&lt;/strong&gt; By case analysis on &lt;script type=&quot;math/tex&quot;&gt;s \mapsto s&#39;&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lemma.&lt;/strong&gt; If &lt;script type=&quot;math/tex&quot;&gt;e \mapsto e&#39;&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;\forall k . k[e] \mapsto k[e&#39;]&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Proof.&lt;/strong&gt; By induction on &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Consider the case &lt;script type=&quot;math/tex&quot;&gt;k = k&#39;; v \square&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;We want to show &lt;script type=&quot;math/tex&quot;&gt;(k; v \square)[e] \mapsto (k&#39;; v \square)[e&#39;]&lt;/script&gt;. Thus, we want to show &lt;script type=&quot;math/tex&quot;&gt;k&#39;[v~e] \mapsto k&#39;[v~e&#39;]&lt;/script&gt;, and so, we want &lt;script type=&quot;math/tex&quot;&gt;v~e \mapsto v~e&#39;&lt;/script&gt;. But, do we actually know that &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; is a value? It turns out this is true, but we need to codify this in an invariant.&lt;/p&gt;

&lt;p&gt;We rephrase the lemma: “if &lt;script type=&quot;math/tex&quot;&gt;e \mapsto e&#39;&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;\forall k&lt;/script&gt;, if &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; is good, &lt;script type=&quot;math/tex&quot;&gt;k[e] \mapsto k[e&#39;]&lt;/script&gt;”. Note that since the book does call-by-name, we don’t have to worry about this case, since &lt;script type=&quot;math/tex&quot;&gt;v\square&lt;/script&gt; never happens.&lt;/p&gt;

&lt;h2 id=&quot;exceptions&quot;&gt;Exceptions&lt;/h2&gt;

&lt;h3 id=&quot;failcatch&quot;&gt;Fail/Catch&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e ::= \cdots \mid \fail \mid \catch{e}{e}&lt;/script&gt;

&lt;p&gt;We can interpret the &lt;script type=&quot;math/tex&quot;&gt;\m{catch}&lt;/script&gt; expression as evaluating the first expression, and if reach &lt;script type=&quot;math/tex&quot;&gt;\fail&lt;/script&gt;, we evaluate the second expression.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;k ::= \cdots \mid k; f \mid k; \catch{\square}{e}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;k &gt; \fail \mapsto k \ll&lt;/script&gt;

&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;\ll&lt;/script&gt; represents unwinding the stack (to find a handler for &lt;script type=&quot;math/tex&quot;&gt;\fail&lt;/script&gt;)&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;k &gt; \catch{e_1}{e_2} \mapsto k; \catch{\square}{e_2} &gt; e_1&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k; \catch{\square}{e} &lt; v \mapsto k &lt; v %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;k; \catch{\square}{e} \ll~\mapsto k &gt; e&lt;/script&gt;

&lt;p&gt;If there’s nothing to pop off the stack, then we’ll reach an error.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;k;f \ll~\mapsto k \ll&lt;/script&gt;

&lt;h3 id=&quot;raisehandle&quot;&gt;Raise/Handle&lt;/h3&gt;

&lt;p&gt;We want our exceptions to be able to carry data as well:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e ::= \cdots \mid \raiset{\t}{e} \mid \handle{e}{x}{e}&lt;/script&gt;

&lt;p&gt;We need to choose &lt;script type=&quot;math/tex&quot;&gt;\t&lt;/script&gt; to be a specific type (as part of the language definition), &lt;script type=&quot;math/tex&quot;&gt;\tau_{exn}&lt;/script&gt;, for typechecking to work. If this is just &lt;script type=&quot;math/tex&quot;&gt;\m{unit}&lt;/script&gt;, then this is basically the same as &lt;script type=&quot;math/tex&quot;&gt;\fail&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;k &gt; \raise{e} \mapsto k; \raise{\square} &gt; e&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
k; \raise{\square} &lt; v \mapsto k \ll v %]]&gt;&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;k &gt; \handle{e_1}{x}{e_2} \mapsto k; \handle{\square}{x}{e_2} &gt; e_1&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
k; \handle{\square}{x}{e_2} &lt; v \mapsto k &lt; v %]]&gt;&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;k; \handle{\square}{x}{e_2} \ll v \mapsto k &gt; [v/x]e_2&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;k;f \ll v \mapsto k \ll v&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;For proof of type safety, look in &lt;em&gt;PFPL&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Now, let’s consider what &lt;script type=&quot;math/tex&quot;&gt;\tau_{exn}&lt;/script&gt; should be.&lt;/p&gt;

&lt;p&gt;Strings are possible (older versions of ML did this), but require serialization and deserialization, which isn’t great.&lt;/p&gt;

&lt;p&gt;Ints are used in C, but you’re limited to a fixed mapping of integers to exceptions. You &lt;em&gt;could&lt;/em&gt; use Gödel numberings, but no one actually wants that.&lt;/p&gt;

&lt;p&gt;We could do &lt;script type=&quot;math/tex&quot;&gt;\unit + \unit + \unit + \m{string} + \unit + \cdots \unit&lt;/script&gt;, where we map each layer of the sum to a different exception. This can be pattern matched on, but is pretty silly.&lt;/p&gt;

&lt;p&gt;Instead, (and modern ML does this) we use the extensible type &lt;script type=&quot;math/tex&quot;&gt;\exn&lt;/script&gt;. According to Crary’s revisionist history, &lt;script type=&quot;math/tex&quot;&gt;\exn&lt;/script&gt; stands for “extensible,” &lt;strong&gt;not&lt;/strong&gt; exception. We can add to this type with the syntax &lt;script type=&quot;math/tex&quot;&gt;\m{extension}~\m{Foo}&lt;/script&gt;.&lt;/p&gt;
</description>
        <pubDate>Thu, 02 Apr 2015 13:26:59 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/04/02/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/04/02/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 20: Futures, Control Operators</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}
\def\a{\alpha}
\def\b{\beta}
\def\t{\tau}

\def\natt{\m{nat}}
\def\boolt{\m{bool}}
\def\unitt{\m{unit}}
\def\voidt{\m{void}}

\def\unit{\langle \rangle}

\def\tt{\m{true}}
\def\ff{\m{false}}

\def\prove{\vdash}

\renewcommand\fun[3]{\lambda #1 : #2 . #3}
\renewcommand\Fun[2]{\Lambda #1 . #2}

\renewcommand\let[3]{\m{let}~#1 = #2~\m{in}~#3}

\def\typet{\m{type}}
\renewcommand\type[1]{#1 : \typet}

\renewcommand\allt[2]{\forall #1.#2}
\renewcommand\prodt[2]{#1 \times #2}
\renewcommand\pair[2]{\langle #1, #2 \rangle}
\renewcommand\App[2]{#1[#2]}
\renewcommand\subst[3]{[#1 / #2] #3}

\renewcommand\existst[2]{\exists #1.#2}
\renewcommand\pack[4]{\m{pack}~[#1,#2]~\m{as}~\exists #3.#4}
\renewcommand\open[4]{\m{open}~[#1,#2] = #3~\m{in}~#4}

\def\defeq{\overset{def}{=}}

\renewcommand\par[5]{\m{par}~#1=#2 \m{ and } #3=#4 \m{ in } #5}
\renewcommand\val[1]{#1~\m{val}}
\def\mapstos{\mapsto_{\m{seq}}}
\def\mapstop{\mapsto_{\m{par}}}

\renewcommand\futt[1]{#1~\m{fut}}
\renewcommand\fute[1]{\m{fut}(#1)}
\renewcommand\fsyn[1]{\m{fsyn}(#1)}
$$
&lt;/div&gt;

&lt;h1 id=&quot;parallelism-continued&quot;&gt;Parallelism (continued)&lt;/h1&gt;

&lt;h2 id=&quot;implicit-parallelism-theorem&quot;&gt;Implicit Parallelism Theorem&lt;/h2&gt;
&lt;p&gt;For all values &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;e \mapstos^* v \iff e \mapstop^* v&lt;/script&gt;.&lt;/p&gt;

&lt;h2 id=&quot;futures&quot;&gt;Futures&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\t &amp; ::= \cdots \mid \futt{\t} \\
e &amp; ::= \cdots \mid \fute{e} \mid \fsyn{e}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\fsyn{e}&lt;/script&gt; is used to synchronize a future and thereby get its actual value.&lt;/p&gt;

&lt;p&gt;We can define nested parallelism with futures:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\par{x_1}{e_1}{x_2}{e_2} \defeq \let{x_1&#39;}{\fute{e_1}}{
    \let{x_2}{e_2}{
        \let{x_1}{\fsyn{x_1&#39;}}{e}
    }
}&lt;/script&gt;

&lt;h3 id=&quot;statics&quot;&gt;Statics&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \prove e : \t}
{\ctx \prove \fute{e} : \futt{\t}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \prove e : \futt{\t}}
{\ctx \prove \fsyn{e} : \t}&lt;/script&gt;

&lt;h3 id=&quot;sequential-dynamics&quot;&gt;Sequential Dynamics&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\val{e}}
{\val{\fute{e}}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \mapstos e&#39;}
{\fute{e} \mapstos \fute{e&#39;}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \mapstos e&#39;}
{\fsyn{e} \mapstos \fsyn{e&#39;}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\val{e}}
{\fsyn{\fute{e}} \mapstos e}&lt;/script&gt;

&lt;h3 id=&quot;pipelining&quot;&gt;Pipelining&lt;/h3&gt;

&lt;p&gt;Consider a situation where a &lt;em&gt;producer&lt;/em&gt; builds a list where elements represent units of works. This can easily be programming with a future list.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[See p.395 of PFPL]&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;speculations&quot;&gt;Speculations&lt;/h3&gt;

&lt;p&gt;Speculations are the by-name version of futures.&lt;/p&gt;

&lt;h3 id=&quot;cost-dynamics--brents-theorem&quot;&gt;Cost Dynamics / Brent’s Theorem&lt;/h3&gt;

&lt;p&gt;Work/span analysis.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[Will be covered in recitation]&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;control-operators&quot;&gt;Control Operators&lt;/h1&gt;
&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}
\def\a{\alpha}
\def\b{\beta}
\def\t{\tau}

\def\natt{\m{nat}}

\renewcommand\ifz[4]{\m{ifz}(#1 ; #2 ; #3 . #4)}
$$
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Exceptions&lt;/li&gt;
  &lt;li&gt;Continuations&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;stack-machines&quot;&gt;Stack machines&lt;/h2&gt;
&lt;p&gt;We want to store &lt;em&gt;where we are in an expression&lt;/em&gt;. Note that we’re doing call-by-value, and the book does call-by-name.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
k &amp; ::= \cdotp \mid k;s~\square \mid k;\ifz{\square}{e_0}{x}{e_1} \mid \cdots \\
S &amp; ::= k &gt; e \mid k &lt; e
\end{align} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k &gt; z \mapsto k &lt; z %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;k &gt; s(e) \mapsto k; s~\square &gt; e&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k; s~\square &lt; v \mapsto k &lt; s(v) %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;k &gt; \ifz{e}{e_0}{x}{e_1} \mapsto k; \ifz{\square}{e_0}{x}{e_1}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k; \ifz{\square}{e_0}{x}{e_1} &lt; z \mapsto k &gt; e_0 %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k; \ifz{\square}{e_0}{x}{e_1} &lt; s(v) \mapsto k &gt; [v / x] e_1 %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;soundness--completeness&quot;&gt;Soundness &amp;amp; Completeness&lt;/h3&gt;

&lt;h4 id=&quot;soundness&quot;&gt;Soundness&lt;/h4&gt;
&lt;p&gt;If &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\cdotp &gt; e \mapsto^* \cdotp &lt; v %]]&gt;&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;e \mapsto^*&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\val{v}&lt;/script&gt;.&lt;/p&gt;

&lt;h4 id=&quot;completeness&quot;&gt;Completeness&lt;/h4&gt;
&lt;p&gt;If &lt;script type=&quot;math/tex&quot;&gt;e \mapsto^* v&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\val{v}&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\cdotp &gt; e \mapsto^* \cdotp &lt; v %]]&gt;&lt;/script&gt;.&lt;/p&gt;
</description>
        <pubDate>Tue, 31 Mar 2015 13:33:22 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/03/31/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/03/31/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 19: Representation Independence, Parallelism</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}
\def\a{\alpha}
\def\b{\beta}
\def\t{\tau}

\def\natt{\m{nat}}
\def\boolt{\m{bool}}
\def\unitt{\m{unit}}
\def\voidt{\m{void}}

\def\unit{\langle \rangle}

\def\tt{\m{true}}
\def\ff{\m{false}}

\def\prove{\vdash}

\renewcommand\fun[3]{\lambda #1 : #2 . #3}
\renewcommand\Fun[2]{\Lambda #1 . #2}

\def\typet{\m{type}}
\renewcommand\type[1]{#1 : \typet}

\renewcommand\allt[2]{\forall #1.#2}
\renewcommand\prodt[2]{#1 \times #2}
\renewcommand\pair[2]{\langle #1, #2 \rangle}
\renewcommand\App[2]{#1[#2]}
\renewcommand\subst[3]{[#1 / #2] #3}

\renewcommand\existst[2]{\exists #1.#2}
\renewcommand\pack[4]{\m{pack}~[#1,#2]~\m{as}~\exists #3.#4}
\renewcommand\open[4]{\m{open}~[#1,#2] = #3~\m{in}~#4}

\def\defeq{\overset{def}{=}}

\renewcommand\par[5]{\m{par}~#1=#2 \m{ and } #3=#4 \m{ in } #5}
\renewcommand\val[1]{#1~\m{val}}
\def\mapstos{\mapsto_{\m{seq}}}
\def\mapstop{\mapsto_{\m{par}}}
$$
&lt;/div&gt;

&lt;h1 id=&quot;representation-independence--abstraction-theoremhttpwwwandrewcmueducourse15-312notesmar-20pdf-continued&quot;&gt;&lt;a href=&quot;http://www.andrew.cmu.edu/course/15-312/notes/mar-20.pdf&quot;&gt;Representation Independence / Abstraction Theorem&lt;/a&gt; (continued)&lt;/h1&gt;

&lt;h2 id=&quot;equivalence-continued&quot;&gt;Equivalence (continued)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Lemma&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;If &lt;script type=&quot;math/tex&quot;&gt;M,M&#39; : \exists{\a}{\t}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;M = \pack{\sigma}{e}{\a}{\t}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;M&#39; = \pack{\sigma&#39;}{e&#39;}{\a}{\t}&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;R : \sigma \to \sigma&#39;&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; is closed under equivalence and &lt;script type=&quot;math/tex&quot;&gt;e \sim e&#39; : \subst{R}{\a}{\t}&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;M \sim M&#39; : \existst{\a}{\t}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Proof&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;Suppose &lt;script type=&quot;math/tex&quot;&gt;M,M&#39; : \exists{\a}{\t}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;M = \pack{\sigma}{e}{\a}{\t}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;M&#39; = \pack{\sigma&#39;}{e&#39;}{\a}{\t}&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;R : \sigma \to \sigma&#39;&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; is closed under equivalence and &lt;script type=&quot;math/tex&quot;&gt;e \sim e&#39; : \subst{R}{\a}{\t}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;We want to show that &lt;script type=&quot;math/tex&quot;&gt;M \sim M&#39; : \allt{\beta}{(\allt{\a}{\t \to \b}) \to \b}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Suppose &lt;script type=&quot;math/tex&quot;&gt;\rho, \rho&#39; : \typet&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;Q : \rho \leftrightarrow \rho&#39;&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;Q&lt;/script&gt; is closed under equivalence.&lt;/p&gt;

&lt;p&gt;We want to show &lt;script type=&quot;math/tex&quot;&gt;\App{M}{\rho} \sim \App{M&#39;}{\rho&#39;} : (\allt{\a}{\t \to Q}) \to Q&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Suppose &lt;script type=&quot;math/tex&quot;&gt;f \sim f&#39; : \allt{\a}{\t \to Q}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;We want to show &lt;script type=&quot;math/tex&quot;&gt;\App{M}{\rho}f \sim \App{M&#39;}{\rho&#39;}f&#39; : Q&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;We want to show that &lt;script type=&quot;math/tex&quot;&gt;\App{M}{\rho}f~~Q~~\App{M&#39;}{\rho&#39;}f&#39;&lt;/script&gt;.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\App{(\Fun{\b}{\lambda g . \App{g}{\sigma}e})}{\rho}f \mapsto^* \App{f}{\sigma}e&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\App{(\Fun{\b}{\lambda g . \App{g}{\sigma&#39;}e&#39;})}{\rho&#39;}f&#39; \mapsto^* \App{f&#39;}{\sigma&#39;}e&#39;&lt;/script&gt;

&lt;p&gt;We want to show that &lt;script type=&quot;math/tex&quot;&gt;\App{f}{\sigma}e~~Q~~\App{f&#39;}{\sigma&#39;}e&#39;&lt;/script&gt;.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\App{f}{\sigma} \sim \App{f&#39;}{\sigma&#39;} : \subst{R}{\a}{(\t \to Q)}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\therefore \App{f}{\sigma} \sim \App{f&#39;}{\sigma&#39;} : Q&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\therefore \App{f}{\sigma}e~~Q~~\App{f&#39;}{\sigma&#39;}e&#39;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\blacksquare&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Theorem&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;If &lt;script type=&quot;math/tex&quot;&gt;e : \allt{\a}{\a \to \a}&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;e \cong \Fun{\a}{\fun{x}{\a}{x}} : \allt{\a}{\a \to \a}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;This theorem states that we can still have &lt;script type=&quot;math/tex&quot;&gt;\unitt&lt;/script&gt;.&lt;/p&gt;

&lt;h1 id=&quot;parallelism&quot;&gt;Parallelism&lt;/h1&gt;

&lt;p&gt;Thus far, we’ve been focusing on &lt;em&gt;small-step evaluation&lt;/em&gt;, &lt;script type=&quot;math/tex&quot;&gt;e \mapsto e&#39;&lt;/script&gt;, where each step is a small, atomic operation. We’ve also encountered &lt;em&gt;large-step evaluation&lt;/em&gt;, &lt;script type=&quot;math/tex&quot;&gt;e \Downarrow v&lt;/script&gt;, where &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt; evaluates to the value &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; after a number of small steps: &lt;script type=&quot;math/tex&quot;&gt;e \mapsto^* v \wedge v~\m{val} \iff e \Downarrow v&lt;/script&gt;.&lt;/p&gt;

&lt;h2 id=&quot;nested-parallelism&quot;&gt;Nested Parallelism&lt;/h2&gt;

&lt;p&gt;This terminology is still non-standard, but Crary believes it should and will be.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Parallelism &lt;script type=&quot;math/tex&quot;&gt;\neq&lt;/script&gt; concurrency.&lt;/strong&gt; Parallelism is deterministic–we want to run a computation on multiple processors to improve efficiency, but there is one, deterministic result that is the result of the computation. Concurrency is nondeterministic.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Nested parallelism&lt;/em&gt; is also known as &lt;em&gt;fork-join parallelism&lt;/em&gt;.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e ::= \cdots \mid \par{x_1}{e_1}{x_2}{e_2}{e}&lt;/script&gt;

&lt;h3 id=&quot;statics&quot;&gt;Statics&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \prove e_1 : \t_1 \qquad \ctx \prove e_2 : \t_2 \qquad \ctx, x_1 : \t_1, x_2 : \t_2 \prove e : \t}
{\ctx \prove \par{x_1}{e_1}{x_2}{e_2}{e} : \tau}&lt;/script&gt;

&lt;h3 id=&quot;dynamics&quot;&gt;Dynamics&lt;/h3&gt;

&lt;p&gt;Let’s pretend our construct isn’t parallel, and just evaluate the two expressions sequentially.&lt;/p&gt;

&lt;h4 id=&quot;sequential&quot;&gt;Sequential&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e_1 \mapsto e_1&#39;}
{\par{x_1}{e_1}{x_2}{e_2}{e} \mapsto \par{x_1}{e_1&#39;}{x_2}{e_2}{e}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\val{e_1} \qquad e_2 \mapsto e_2&#39;}
{\par{x_1}{e_1}{x_2}{e_2}{e} \mapsto \par{x_1}{e_1}{x_2}{e_2&#39;}{e}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\val{e_1} \qquad \val{e_2}}
{\par{x_1}{e_1}{x_2}{e_2}{e} \mapsto \subst{e_1~e_2}{x_1~x_2}{e}}&lt;/script&gt;

&lt;p&gt;If we can show the actual implementation works like this, we can reason about our parallel code the same way we’ve reasoned about sequential code, which greatly simplifies analysis.&lt;/p&gt;

&lt;p&gt;We will make the distinction between &lt;script type=&quot;math/tex&quot;&gt;\mapstos&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\mapstop&lt;/script&gt;.&lt;/p&gt;

&lt;h4 id=&quot;parallel&quot;&gt;Parallel&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e_1 \mapstop e_1&#39; \qquad e_2 \mapstop e_2&#39;}
{\par{x_1}{e_1}{x_2}{e_2}{e} \mapstop \par{x_1}{e_1&#39;}{x_2}{e_2&#39;}{e}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\val{e_1} \qquad e_2 \mapstop e_2&#39;}
{\par{x_1}{e_1}{x_2}{e_2}{e} \mapstop \par{x_1}{e_1}{x_2}{e_2&#39;}{e}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e_1 \mapstop e_1&#39; \qquad \val{e_2}}
{\par{x_1}{e_1}{x_2}{e_2}{e} \mapstop \par{x_1}{e_1&#39;}{x_2}{e_2}{e}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\val{e_1} \qquad \val{e_2}}
{\par{x_1}{e_1}{x_2}{e_2}{e} \mapstop \subst{e_1~e_2}{x_1~x_2}{e}}&lt;/script&gt;
</description>
        <pubDate>Thu, 26 Mar 2015 13:25:50 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/03/26/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/03/26/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 18: Existential Types, Representation Independence</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}
\def\a{\alpha}
\def\b{\beta}
\def\t{\tau}

\def\natt{\m{nat}}
\def\boolt{\m{bool}}
\def\unitt{\m{unit}}
\def\voidt{\m{void}}

\def\unit{\langle \rangle}

\def\tt{\m{true}}
\def\ff{\m{false}}

\def\prove{\vdash}

\renewcommand\fun[3]{\lambda #1 : #2 . #3}
\renewcommand\Fun[2]{\Lambda #1 . #2}

\def\typet{\m{type}}
\renewcommand\type[1]{#1 : \typet}

\renewcommand\allt[2]{\forall #1.#2}
\renewcommand\prodt[2]{#1 \times #2}
\renewcommand\pair[2]{\langle #1, #2 \rangle}
\renewcommand\App[2]{#1[#2]}
\renewcommand\subst[3]{[#1 / #2] #3}

\renewcommand\existst[2]{\exists #1.#2}
\renewcommand\pack[4]{\m{pack}~[#1,#2]~\m{as}~\exists #3.#4}
\renewcommand\open[4]{\m{open}~[#1,#2] = #3~\m{in}~#4}

\def\defeq{\overset{def}{=}}
$$
&lt;/div&gt;

&lt;h1 id=&quot;polymorphism-continued&quot;&gt;Polymorphism (continued)&lt;/h1&gt;

&lt;h2 id=&quot;data-asbstraction--existential-types&quot;&gt;Data asbstraction / existential types&lt;/h2&gt;

&lt;p&gt;An existential type is of the form&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\existst{\a}{\t}&lt;/script&gt;

&lt;p&gt;This forces us to be parametric on &lt;script type=&quot;math/tex&quot;&gt;\a&lt;/script&gt;. We introduce&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\pack{\t}{e}{\a}{\t&#39;}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\open{\a}{x}{e}{e&#39;}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx\prove \type{\t} \qquad \ctx\prove e : \subst{\t}{\a}{\t&#39;} \qquad \ctx,\type{\a} \prove \type{\t&#39;}}
{\ctx \prove \pack{\t}{e}{\a}{\t&#39;} : \existst{\a}{\t&#39;}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \prove e_1 : \existst{\a}{\t} \qquad \ctx, \type{\a}, x : \t \prove e_2 : \t&#39; \qquad \ctx \prove \type{\t&#39;}}
{\ctx \prove \open{\a}{x}{e_1}{e_2} : \t&#39;}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;{\tt
sig \\
  type~\tau \\
  val~init : \tau \\
  val~flip : t \to \tau \\
  val~out : t \to \m{bool} \\
end
}&lt;/script&gt;

&lt;p&gt;We actually don’t need explicit existential types, because we can implement them in terms of universal types.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\existst{\a}{\t} &amp; \defeq \allt{\b}{(\allt{\a}{\t \to \b}) \to \b} \\
\pack{\t}{e}{\a}{\t&#39;} &amp; \defeq \Fun{\b}{\fun{f}{(\allt{\a}{\t&#39; \to \b})}{f~\t~e}} \\
\open{\a}{x}{e_1}{e_2} &amp; \defeq \App{e_1}{\t&#39;}(\Fun{\a}{\fun{x}{\tau}{e_2}})
\end{align} %]]&gt;&lt;/script&gt;

&lt;h1 id=&quot;representation-independence--abstraction-theoremhttpwwwandrewcmueducourse15-312notesmar-20pdf&quot;&gt;&lt;a href=&quot;http://www.andrew.cmu.edu/course/15-312/notes/mar-20.pdf&quot;&gt;Representation Independence / Abstraction Theorem&lt;/a&gt;&lt;/h1&gt;

&lt;h2 id=&quot;equivalence&quot;&gt;Equivalence&lt;/h2&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\alpha&lt;/script&gt;-equivalence is when two terms are exactly the same, except for variable names. This is the strictest form of equivalence.&lt;/p&gt;

&lt;p&gt;Trivial equivalence is when everything is said to be equivalent. This is pretty useless.&lt;/p&gt;

&lt;p&gt;We will discuss &lt;em&gt;contexual&lt;/em&gt; and &lt;em&gt;logical&lt;/em&gt; equivalence, which are the same.&lt;/p&gt;

&lt;p&gt;Two terms are contextually equivalent if any program we embed those terms into cannot tell the difference between the two terms. This is pretty well motivated–we want to know if this is the case all the time. However, it’s hard to work with, since in theory, to show it, we have to check all possible inputs.&lt;/p&gt;

&lt;p&gt;Contexual: &lt;script type=&quot;math/tex&quot;&gt;e \cong e&#39; : \t&lt;/script&gt;&lt;br /&gt;
Logical: &lt;script type=&quot;math/tex&quot;&gt;e \sim e&#39; : \t&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;(Special case of) Reynold’s Abstraction Theorem: If &lt;script type=&quot;math/tex&quot;&gt;\prove e : \t&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;e \sim e : \t&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Logical relation:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
e \sim e&#39; : \boolt &amp; \iff (e \mapsto^* \tt \wedge e&#39; \mapsto^* \tt) \vee (e \mapsto^* \ff \wedge e&#39; \mapsto^* \ff) \\
e \sim e&#39; : \unitt &amp; \iff \m{yes} \\
e \sim e&#39; : \natt &amp; \iff \exists n . e \mapsto^* \bar{n} \wedge e&#39; \mapsto \bar{n} \\
e \sim e&#39; : \t_1 \to \t_2 &amp; \iff \forall v, v&#39; . \m{if}~v \sim v&#39; : \t_1, \m{then}~e~v\sim e&#39;~v&#39; : \t_2 \\
e \sim e&#39; : \t_1 \times \t_2 &amp; \iff e \cdot l \sim e&#39; \cdot l : \tau_1 \vee e \cdot r \sim e&#39; \cdot r : \t_2 \\
e \sim e&#39; : \allt{\a}{\t} &amp; \iff \forall \t_1, \t_2 . \forall R : \t_1 \leftrightarrow \t_2 . \App{e}{\t_1} \sim \App{e&#39;}{\t_2} : \subst{R}{\a}{\t} \\
e \sim e&#39; : R &amp; \iff e~R~e&#39;
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;We’re using quasi-types:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;q ::= \boolt \mid \natt \mid \unitt \mid q \to q \mid q \times q \mid \allt{\a}{q} \mid R&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;R \subseteq \{ e\mid e : \t_1 \} \times \{ e \mid e : \t_2 \}&lt;/script&gt;

&lt;p&gt;such that &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; is closed under equivalence. Thus, reflexivity is no longer obvious, which makes the abstraction theorem so useful.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;M_1 = \pack{\boolt}{\pair{\ff}{\pair{\natt}{\lambda x . x}}}{\a}{\a \times (\a \to \a) \times \a \to \boolt}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;M_2 = \pack{\natt}{\pair{\bar{0}}{\pair{\m{succ}}{\m{odd?}}}}{\a}{\a \times (\a \to \a) \times \a \to \boolt}&lt;/script&gt;

&lt;p&gt;We can prove that &lt;script type=&quot;math/tex&quot;&gt;M_1 \sim M_2 : \existst{\a}{\a \times (\a \to \a) \times \a \to \boolt}.&lt;/script&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 24 Mar 2015 13:27:21 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/03/24/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/03/24/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 17: Polymorphism</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}
\def\a{\alpha}
\def\t{\tau}

\def\natt{\m{nat}}
\def\boolt{\m{bool}}
\def\unitt{\m{unit}}
\def\voidt{\m{void}}

\def\unit{\langle \rangle}

\def\prove{\vdash}

\renewcommand\fun[3]{\lambda #1 : #2 . #3}
\renewcommand\Fun[2]{\Lambda #1 . #2}

\def\typet{\m{type}}
\renewcommand\type[1]{#1~\typet}

\renewcommand\allt[2]{\forall(#1.#2)}
\renewcommand\prodt[2]{#1 \times #2}
\renewcommand\pair[2]{\langle #1, #2 \rangle}
\renewcommand\App[2]{#1[#2]}
\renewcommand\subst[3]{[#1 / #2] #3}
$$
&lt;/div&gt;

&lt;h1 id=&quot;polymorphism-continued&quot;&gt;Polymorphism (continued)&lt;/h1&gt;

&lt;h2 id=&quot;type-safety&quot;&gt;Type Safety&lt;/h2&gt;

&lt;p&gt;Preservation and progress do hold. See &lt;em&gt;PFPL&lt;/em&gt; for more details.&lt;/p&gt;

&lt;p&gt;To prove preservation for&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{}
{\App{(\Fun{\alpha}{e})}{\tau} \to \subst{\tau}{\alpha}{e}}&lt;/script&gt;

&lt;p&gt;we need a substitution lemma (type substitution).&lt;/p&gt;

&lt;h2 id=&quot;language-constructs&quot;&gt;Language Constructs&lt;/h2&gt;

&lt;p&gt;Recall natural numbers from the untyped lambda calculus:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\bar{0} = \lambda z . \lambda s . z&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\overline{n+1} = \lambda z . \lambda s . s ~ (\bar{n} ~ z ~ s)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\natt: b \to (b \to b) \to b&lt;/script&gt;

&lt;p&gt;We need to fix $b$ to be a specific type, which works in an untyped language (type is just &lt;script type=&quot;math/tex&quot;&gt;\m{dyn}&lt;/script&gt;) but not in the typed lambda calculus.&lt;/p&gt;

&lt;p&gt;With polymorphism, we can make this work:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\natt &amp; = \allt{\alpha}{\alpha \to (\alpha \to \alpha) \to \alpha} \\
\bar{0} &amp; = \Fun{\alpha}{\fun{z}{\alpha}{\fun{s}{\alpha \to \alpha}{z}}} \\
\overline{n+1} &amp; = \Fun{\alpha}{\fun{z}{\alpha}{\fun{s}{\alpha \to \alpha}{s~(\App{\bar{n}}{\alpha}~z~s)}}} \\
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;We can also implement other constructs we’ve seen in this class:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\boolt &amp; = \allt{\alpha}{\alpha \to \alpha \to \a} \\
\overline{\m{true}} &amp; = \Fun{\alpha}{\fun{x}{\a}{\fun{y}{\a}{x}}}
\end{align} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\prod{\tau_1}{\tau_2} &amp; = \allt{\a}{(\tau_1 \to \tau_2 \to \a) \to \a} \\
\overline{\pair{e}{e&#39;}} &amp; = \Fun{\a}{\fun{f}{\t_1 \to \t_2 \to \a}{f~e~e&#39;}} \\
\m{outl}_{\t_1,t_2}~e &amp; = \App{e}{\t_1}(\fun{x}{\t_1}{\fun{y}{\t_2}{x}})
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;System-F also has sum types, though it does &lt;em&gt;not&lt;/em&gt; have recursive types, because all programs terminate.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\unitt &amp; = \allt{\a}{\a \to \a} \\
\overline{\unit} &amp; = \Fun{\a}{\fun{x}{\a}{x}} \\
\voidt &amp; = \allt{\a}{\a} \\
\overline{\m{abort}_\t~e} &amp; = \App{e}{\t}
\end{align} %]]&gt;&lt;/script&gt;

&lt;h2 id=&quot;natural-numbers&quot;&gt;Natural Numbers&lt;/h2&gt;
&lt;p&gt;We claim that our definition of natural numbers &lt;em&gt;are the natural numbers&lt;/em&gt;: there is nothing else in the type. Similarly, for &lt;script type=&quot;math/tex&quot;&gt;\unitt&lt;/script&gt;, if &lt;script type=&quot;math/tex&quot;&gt;e : \unitt&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;e \cong \Fun{\a}{\fun{x}{\a}{x}}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Proving this rigorously takes an additional semester of math. But, in short, this proof relies on &lt;em&gt;parametricity&lt;/em&gt;. Since we can’t branch on type, we have parametric polymorphism. Consider&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e \cong \Fun{\alpha}{\fun{x}{\a}{\_}}&lt;/script&gt;

&lt;p&gt;Because we can’t branch on &lt;script type=&quot;math/tex&quot;&gt;\a&lt;/script&gt;, and because $\a$ is unknown, the only way to produce a value of type &lt;script type=&quot;math/tex&quot;&gt;\a&lt;/script&gt; is to fill in the blank with &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;If the language allowed for non-terminating programs (recursion), then for &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt; to have type &lt;script type=&quot;math/tex&quot;&gt;\alpha&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;e \cong \bot&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\Fun{\a}{\bot}&lt;/script&gt;, or &lt;script type=&quot;math/tex&quot;&gt;\Fun{\alpha}{\fun{x}{\a}{\bot}}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;The Parametricity Theorem is also called the Abstraction Theorem, which is an important part of modular programming. It basically says that we can have a program composed of separate pieces that can possibly work.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;Crary claims that the Abstraction Theorem is the most important theorem in computer science.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;impredicative-types&quot;&gt;Impredicative Types&lt;/h2&gt;

&lt;p&gt;In &lt;script type=&quot;math/tex&quot;&gt;\allt{\a}{\t}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\a&lt;/script&gt; ranges over a collection (possibly not a set) of types that includes &lt;script type=&quot;math/tex&quot;&gt;\allt{\a}{\t}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;In ML, we have &lt;em&gt;predicative&lt;/em&gt; types. There are monotypes (&lt;script type=&quot;math/tex&quot;&gt;\tau ::= \a \mid \t \to \t&lt;/script&gt;) and polytypes (&lt;script type=&quot;math/tex&quot;&gt;\sigma ::= \t \mid \allt{\a}{\sigma}&lt;/script&gt;). Note that the &lt;script type=&quot;math/tex&quot;&gt;\forall&lt;/script&gt; ranges over monotypes, not polytypes. This lets ML hide all quanitifies, and it uses prenex quantification to put all the quantifies at the front of the type.&lt;/p&gt;

&lt;h2 id=&quot;value-restriction&quot;&gt;Value Restriction&lt;/h2&gt;
&lt;p&gt;[&lt;em&gt;I’m not sure I understand this explanation.&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;Why does ML blow up if you have &lt;code&gt;val x = rev nil&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;Consider&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val x = (print &quot;hello&quot;; nil)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we let this have the type &lt;code&gt;&#39;a list&lt;/code&gt;, then &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; would be a value. Whenever &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; is used, “hello” will be printed. Thus, we can introduce unexpected side effects to our program.&lt;/p&gt;

&lt;p&gt;This is commonly, &lt;em&gt;incorrectly&lt;/em&gt; believed to be to preserve type safety. (For what it’s worth, &lt;a href=&quot;http://mlton.org/ValueRestriction&quot;&gt;MLTon claims this&lt;/a&gt;.) The concern is&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;val r = ref NONE;
val () = r := SOME 12;
val x = case !(r : (int -&amp;gt; int) option ref) of
            NONE =&amp;gt; ...
          | SOME f =&amp;gt; f 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, a new reference &lt;script type=&quot;math/tex&quot;&gt;r&lt;/script&gt; is being generated each time, so while the behavior is unexpected, it does not break type safety. The reason it’s believed this breaks type safety is that it’s incorrectly believed there should be a rule&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \mapsto e&#39;}
{\Fun{\a}{e} \mapsto \Fun{\a}{e&#39;}}&lt;/script&gt;
</description>
        <pubDate>Thu, 19 Mar 2015 13:30:50 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/03/19/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/03/19/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
  </channel>
</rss>
