<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Notes</title>
    <description>Notes on classes at CMU.
</description>
    <link>http://www.tomshen.me/notes/</link>
    <atom:link href="http://www.tomshen.me/notes/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Thu, 30 Apr 2015 14:47:28 -0400</pubDate>
    <lastBuildDate>Thu, 30 Apr 2015 14:47:28 -0400</lastBuildDate>
    <generator>Jekyll v2.4.0</generator>
    
      <item>
        <title>15-312 Lecture 28: Higher-order type constructors</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}

\renewcommand{\type}{\m{type}}
\renewcommand{\natt}{\m{nat}}
\renewcommand{\intt}{\m{int}}

\renewcommand{\pair}[2]{\langle #1, #2 \rangle}
\renewcommand{\ref}[1]{#1~\m{ref}}
$$
&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;The final exam will be cumulative, including all lectures. There will be more of a focus on material covered in the second half of the course. Open book, open notes, but “closed” electronics.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;We’re going to be discussing &lt;em&gt;higher-order type constructors,&lt;/em&gt; also known as &lt;em&gt;higher kinds.&lt;/em&gt; The associated language is $F_\omega$.&lt;/p&gt;

&lt;p&gt;Recall System-F:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\tau ::= \alpha \mid \forall \alpha . \tau \mid \tau \to \tau&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e ::= x \mid \Lambda \alpha . e \mid e[\tau] \mid \lambda x : \tau . e \mid e~e&lt;/script&gt;

&lt;p&gt;We’ve said that $\tau : \m{type}$. But is $\type$ a type? If it is, then we can ask if $\type : \type$, but this is a really bad question. $\type$ can’t be a type, but it also can’t not be a type. How do we resolve this?&lt;/p&gt;

&lt;p&gt;If we want to have computations that produce types, then we want these computations have types as well. We call these types of types &lt;em&gt;kinds&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Currently, our only kind is $\type$. We replace $\tau$ with $c$, which stands for &lt;em&gt;type constructor&lt;/em&gt; (or just &lt;em&gt;constructor&lt;/em&gt;).&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;k ::= \type&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\tau ::= \alpha \mid \forall \alpha : k .c \mid c \to c&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e ::=  x \mid \Lambda \alpha : k . e \mid e[c] \mid \lambda x : c . e \mid e~e &lt;/script&gt;

&lt;p&gt;We have two types (&lt;em&gt;types types types types types&lt;/em&gt;) of judgments: $e : c$ and $c : k$.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \Gamma, \alpha : k \vdash e : c
}{
    \Gamma \vdash \Lambda \alpha : k . e : \forall \alpha : k . c
}&lt;/script&gt;

&lt;p&gt;&lt;em&gt;[Missing quite a few judgments]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We add a new type:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;k ::= \type \mid k \to k&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;c ::= \cdots \mid \lambda \alpha : k . c \mid c~c&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \Gamma, \alpha : k \vdash c : k&#39;
}{
    \Gamma \vdash \lambda \alpha : k . c : k \to k&#39;
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \Gamma \vdash c_1 : k \to k&#39; \qquad
    \Gamma \vdash c_2 : k
}{
    \Gamma \vdash c_1~c_2 : k&#39;
}&lt;/script&gt;

&lt;p&gt;Note that distinction between $\lambda \alpha : k . c$ and $\lambda \alpha : k . c$. The former is &lt;em&gt;not&lt;/em&gt; a type, and the latter is a &lt;em&gt;type&lt;/em&gt;, with members.&lt;/p&gt;

&lt;p&gt;Standard ML doesn’t have type constructors (Haskell does!), but you can simulate them with functors:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-sml&quot; data-lang=&quot;sml&quot;&gt;&lt;span class=&quot;kr&quot;&gt;functor&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;Foo&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;X&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;sig&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;struct&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;t&lt;/span&gt;
    &lt;span class=&quot;kr&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;sig&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;val&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;u&lt;/span&gt; &lt;span class=&quot;kr&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;$\m{Foo} : \forall t : \type . t~\intt \to \exists u : \type \to \type. u~\intt$&lt;/p&gt;

&lt;p&gt;As an example, we’ll define a general increment function that will incrememnt anything that looks like a counter:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\m{counter} = \exists \alpha . \alpha \times ((\alpha \to \alpha) \times (\alpha \to \natt))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\m{genInc} : \forall \alpha . (\alpha \to \m{counter}) \to \alpha \to \alpha&lt;/script&gt;

&lt;p&gt;Without higher order type constructors, we can’t write this:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\m{genInc} : \Lambda \alpha . \lambda f : \alpha \to \m{counter} . \lambda x : \alpha . ??&lt;/script&gt;

&lt;p&gt;We define a counter interface:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\m{counterI} : \type \to \type = \lambda \alpha : \type . (\alpha \to \alpha) \times (\alpha \to \natt)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\m{obj} : (\type \to \type) \to \type = \lambda \varphi : \type \to \type . \exists \alpha . \alpha \times \varphi~\alpha&lt;/script&gt;

&lt;p&gt;Note that $\m{counter} \cong \m{obj}~\m{counterI}$.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\m{genInc} : &amp; \forall \varphi : \type \to \type . (\forall \alpha . \varphi~\alpha \to \m{counterI}~\alpha) \to \m{obj}~\varphi \to \m{obj}~\varphi \\
= &amp; \Lambda \varphi : \type \to \type . (\forall \alpha . \varphi~\alpha \to \m{counterI}~\alpha) . \lambda x : \m{obj}~\varphi . \\
&amp; \m{unpack}~[\alpha,y] = x \m{ in } \m{pack}~[\alpha, \pair{f[\alpha](y \cdot r) \cdot l~(y \cdot l)}{y \cdot r}] \\
&amp; \m{ as } \exists \alpha . \alpha \times \varphi~\alpha
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;Consider $\m{id} : \forall \varphi : \type \to \type . \varphi~\intt \to \varphi~\intt$.&lt;/p&gt;

&lt;p&gt;But when we try to apply this:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\m{id}[\lambda \alpha : \type . \alpha]~12&lt;/script&gt;

&lt;p&gt;We end up with &lt;script type=&quot;math/tex&quot;&gt;(\lambda \alpha . \alpha)~\intt \to (\lambda \alpha . \alpha)~\intt&lt;/script&gt;. However, &lt;script type=&quot;math/tex&quot;&gt;(\lambda \alpha . \alpha)~\intt \neq \intt&lt;/script&gt;. Though these types are equivalent, they are not identical, and thus we don’t recognize this in our type theory. We fix this with the &lt;em&gt;equivalence rule&lt;/em&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \Gamma \vdash e : \tau \qquad
    \Gamma \vdash \tau \equiv \tau&#39; : \type
}{
    \Gamma \vdash e : \tau&#39;
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \Gamma \vdash c : k
}{
    \Gamma \vdash c \equiv c : k
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \Gamma \vdash c \equiv c&#39; : k
}{
    \Gamma \vdash c&#39; \equiv c : k
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \Gamma \vdash c_1 \equiv c_2 : k \qquad
    \Gamma \vdash c_2 \equiv c_3 : k
} {
    \Gamma \vdash c_1 \equiv c_3 : k
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \Gamma \vdash c&#39; : k_1 \qquad
    \Gamma, \alpha : k \vdash c : k_2
}{
    \Gamma \vdash (\lambda \alpha : k_1 . c) c&#39; \equiv [c&#39; / \alpha]~c : k_2
}(\beta)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \Gamma \vdash c_1 \equiv c_1 : \type \qquad
    \Gamma \vdash e_2 \equiv e_2&#39; : \type
}{
    \Gamma \vdash c_1 \to c_2 \equiv c_1&#39; \to c_2&#39; : \type
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \Gamma \vdash c_1 \equiv c_1&#39; : k \to k&#39; \qquad
    \Gamma \vdash c_2 \equiv _2&#39; : k
}{
    \Gamma \vdash c_1~c_2 \equiv c_1&#39;~c_2&#39; : k&#39;
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \Gamma, \alpha : k \vdash c \equiv c&#39; : k&#39;
}{
    \Gamma \vdash \alpha : k . c \equiv \lambda \alpha : k . c&#39; : k \to k&#39;
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \Gamma, \alpha : k \vdash c~\alpha \equiv c&#39;~\alpha : k_2
}{
    \Gamma \vdash c \equiv c&#39; : k_1 \to k_2
}(\m{extensionality})&lt;/script&gt;

&lt;p&gt;(must hold for all $\alpha$)&lt;/p&gt;

&lt;p&gt;The &lt;strong&gt;Church-Rosser Theorem&lt;/strong&gt; lets us prove normal forms with these equivalence rules [?].&lt;/p&gt;
</description>
        <pubDate>Thu, 30 Apr 2015 13:31:32 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/04/30/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/04/30/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 27: Subtyping</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}

\renewcommand{\natt}{\m{nat}}
\renewcommand{\intt}{\m{int}}

\renewcommand{\pair}[2]{\langle #1, #2 \rangle}
\renewcommand{\ref}[1]{#1~\m{ref}}
$$
&lt;/div&gt;

&lt;h1 id=&quot;subtyping&quot;&gt;Subtyping&lt;/h1&gt;

&lt;p&gt;We represents subtyping with $&amp;lt;:$.&lt;/p&gt;

&lt;p&gt;The &lt;em&gt;subsumption principle&lt;/em&gt;: if $\tau &amp;lt;: \tau’$, then a term of type $\tau’$ can be used anywhere a term of type $\tau’$ is expected.&lt;/p&gt;

&lt;p&gt;Therefore, subtyping is reflexive and transitive. It may not be anti-symmetric.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\frac{
    \Gamma \vdash e : \tau \qquad
    \tau &lt;: \tau&#39;
}{
    \Gamma \vdash e : \tau&#39;
}(\m{subsumption}) %]]&gt;&lt;/script&gt;

&lt;p&gt;$\tau$ is the &lt;em&gt;subtype&lt;/em&gt;, and $\tau’$ is the &lt;em&gt;supertype&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;For instance, $\natt :&amp;gt; \intt$ means either&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;the values of $\natt$ are values of type $\intt$ (inclusive), or&lt;/li&gt;
  &lt;li&gt;the values of $\natt$ can be coerced into values of type $\intt$ (coercive).&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;There are three types of subtyping:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;subtyping on base types (e.g. $\natt &amp;lt;: \intt$)&lt;/li&gt;
  &lt;li&gt;structural subtyping (general products and sums)&lt;/li&gt;
  &lt;li&gt;nominal subtyping that you have to declare (e.g. $\m{Square} &amp;lt;: \m{Shape}$)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;We “don’t like” nominal subtyping, because it’s just a veneer over some underlying relationship.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Width&lt;/em&gt; subtyping is subtyping on general products (records in ML) or general sums.&lt;/p&gt;

&lt;p&gt;For general products, $\pair{i_1 \hookrightarrow \natt}{i_2 \hookrightarrow \m{bool}} &amp;lt;: \langle i_1 \hookrightarrow \natt \rangle$.&lt;/p&gt;

&lt;p&gt;For general sums, $[i_1 \hookrightarrow \natt] &amp;lt;: [i_1 \hookrightarrow \natt, i_2 \hookrightarrow \m{bool}]$. Note the reversed ordering.&lt;/p&gt;

&lt;p&gt;There are tradeoffs when it comes to implementation of subtyping. You can only have two of the following:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;cheap access&lt;/li&gt;
  &lt;li&gt;inclusive interpretation&lt;/li&gt;
  &lt;li&gt;unordered&lt;/li&gt;
&lt;/ol&gt;

&lt;h1 id=&quot;variance&quot;&gt;Variance&lt;/h1&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\frac{
    \tau_1 &lt;: \tau_1&#39; \qquad
    \tau_2 &lt;: \tau_2&#39;
}{
    \tau_1 \times \tau_2 &lt;: \tau_1&#39; \times \tau_2&#39;
}(\m{covariant}) %]]&gt;&lt;/script&gt;

&lt;p&gt;Note that order matters for pairs, but labels matter for general products. $\pair{i_1 \hookrightarrow \natt}{i_2 \hookrightarrow \m{bool}} &amp;lt;: \pair{i_1 \hookrightarrow \intt}{i_2 \hookrightarrow \m{bool}}$ is &lt;em&gt;depth&lt;/em&gt; subtyping.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\frac{
    \tau_1&#39; &lt;: \tau_1 \qquad
    \tau_2 &lt;: \tau_2&#39;
}{
    \tau_1 \to \tau_2 &lt;: \tau_1&#39; \to \tau_2&#39;
}(\m{contravariant}) %]]&gt;&lt;/script&gt;

&lt;p&gt;Note the flipping for $\tau_1$. Functions are &lt;em&gt;contravariant&lt;/em&gt; on the left, and &lt;em&gt;covariant&lt;/em&gt; on the right. By default, things are covariant, and thus contravariance is more interesting. In fact, contravariance is &lt;em&gt;the&lt;/em&gt; interesting thing about subtyping.&lt;/p&gt;

&lt;p&gt;For instance, $\intt \to \natt &amp;lt;: \natt \to \natt$. This is because, if we expect to have a function that has a $\natt$ as input, being given a function that takes $\intt$ as input is fine. The reverse is not true, since we can’t pass an $\intt$ to a function that takes an $\natt$ as input.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\frac{
    \tau_1 &lt;: \tau_1&#39; \qquad
    \tau_2 &lt;: \tau_2&#39;
}{
    \tau_1 + \tau_2 &lt;: \tau_1&#39; + \tau_2&#39;
}(\m{covariant}) %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\frac{
    \tau = \tau&#39;
}{
    \ref{\tau} &lt;: \ref{\tau&#39;}
}(\m{invariant}) %]]&gt;&lt;/script&gt;

&lt;p&gt;References are neither covariant nor contravariant: they are &lt;em&gt;invariant&lt;/em&gt;. Consider $\ref{\natt}$ and $\ref{\intt}$. If we expect an $\ref{\intt}$, but have a $\ref{\natt}$, and attempt to assign a $\intt$, it fails. If we expect a $\ref{\natt}$, but have a $\ref{\natt}$, and attempt to read it, it fails.&lt;/p&gt;

&lt;p&gt;Three anecdotes on poor language design with respect to subtyping:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Eiffel is a language with covariant functions. Naturally, this broke type safety. To patch around this, you need to do a global check to make sure your code isn’t horribly broken.&lt;/li&gt;
  &lt;li&gt;Arrays are just “wider” references, and thus they should be invariant as well. In Java, arrays are covariant. Thus, Java has runtime checks, and you downcast every time you get something out of an array. This makes it really hard to have efficient arrays, and the compiler has to do a lot of extra work (dataflow analysis) to see if the downcasts can be omitted.&lt;/li&gt;
  &lt;li&gt;There is a paper titled “Should Your Specification Language Be Typed?” by “a famous guy” (Leslie Lamport, of distributed systems and $\LaTeX$ fame). He assumed that references (called variables in his type theory) should be covariant (since everything should be covariant), and thus type safety is broken and useless. In essence, he showed that broken type theories are broken.&lt;/li&gt;
&lt;/ol&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\frac{
    \alpha : \m{type} \vdash \tau &lt;: \tau&#39;
}{
    \forall \alpha  . \tau &lt;: \forall \alpha . \tau&#39;
} %]]&gt;&lt;/script&gt;

&lt;h1 id=&quot;bounded-quantification&quot;&gt;Bounded quantification&lt;/h1&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\tau ::= \cdots \mid \forall \alpha &lt;: \tau_1 . \tau_2 %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\frac{
    \Gamma, \alpha &lt;: \tau \vdash e : \tau&#39;
}{
    \Gamma \vdash \Lambda \alpha &lt;: \tau . e : \forall \alpha &lt;: \tau . \tau&#39;
} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\frac{
    \Gamma \vdash e : \forall \alpha &lt;: \tau_1 . \tau_2 \qquad
    \Gamma \vdash \tau &lt;: \tau_1
}{
    \Gamma \vdash e[\tau] : [\tau / \alpha]~\tau_2
} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\frac{
    \Gamma \vdash \tau_1&#39; &lt;: \tau_1 \qquad
    \Gamma, \alpha &lt;: \tau_1&#39; \vdash \tau_2 &lt;: \tau_2&#39;
}{
    (\Gamma \vdash \forall \alpha &lt;: \tau_1 . \tau_2)
    &lt;:
    (\forall \alpha &lt;: \tau_1&#39; . \tau_2&#39;)
} %]]&gt;&lt;/script&gt;

&lt;p&gt;This language is called $F_{&amp;lt;:}$ (pronounced “F-sub”). Unfortunately, subtyping is undecidable. We can choose to just implement type checking anyways. Since the infinite-looping case only happens when we write a program that doesn’t type check, and since it’s pretty rare, we can sort of just be okay with that. (For instance, SML’s type checking can be hyperexponential in theory, but is generally linear in practice.) There exists something called &lt;a href=&quot;http://www.di.unipi.it/~ghelli/papers/ColGhe99-lics.pdf&quot;&gt;&lt;em&gt;kernel Fun&lt;/em&gt;&lt;/a&gt; that avoids this problem, but it’s not fun.&lt;/p&gt;

&lt;p&gt;Consider recursive types. Is it the case that $\mu~\alpha . \natt \times (\alpha \to \natt) &amp;lt;: \mu~\alpha . \intt \times (\alpha \to \intt)$? If we have $\m{fold}~\pair{0}{\lambda x : T . \sqrt{(\m{unfold}~x).l}} : T$, where the square root is natural number square root. Obviously, this won’t work if we have a negative integer, so recursive types cannot be covariant. The actual rule needs to be&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\frac{
    \Gamma, \alpha&#39;~\m{type}, a &lt;: \alpha&#39; \vdash \tau &lt;: \tau&#39;
}{
    \Gamma \vdash \mu~\alpha . \tau &lt;: \mu~\alpha&#39; . \tau&#39;
} %]]&gt;&lt;/script&gt;
</description>
        <pubDate>Tue, 28 Apr 2015 13:18:08 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/04/28/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/04/28/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 26: Proofs as Programs</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\renewcommand\defeq{\overset{def}{=}}

\renewcommand{\true}[1]{#1~\m{true}}

\renewcommand{\intro}[1]{#1\text{-I}}
\renewcommand{\elim}[1]{#1\text{-E}}

\renewcommand{\pair}[2]{\langle #1, #2 \rangle}
\renewcommand{\proj}[2]{#1.#2}
\renewcommand{\inl}[1]{\m{inl}~#1}
\renewcommand{\inr}[1]{\m{inr}~#1}
\renewcommand{\case}[5]{\m{case}(#1;#2.#3;#4.#5)}
\renewcommand{\unit}{()}
\renewcommand{\abort}[1]{\m{abort}~#1}
$$
&lt;/div&gt;

&lt;p&gt;We’ll be talking about&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;propositions as types&lt;/li&gt;
  &lt;li&gt;proofs as programs&lt;/li&gt;
  &lt;li&gt;the Curry-Howard Isomorphism&lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;propositions-as-types&quot;&gt;Propositions as types&lt;/h1&gt;

&lt;h2 id=&quot;propositions&quot;&gt;Propositions&lt;/h2&gt;

&lt;p&gt;What is the meaning of a logical proposition? e.g.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\|x\| = 121, \|x\| = 0&lt;/script&gt;

&lt;p&gt;&lt;em&gt;Denotation&lt;/em&gt; is the assignment of mathematic expressions, and is the truth value.&lt;/p&gt;

&lt;p&gt;So, &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; &lt;strong&gt;is&lt;/strong&gt; &lt;script type=&quot;math/tex&quot;&gt;121&lt;/script&gt;. But, this means that &lt;script type=&quot;math/tex&quot;&gt;\|x\| = 121&lt;/script&gt; is the same as&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\forall n &gt; 2 . \forall x,y,z \in \mathbb{N}. x^n + y^n \neq z^n,&lt;/script&gt;

&lt;p&gt;since both are true.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Sense&lt;/em&gt; is &lt;em&gt;[missing]&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;We want both denotation and sense. To resolve this, we want to focus on the proofs.&lt;/p&gt;

&lt;h2 id=&quot;judgments&quot;&gt;Judgments&lt;/h2&gt;

&lt;p&gt;We define a judgment &lt;script type=&quot;math/tex&quot;&gt;\true{A}&lt;/script&gt;. We also assume we have &lt;em&gt;atomic propositions&lt;/em&gt; that we know the proofs for, such as &lt;script type=&quot;math/tex&quot;&gt;11 \times 11 = 121&lt;/script&gt;.&lt;/p&gt;

&lt;h3 id=&quot;introduction&quot;&gt;Introduction&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \true{A} \qquad
    \true{B}
}{
    \true{A \wedge B}
}(\intro{\wedge})&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \true{A}
}{
    \true{A \vee B}
}(\intro{\vee}1)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \true{B}
}{
    \true{A \vee B}
}(\intro{\vee}2)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{

}{
    \true{T}
}(\intro{T})&lt;/script&gt;

&lt;p&gt;(&lt;script type=&quot;math/tex&quot;&gt;\supset&lt;/script&gt; is implication)&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \true{A} \vdash \true{B}
}{
    \true{A \supset B}
}(\intro{\supset})&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\neg A \defeq A \supset F&lt;/script&gt;

&lt;h3 id=&quot;elimination&quot;&gt;Elimination&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \true{A \wedge B}
}{
    \true{A}
}(\elim{\wedge}1)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \true{A \wedge B}
}{
    \true{B}
}(\elim{\wedge}2)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \true{A \vee B} \qquad
    \true{A} \vdash \true{C} \qquad
    \true{B} \vdash \true{C}
}{
    \true{C}
}(\elim{\vee})&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \true{F}
}{
    \true{C}
}(\elim{F})&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \true{A \supset B} \qquad
    \true{A}
}{
    \true{B}
}(\elim{\supset})&lt;/script&gt;

&lt;h2 id=&quot;intuitionistic--constructive-logic&quot;&gt;Intuitionistic / Constructive Logic&lt;/h2&gt;
&lt;p&gt;We’ve just defined the basics of constructive logic. Note that we cannot prove that, in general,&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{

}{
    \true{A \vee \neg A}
}.&lt;/script&gt;

&lt;p&gt;In other words, we do not have the &lt;em&gt;law of excluded middle&lt;/em&gt;. Similarly, we cannot prove&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    \true{\neg \neg A} \qquad
    \true{A}
}{
    \neg \neg A \supset \true{A}
},&lt;/script&gt;

&lt;p&gt;which is &lt;em&gt;double negation elimination&lt;/em&gt;, since it is equivalent to the law of excluded middle. This is important since this is how we do proof by contradiction.&lt;/p&gt;

&lt;p&gt;You may think that classical logic is “better,” since we have these (pretty handy) theorems. But, you lose the distinction between &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\neg \neg A&lt;/script&gt;. Thus, &lt;strong&gt;intuitionistic logic has more expressive power.&lt;/strong&gt; Additionally, intuitionistic logic has a useful computational interpretation.&lt;/p&gt;

&lt;h1 id=&quot;proofs-as-programs&quot;&gt;Proofs as programs&lt;/h1&gt;

&lt;p&gt;We represent “&lt;script type=&quot;math/tex&quot;&gt;M&lt;/script&gt; is a &lt;em&gt;proof term&lt;/em&gt; for &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;” with &lt;script type=&quot;math/tex&quot;&gt;M : A&lt;/script&gt;.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    M : A \qquad
    N : B
}{
    \pair{M}{N} : A \wedge B
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    M : A \wedge B
}{
    \proj{M}{l} : A
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    M : A \wedge B
}{
    \proj{M}{r} : B
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    x : A \vdash M : B
}{
    \lambda x : A.M : A \supset B
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    M : A \supset B \qquad
    N : A
}{
    MN : B
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    M : A
}{
    \inl{M} : A \vee B
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    M : B
}{
    \inr{M} : A \vee B
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    M : A \vee B \qquad
    x : A \vdash N : C \qquad
    y : B \vdash O : C
}{
    \case{M}{x}{N}{y}{O} : C
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{

}{
    \unit : T
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    M : F
}{
    \abort{M} : C
}&lt;/script&gt;

&lt;p&gt;So, a proof of &lt;script type=&quot;math/tex&quot;&gt;\true{(A \supset B) \supset (\neg B \supset \neg A)}&lt;/script&gt; would be&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\lambda f : A \supset B . \lambda y : \neg B . \lambda x : A . g(f x)&lt;/script&gt;

&lt;p&gt;This is the &lt;em&gt;Curry-Howard Isomorphism&lt;/em&gt;!&lt;/p&gt;

&lt;table&gt;
  &lt;thead&gt;
    &lt;tr&gt;
      &lt;th&gt;Propositions&lt;/th&gt;
      &lt;th&gt;Types&lt;/th&gt;
    &lt;/tr&gt;
  &lt;/thead&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;A \wedge B&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;A \times B&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;A \vee B&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;A + B&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;A \supset B&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;A \to B&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;T&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\unit&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;F&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\m{void}&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\forall x . A&lt;/script&gt;&lt;/td&gt;
      &lt;td&gt;&lt;script type=&quot;math/tex&quot;&gt;\pi x . A&lt;/script&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Note that recursive types don’t work out well, since it’s then possible to prove any proposition.&lt;/p&gt;
</description>
        <pubDate>Thu, 23 Apr 2015 13:32:05 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/04/23/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/04/23/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 25: Concurrency &amp; Interaction (continued)</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
$$
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Delivered by Bob Harper&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;asynchronous-process-calculus&quot;&gt;Asynchronous Process Calculus&lt;/h1&gt;
&lt;p&gt;Previously, we discussed sychronous process calculus. But, how is a process supposed to know that some other process has received a message it sent? There must be some sort of back channel between these processes that sends a “notification.”&lt;/p&gt;

&lt;p&gt;We only have receive events:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;E ::= \cdots \mid ?a(x.P) \mid O | E_1 + E_2&lt;/script&gt;

&lt;p&gt;Thus, an event will always be of the form&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;?a_1(x_1.P_1) | \cdots | ?a_n(x_n.P_n)&lt;/script&gt;

&lt;p&gt;This is like &lt;code&gt;select&lt;/code&gt; in CML and Unix sockets.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P ::= \$E \mid !a(v) \mid \nu a \sim \tau.P \mid 1 \mid P_1 \parallel P_2&lt;/script&gt;

&lt;p&gt;We acknowledge receipt by sending &lt;script type=&quot;math/tex&quot;&gt;\langle \rangle&lt;/script&gt;. We arrange to have backchannels through our own programming.&lt;/p&gt;

&lt;p&gt;What about types on channels?&lt;/p&gt;

&lt;p&gt;You can choose your own by specifying &lt;script type=&quot;math/tex&quot;&gt;\tau&lt;/script&gt; in &lt;script type=&quot;math/tex&quot;&gt;\nu a \sim \tau.P&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Or, we choose a specific type, via &lt;em&gt;polyadic &lt;script type=&quot;math/tex&quot;&gt;\pi&lt;/script&gt;-calculus&lt;/em&gt;. We declare channels with &lt;script type=&quot;math/tex&quot;&gt;\nu a .P&lt;/script&gt;. No type is specified, and instead you send a tuple of things and pattern match.&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\nu a \sim \pi . P&lt;/script&gt;. We can only send channels. Data is represented by processes. Milner numerals are process calculus versions of Church numerals.&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\pi \cong \sum_{n \in \mathbb{N}} \pi~\m{chan} \times \cdots \times \pi~\m{chan}&lt;/script&gt;&lt;br /&gt;
(n times)&lt;/p&gt;

&lt;p&gt;Note that &lt;script type=&quot;math/tex&quot;&gt;\pi&lt;/script&gt; is a recursive type, and that consitutent types are channel references, which admit both send and receive. Recall that &lt;script type=&quot;math/tex&quot;&gt;\Lambda&lt;/script&gt; (the &lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt;-calculus) is universal with respect to &lt;script type=&quot;math/tex&quot;&gt;\m{nat} \rightharpoonup \m{nat}&lt;/script&gt;, because &lt;script type=&quot;math/tex&quot;&gt;\lambda \cong (\lambda \to \lambda)&lt;/script&gt;, so we can encode the Y combinator and have recursion. The &lt;script type=&quot;math/tex&quot;&gt;\pi&lt;/script&gt;-calculus is also universal with respect to &lt;script type=&quot;math/tex&quot;&gt;\m{nat} \rightharpoonup \m{nat}&lt;/script&gt;, because we can encode &lt;script type=&quot;math/tex&quot;&gt;\Lambda&lt;/script&gt; into &lt;script type=&quot;math/tex&quot;&gt;\Pi&lt;/script&gt;. This only works because we have the recursive type.&lt;/p&gt;

&lt;h1 id=&quot;encoding-lambda&quot;&gt;Encoding &lt;script type=&quot;math/tex&quot;&gt;\Lambda&lt;/script&gt;&lt;/h1&gt;
&lt;p&gt;Key ideas:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt;-terms have names–channels&lt;/li&gt;
  &lt;li&gt;channels name servers taht can be contacted to obtain their value by passing a backchannel to a continuation (stack, &lt;script type=&quot;math/tex&quot;&gt;\lambda&lt;/script&gt;-term)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Define $M@k$, where $k$ is a channel reference.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;$x @ k \triangleq !!(x;k)$, where $x$ is going to be a $\lambda$-term&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;(\lambda x . M) @ k \triangleq \$(??(k; \langle x, k&#39;\rangle. M @ k))&lt;/script&gt;.&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
(M~N)@k \triangleq \nu m .(M @ (\&amp;m)) \parallel \nu a . (!m(\langle \&amp; a, k \rangle); *\$(?a.(n.(N~e~n)))) %]]&gt;&lt;/script&gt;, where &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
!m(\langle \&amp; a, k \rangle %]]&gt;&lt;/script&gt; informs &lt;script type=&quot;math/tex&quot;&gt;m&lt;/script&gt; of its argument’s location (server) and where to deliver result, and &lt;script type=&quot;math/tex&quot;&gt;*\$(?a.(n.(N~e~n)))&lt;/script&gt; is the “&lt;script type=&quot;math/tex&quot;&gt;N&lt;/script&gt; server”&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;[This is tricky and low level. We aren’t really expected to understand it]&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;consolidated-message-passing&quot;&gt;Consolidated Message Passing&lt;/h1&gt;
&lt;p&gt;We currently have $a!v$ and $a?v$, but instead, we could label our payloads with a header: $!(a.v)$ and $?(a.v)$. &lt;strong&gt;Globally unique identifiers are just reimplementing &lt;script type=&quot;math/tex&quot;&gt;\alpha&lt;/script&gt;-conversion.&lt;/strong&gt; A channel is a dynamic class, and a message is just a value of type &lt;script type=&quot;math/tex&quot;&gt;\m{clsfd}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;a \sim \tau&lt;/script&gt; is a class classifying values of type &lt;script type=&quot;math/tex&quot;&gt;\tau&lt;/script&gt;. Channels have nothing to do with concurrency (inherently, at least).&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P ::= !v \mid ?(x.P) \mid P_1 \parallel P_2 \mid 1&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Concurrency is non-deterministic composition.&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 21 Apr 2015 13:29:18 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/04/21/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/04/21/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 24: Concurrency &amp; Interaction (continued)</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
$$
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Delivered by Bob Harper&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Recall that we defined processes:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt; P ::= \$E \mid P_1 \parallel P_2 \mid \bot \mid *P &lt;/script&gt;

&lt;p&gt;and events:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt; E ::= ?a.P \mid !a.P \mid E_1 + E_2 \mid 0 &lt;/script&gt;

&lt;p&gt;We have a labeled transition system &lt;script type=&quot;math/tex&quot;&gt;P \overset{\alpha}{\mapsto} P&#39;&lt;/script&gt; where&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt; \alpha ::= a? \mid a! \mid \varepsilon &lt;/script&gt;

&lt;p&gt;and &lt;script type=&quot;math/tex&quot;&gt;\overline{a?} \triangleq a!&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;\overline{a!} \triangleq a?&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt; \overline{\varepsilon} \triangleq \varepsilon&lt;/script&gt;. (&lt;script type=&quot;math/tex&quot;&gt;P \mapsto P&#39;&lt;/script&gt; means &lt;script type=&quot;math/tex&quot;&gt;P \overset{\varepsilon}{\mapsto} P&#39;&lt;/script&gt;).&lt;/p&gt;

&lt;p&gt;We used iteration (&lt;script type=&quot;math/tex&quot;&gt;*P \equiv P \parallel *P&lt;/script&gt;) to replace recursive definitions, using a system with &lt;em&gt;sparks:&lt;/em&gt;&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;spark: &lt;script type=&quot;math/tex&quot;&gt;\$(!x;1)&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;activator: &lt;script type=&quot;math/tex&quot;&gt;*\$(?x; P(\$(!x;1)))&lt;/script&gt;&lt;/li&gt;
  &lt;li&gt;&lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; becomes &lt;script type=&quot;math/tex&quot;&gt;*\$(?x; P(\$(!x;1))) \mid \$(!x;1)&lt;/script&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Note that channel &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; is dedicated to the implementation &lt;script type=&quot;math/tex&quot;&gt;X&lt;/script&gt;. But, shouldn’t the channel &lt;script type=&quot;math/tex&quot;&gt;x&lt;/script&gt; be private to the definition? Thus, we introduce a new process (called a &lt;em&gt;channel&lt;/em&gt;):&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P ::= \cdots \mid \nu (a.P)&lt;/script&gt;

&lt;p&gt;Note that the bound channel &lt;script type=&quot;math/tex&quot;&gt;\alpha&lt;/script&gt;-varies, and&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{P =_\alpha P&#39;}
{P \equiv P&#39;}&lt;/script&gt;

&lt;p&gt;which is sorta similar to &lt;script type=&quot;math/tex&quot;&gt;\m{dcl}(e; a.m)&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;The name of the bound channel is an “unguessable secret.”&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LTS&lt;/strong&gt;: &lt;script type=&quot;math/tex&quot;&gt;P \overset{\alpha}{\underset{\Sigma}{\mapsto}} P&#39;&lt;/script&gt; where &lt;script type=&quot;math/tex&quot;&gt;\vdash_\Sigma \alpha~\m{action}&lt;/script&gt;.&lt;/p&gt;

&lt;h1 id=&quot;communication-generalizes-syncrhonization&quot;&gt;Communication (generalizes syncrhonization)&lt;/h1&gt;

&lt;p&gt;We want to communicate the values of a type. &lt;script type=&quot;math/tex&quot;&gt;\Sigma : a \sim \tau&lt;/script&gt; means that &lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt; carries values of type &lt;script type=&quot;math/tex&quot;&gt;\tau&lt;/script&gt;. To do so, we redefine our events:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;E ::= ?a(x.P) \mid !a(e; p)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;E ::= \m{rcv}[a](x.P) \mid \m{snd}[a](e;P)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\Gamma, x: \tau \vdash_{\Sigma, a \sim \tau} P~\m{process}}
{\Gamma \vdash_{\Sigma, a \sim \tau} ?a(x.P)~\m{event}}&lt;/script&gt;

&lt;p&gt;Note that they are no longer symmetric, since receiving binds, while sending does not.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\alpha ::= a!e \mid a?e \mid \varepsilon&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e~\m{val}_{\Sigma, a \sim \tau}}
{\$(!a(e;P) + E) \overset{a!e}{\underset{\Sigma, a \sim \tau}{\mapsto}} P}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\vdash_{\Sigma, a \sim \tau} e : \tau ~~~~ e~\m{val}_{\Sigma, a \sim \tau}}
{\$(?a(x.P) + E) \overset{a?e}{\underset{\Sigma, a \sim \tau}{\mapsto}} [e/x]P}&lt;/script&gt;

&lt;p&gt;We have to change &lt;script type=&quot;math/tex&quot;&gt;\nu(a.P)&lt;/script&gt; to &lt;script type=&quot;math/tex&quot;&gt;\nu(a \sim \tau.P)&lt;/script&gt;, or &lt;script type=&quot;math/tex&quot;&gt;\m{new}[\tau](a.P)&lt;/script&gt;.&lt;/p&gt;

&lt;h1 id=&quot;channel-references&quot;&gt;Channel References&lt;/h1&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\tau ::= \cdots \mid \tau~\m{chan}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
e ::= \cdots \mid \&amp;a %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
(\&amp;a)~\m{val}_{\Sigma, a \sim \tau} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\Gamma, \vdash_{\Sigma, a \sim \tau} \&amp;a : \tau~\m{chan} %]]&gt;&lt;/script&gt;

&lt;p&gt;We define new events, called a &lt;em&gt;dynamic&lt;/em&gt; receives and sends:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;E ::= \cdots \mid ??(e; x.P) \mid !!(e_1;e_2;P)&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;e_1&lt;/script&gt; evaluate to channels, and &lt;script type=&quot;math/tex&quot;&gt;e_2&lt;/script&gt; is the message to send.&lt;/p&gt;

&lt;p&gt;Our old receives and sends are &lt;em&gt;static&lt;/em&gt;, because the channels are specified.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\Gamma \vdash_\Sigma e : \tau~\m{chan} ~~~~ \Gamma, x:\tau \vdash_\Sigma P~\m{process}}
{\Gamma \vdash_\Sigma ??(e; x. P)~\m{event}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\Gamma \vdash_\Sigma e_1 : \tau~\m{chan} ~~~~ \Gamma \vdash_\Sigma e_2 : \tau ~~~~ \Gamma, x:\tau \vdash_\Sigma P~\m{process}}
{\Gamma \vdash_\Sigma !!(e_1; e_2; P)~\m{event}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \underset{\Sigma}{\mapsto} e&#39;}
{??(e;P) \overset{\varepsilon}{\underset{\Sigma}{\mapsto}} ??(e&#39;;P)}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\frac
{}
{??(\&amp;a ;P) \overset{\varepsilon}{\underset{\Sigma, a \sim \tau}{\mapsto}} ?a(x.P)} %]]&gt;&lt;/script&gt;

&lt;p&gt;So, the dynamic receive evaluates to the static receive once we get to the channel we have a reference to, and similarly for dynamic sends.&lt;/p&gt;

&lt;p&gt;Consider&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\nu b (\nu a (P \parallel Q) \parallel R)&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;P&lt;/script&gt; could have &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\$(!b(\&amp;a ; P&#39;)) %]]&gt;&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; could have &lt;script type=&quot;math/tex&quot;&gt;\$(?b(x.\$(!!(x;\m{fact}(5);R&#39;))))&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;This leads to issues (&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\overset{b!\&amp;a}{\underset{\Sigma}{\mapsto^*}} %]]&gt;&lt;/script&gt;) [&lt;em&gt;I wasn’t paying attention for a few minutes&lt;/em&gt;] that lead us to need a new principle, called &lt;em&gt;scope extrusion&lt;/em&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\nu b (\nu a (P \parallel Q) \parallel R) \equiv \nu b \nu a (P \parallel Q \parallel R)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;P \equiv \nu \Sigma\{ \$(E_1) \otimes \cdots \otimes \$(E_n) \}&lt;/script&gt;

&lt;p&gt;which looks very similar to Modernized Algol (except with &lt;script type=&quot;math/tex&quot;&gt;a_1 \hookrightarrow e_1&lt;/script&gt;). In fact, we could say that &lt;script type=&quot;math/tex&quot;&gt;a \hookrightarrow e&lt;/script&gt; means &lt;script type=&quot;math/tex&quot;&gt;\$(?\m{get}(\_) + ?\m{set}(\_))&lt;/script&gt;. [&lt;em&gt;see PFPL for filled in blanks&lt;/em&gt;]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Memory is nothing more than a bunch of processes.&lt;/strong&gt;&lt;/p&gt;
</description>
        <pubDate>Tue, 14 Apr 2015 13:22:10 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/04/14/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/04/14/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 23: Concurrency &amp; Interaction</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}
\def\a{\alpha}
\def\b{\beta}
\def\t{\tau}
$$
&lt;/div&gt;

&lt;p&gt;&lt;em&gt;Delivered by Bob Harper&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We’re going to discuss &lt;strong&gt;abstract process calculus&lt;/strong&gt;, which is derived from &lt;script type=&quot;math/tex&quot;&gt;\pi&lt;/script&gt;-calculus. The key idea is &lt;em&gt;interacting automata&lt;/em&gt;. We will introduce concurrency to Modernized Algol, creating &lt;em&gt;Concurrent Algol&lt;/em&gt;, thus applying process calculus to a “real” programming language.&lt;/p&gt;

&lt;p&gt;What is concurrency? It’s unrelated to parallelism. Instead, it’s really about &lt;em&gt;composition&lt;/em&gt;, and non-determinism (Bob Harper prefers &lt;em&gt;indeterminacy&lt;/em&gt;).&lt;/p&gt;

&lt;p&gt;Our starting point is consideration of processes as automata. One example is Milner’s vending machine. We have an automata for the vending machine &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt;, and an automata for the person using it &lt;script type=&quot;math/tex&quot;&gt;U&lt;/script&gt;. They interact concurrently (&lt;script type=&quot;math/tex&quot;&gt;V \| U&lt;/script&gt;), since the person loses money as they put it into the machine, and when the machine dispenses a drink, the person gains a drink.&lt;/p&gt;

&lt;h1 id=&quot;process-notation&quot;&gt;Process Notation&lt;/h1&gt;
&lt;p&gt;We have a primitive called &lt;script type=&quot;math/tex&quot;&gt;\m{await}(E)&lt;/script&gt;, for awaiting events. It can also be represented with &lt;script type=&quot;math/tex&quot;&gt;\$E&lt;/script&gt;. &lt;script type=&quot;math/tex&quot;&gt;?a.P&lt;/script&gt; represents receiving events. &lt;script type=&quot;math/tex&quot;&gt;P&lt;/script&gt; represents a process. &lt;script type=&quot;math/tex&quot;&gt;!a.P&lt;/script&gt; represents sending events. Note these are symmetric, in the sense that we could switch their meanings. &lt;script type=&quot;math/tex&quot;&gt;E_1 + E_2&lt;/script&gt; represents a binary sum, or a binary choice, between events. &lt;script type=&quot;math/tex&quot;&gt;0&lt;/script&gt; represents the null choice, or no choice.&lt;/p&gt;

&lt;p&gt;We can represent &lt;script type=&quot;math/tex&quot;&gt;V&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;U&lt;/script&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;V = \$(?2p.\$(!tea.V + ?2p.(\$(!coffee.V))))&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;U = \$(!2p . \$(!2p . \$(?coffee.U)))&lt;/script&gt;

&lt;p&gt;Note that these are cursive, so some equation solving is required. We want a fixed point.&lt;/p&gt;

&lt;h1 id=&quot;structural-congruence&quot;&gt;Structural Congruence&lt;/h1&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;P \equiv P&#39;&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;E \equiv E&#39;&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Structural congruence&lt;/strong&gt; is an equivalence relation that is compaible with all the constructs of the language. The idea is to treat processes and events modulo structural congruence. &lt;script type=&quot;math/tex&quot;&gt;\alpha&lt;/script&gt;-equivalence is structural equivalence. We want the order of events to not matter.&lt;/p&gt;

&lt;p&gt;We have commutivity: &lt;script type=&quot;math/tex&quot;&gt;E_1 + E_2 \equiv E_2 + E_1&lt;/script&gt;, associativity: &lt;script type=&quot;math/tex&quot;&gt;E_1 + (E_2 + E_3) \equiv (E_1 + E_2) + E_3&lt;/script&gt;, and unit &lt;script type=&quot;math/tex&quot;&gt;E + 0 \equiv E \equiv 0 + E&lt;/script&gt;. Thus, we have a commutative monoid (additivity).&lt;/p&gt;

&lt;h1 id=&quot;composition&quot;&gt;Composition&lt;/h1&gt;
&lt;p&gt;We’re going to think about of our processors as get/set servers for assignables. &lt;script type=&quot;math/tex&quot;&gt;P_1 \parallel P_2&lt;/script&gt; (or “tensor” &lt;script type=&quot;math/tex&quot;&gt;P_1 \otimes P_2&lt;/script&gt;) represents concurrrent composition. 1 represents inert composition. The order of processes doesn’t matter. This is another commutative monoid (multiplicative).&lt;/p&gt;

&lt;p&gt;The main missing thing is distributivity, so we don’t have a ring.&lt;/p&gt;

&lt;h1 id=&quot;normal-form&quot;&gt;Normal Form&lt;/h1&gt;
&lt;p&gt;Every process is sturcturally congruent to one of the form&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\$E_1 \parallel \cdots \parallel \$E_n&lt;/script&gt;

&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;n \geq 0&lt;/script&gt;. That is, it’s a bunch of automata in “a big pot of (matzoh ball) soup.” The multiplicative structure corresponds to “Brownian motion,” letting “the soup boil.”&lt;/p&gt;

&lt;h1 id=&quot;dynamicsinteraction-between-processes&quot;&gt;Dynamics—interaction between processes&lt;/h1&gt;
&lt;p&gt;We have a labelled transition system:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
P \mapsto^{\epsilon} P&#39; &amp; \alpha  ::= a? &amp; \text{receive action} \\
P \mapsto^{\alpha} P&#39; &amp; |  a! &amp; \text{send action} \\
&amp; |  \epsilon &amp; \text{null action}
\end{align} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;V \overset{2p?}{\mapsto} V&#39; \overset{2p?}{\mapsto} V&#39;&#39; \overset{coffee!}{\mapsto} V&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;V&#39; \overset{tea!}{\mapsto} V&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;U \overset{2p!}{\mapsto} U&#39; \overset{2p!}{\mapsto} \ \overset{coffee?}{\mapsto} U&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{P_1 \equiv P_1&#39; \overset{\alpha}{\mapsto} P_2&#39; \equiv P_2}
{P_1 \overset{\alpha}{\mapsto} P_2}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\$(a.P + E) \overset{a?}{\mapsto} P&lt;/script&gt;

&lt;p&gt;Note that &lt;script type=&quot;math/tex&quot;&gt;E&lt;/script&gt; is lost. A non-deterministic choice is made.&lt;/p&gt;

&lt;p&gt;The framing principle is that a process takes the same action regardless of “who’s watching.” Thus, if you have several processors, you can have two of them interact in parallel without affecting the others.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    P_1
    \overset{\alpha}{\mapsto}
    P_1&#39;
}{
    P_1 \parallel P_2 \overset{\alpha}{\mapsto} P_1&#39; \parallel P_2
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
    P_1 \overset{\alpha}{\mapsto} P_1&#39; ~~~~
    P_2 \overset{\overline{\alpha}}{\mapsto} P_2&#39;
}{
    P_1 \parallel P_2 \mapsto P_1&#39; \parallel P_2&#39;
}&lt;/script&gt;

&lt;p&gt;This rule allows for interaction. Thus, the user can get a coffee at the same time the vending machine sends a coffee.&lt;/p&gt;

&lt;h1 id=&quot;replication&quot;&gt;Replication&lt;/h1&gt;
&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;*P \equiv *P \parallel P&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;*P&lt;/script&gt; is any number of copies of &lt;script type=&quot;math/tex&quot;&gt;P&lt;/script&gt;.&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;accept recursive definitions as given&lt;/li&gt;
  &lt;li&gt;reduce to replication &amp;amp; synchronization&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The activator waits for the assert to arrive, and activates &lt;script type=&quot;math/tex&quot;&gt;P&lt;/script&gt;:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A = *\$(?a.P(\$(!a.1))) \equiv A&#39; \parallel A&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A&#39; = \$(?a.P(\$(!a.1)))&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\$(!a.1)&lt;/script&gt; is the “spark” to activate the next &lt;script type=&quot;math/tex&quot;&gt;A&lt;/script&gt;.&lt;/p&gt;
</description>
        <pubDate>Thu, 09 Apr 2015 13:30:34 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/04/09/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/04/09/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 22: Exceptions, Continuations</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}
\def\a{\alpha}
\def\b{\beta}
\def\t{\tau}
\def\emp{\cdotp}

\def\natt{\m{nat}}
\def\unit{\m{unit}}
\def\exn{\m{exn}}
\def\prove{\vdash}
\def\typet{\m{type}}

\def\fail{\m{fail}}
\renewcommand\catch[2]{\m{catch}~#1~\m{ow}~#2}

\renewcommand\raiset[2]{\m{raise}_{#1}~#2}
\renewcommand\raise[1]{\m{raise}~#1}
\renewcommand\handle[3]{\m{handle}~#1~\m{ow}~#2.#3}

\def\defeq{\overset{def}{=}}

\renewcommand\ifz[4]{\m{ifz}(#1 ; #2 ; #3 . #4)}

\renewcommand\clsfdt{\m{clsfd}}
\renewcommand\classt[1]{\m{class}(#1)}
\renewcommand\newcls[1]{\m{newcls}[#1]}
\renewcommand\mk[2]{\m{mk}(#1;#2)}
\renewcommand\isofcls[5]{\m{isofcls}(#1;#2;#3.#4;#5)}
$$
&lt;/div&gt;

&lt;h1 id=&quot;control-operators-continued&quot;&gt;Control Operators (continued)&lt;/h1&gt;

&lt;h2 id=&quot;exceptions-continued&quot;&gt;Exceptions (continued)&lt;/h2&gt;

&lt;p&gt;We introduced classified terms, which are exceptions in ML.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\t &amp; ::= \cdots \mid \clsfdt \mid \classt{\t} \\
e &amp; ::= \cdots \mid \newcls{\t} \mid \mk{e}{e} \mid \isofcls{e}{e}{x}{e}{e}
\end{align} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
\ctx \prove e : \classt{\t} \qquad \ctx \prove e&#39;:\t
}{
\ctx \prove \mk{e}{e&#39;} : \clsfdt
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
\ctx \prove e_0 : \classt{\t} \qquad \ctx \prove e_1 : \clsfdt \qquad \ctx, x : \t \prove e_2 : \t&#39; \qquad \ctx \prove e_3 : \t&#39;
}{
\ctx \prove \isofcls{e_0}{e_1}{x}{e_2}{e_3} : \t&#39;
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
\ctx \prove \t : \typet
}{
\newcls{\t} : \classt{\t}
}&lt;/script&gt;

&lt;p&gt;This system is more powerful than ML’s exceptions. Here’s a way to implement it in ML (or any language with first-class functions and references), though it would probably be more efficient as a primitive.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;n&quot;&gt;signature&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CLSFD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;sig&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clsfd&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;mk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clsfd&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;isofcls&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clsfd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;structure&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Clsfd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:&amp;gt;&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;CLSFD&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;struct&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;clsfd&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unit&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;type&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;option&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NONE&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mk&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;option&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;fn&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SOME&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;isofcls&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;r&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;option&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ref&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;c&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unit&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;unit&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;a&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;-&amp;gt;&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;:&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;&amp;#39;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;:=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NONE&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;c&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;()&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;r&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;NONE&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SOME&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;f&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;y&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Thus, we can see &lt;script type=&quot;math/tex&quot;&gt;\clsfdt&lt;/script&gt; as an abstract data type, with multiple possible implementations. One thing that must be true across all implementations is that classes must be dynamically generated.&lt;/p&gt;

&lt;h3 id=&quot;static-exceptions&quot;&gt;Static Exceptions&lt;/h3&gt;
&lt;p&gt;Crary claims static exceptions (such as those in Java) don’t work. In our terminology, static exceptions are those that have classes that can be determined statically. In theory, this lets us reason about exceptions that a piece of code may raise.&lt;/p&gt;

&lt;p&gt;However, if you have type abstraction, this doesn’t work. If &lt;code&gt;new&lt;/code&gt; returns a static class, then if you have two classes with different &lt;code&gt;&#39;a&lt;/code&gt;s, they would still have the same classes, which breaks type safety. &lt;em&gt;[My understanding of Crary’s explanation is questionable.]&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&quot;continuations&quot;&gt;Continuations&lt;/h2&gt;

&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand\contt[1]{#1~\m{cont}}
\renewcommand\letcc[3]{\m{letcc}_{#1}~#2~\m{in}~#3}
\renewcommand\throw[3]{\m{throw}_{#1}~#2~\m{to}~#3}
\renewcommand\cont[1]{\m{cont}(#1)}
$$
&lt;/div&gt;

&lt;p&gt;We’re going to talk about first-class continuations. They give you the ability to capture the “sequel” of the evaluation of the program.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\t &amp; ::= \cdots \mid \contt{\t} \\
e &amp; ::= \cdots \mid \letcc{\t}{x}{e} \mid \throw{\t}{e}{e} \mid \cont{k}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\contt{\t}&lt;/script&gt; can be thought of as a function that does something, but never returns anything we care about.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
\ctx, x : \contt{\t} \prove e: \t
}{
\ctx \prove \letcc{\t}{x}{e} : \t
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{
\ctx \prove e : \t \qquad \ctx \prove e&#39; : \contt{\t}
}{
\ctx \prove \throw{\t&#39;}{e}{e&#39;} : \t&#39;
}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[

k &gt; \letcc{\t}{x}{e} \mapsto k &gt; [\cont{k} / x] c \\
k &gt; \throw{\t}{e_1}{e_2} \mapsto k; \throw{\t}{\square}{e_2} &gt; e_1 \\
k; \throw{\t}{\square}{e_2} &lt; v \mapsto k; \throw{\t}{v}{\square} &gt; e_2 \\
k; \throw{\t}{v}{\square} &lt; \cont{k&#39;} \mapsto k&#39; &lt; v \\
 %]]&gt;&lt;/script&gt;

&lt;p&gt;Continuations let us have non-local exits. SML/NJ (but not Standard ML) has &lt;code&gt;callcc: (&#39;a cont -&amp;gt; &#39;a) -&amp;gt; &#39;a&lt;/code&gt; and &lt;code&gt;throw: &#39;a * &#39;a cont -&amp;gt; &#39;b&lt;/code&gt;. C has &lt;code&gt;setjmp&lt;/code&gt; and &lt;code&gt;longjmp&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Consider a function that computes the product of a list of &lt;code&gt;nat&lt;/code&gt;s. We might want to exit early if any of them are 0, since there’s no point in computing the product any further.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;λl : nat list .
    letcc exit in
        (fix product : nat list -&amp;gt; nat =
            λl . case l of
                nil =&amp;gt; 1
            | 0 :: _ =&amp;gt; throw 0 to exit
            | n :: t =&amp;gt; n * product t)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can use continuations for “time travel,” without the “paradoxes” that might result if had state.&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ocaml&quot; data-lang=&quot;ocaml&quot;&gt;&lt;span class=&quot;n&quot;&gt;datatype&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Large&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Small&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;size&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cont&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;fun&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;guessSize&lt;/span&gt; &lt;span class=&quot;bp&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;letcc&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;in&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Small&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;

&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;case&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;s&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;of&lt;/span&gt;
  &lt;span class=&quot;nc&quot;&gt;Large&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;disp&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;|&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Small&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;throw&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;Large&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;to&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&amp;#39;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;largedisp&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;pre&gt;&lt;code&gt;compose (f : τ&#39; -&amp;gt; τ) (k: τ cont) : τ&#39; cont =
    letcc k&#39;&#39; in throw f (letcc k&#39; in throw k&#39; to k&#39;&#39;) to k
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &lt;code&gt;k&#39;&#39;: τ&#39; cont cont&lt;/code&gt;. We can use &lt;code&gt;compose&lt;/code&gt; to implement coroutines in user space.&lt;/p&gt;

&lt;h2 id=&quot;comparing-exceptions-and-continuations&quot;&gt;Comparing Exceptions and Continuations&lt;/h2&gt;

&lt;p&gt;Neither continuations nor exceptions are more powerful than the other. The two features are incomparable. You &lt;em&gt;can&lt;/em&gt; implement exceptions with continuations and references.&lt;/p&gt;

&lt;p&gt;Exceptions actually expand the computing power of a language, because you can implement a loop, which you can’t do with just continuations. In that sense, exceptions are “more powerful.”&lt;/p&gt;

&lt;p&gt;On the other hand, with continuations, we expand the logical scope from constructive logic to classical logic. You can prove anything with loops, but that isn’t &lt;em&gt;that&lt;/em&gt; useful from a logical perspective.&lt;/p&gt;
</description>
        <pubDate>Tue, 07 Apr 2015 13:29:45 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/04/07/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/04/07/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 21: Stack Machines, Unraveling, Exceptions</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}
\def\a{\alpha}
\def\b{\beta}
\def\t{\tau}
\def\emp{\cdotp}

\def\natt{\m{nat}}
\def\unit{\m{unit}}
\def\exn{\m{exn}}

\def\fail{\m{fail}}
\renewcommand\catch[2]{\m{catch}~#1~\m{ow}~#2}

\renewcommand\raiset[2]{\m{raise}_{#1}~#2}
\renewcommand\raise[1]{\m{raise}~#1}
\renewcommand\handle[3]{\m{handle}~#1~\m{ow}~#2.#3}

\def\defeq{\overset{def}{=}}

\renewcommand\ifz[4]{\m{ifz}(#1 ; #2 ; #3 . #4)}
$$
&lt;/div&gt;

&lt;h1 id=&quot;control-operators-continued&quot;&gt;Control Operators (continued)&lt;/h1&gt;

&lt;h2 id=&quot;stack-machines-continued&quot;&gt;Stack machines (continued)&lt;/h2&gt;

&lt;p&gt;Refactoring the syntax a bit:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
k &amp; ::= \emp \mid k;~f \\
f &amp; ::= s~\square \mid \ifz{\square}{e_0}{x}{e_1} \mid \cdots \\
S &amp; ::= k &gt; e \mid k &lt; e
\end{align} %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;soundness--completeness-continued&quot;&gt;Soundness &amp;amp; Completeness (continued)&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;Lemma.&lt;/strong&gt; If &lt;script type=&quot;math/tex&quot;&gt;e \Downarrow v&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\forall k. k &gt; e \mapsto^* k &lt; v %]]&gt;&lt;/script&gt;.&lt;/p&gt;

&lt;h2 id=&quot;unraveling-reraveling&quot;&gt;Unraveling (Reraveling)&lt;/h2&gt;

&lt;p&gt;For any state &lt;script type=&quot;math/tex&quot;&gt;s&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;s^*&lt;/script&gt; is a term.&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;(k &gt; e)^* \defeq k[e]&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
(k &lt; e)^* \defeq k[e] %]]&gt;&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;\emp[e] \defeq e&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;(k; s \square)[e] \defeq k[s(e)]&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;(k; \ifz{\square}{e_0}{x}{e_1})[e] = k[\ifz{e}{e_0}{x}{e_1}]&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;(k; \square e_2)[e] = k[e~e_2]&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;(k; v_1 \square)[e] = k[v_1~e]&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lemma.&lt;/strong&gt; If &lt;script type=&quot;math/tex&quot;&gt;s \mapsto s&#39;&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;s^* \mapsto^* s&#39;^*&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Proof.&lt;/strong&gt; By case analysis on &lt;script type=&quot;math/tex&quot;&gt;s \mapsto s&#39;&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Lemma.&lt;/strong&gt; If &lt;script type=&quot;math/tex&quot;&gt;e \mapsto e&#39;&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;\forall k . k[e] \mapsto k[e&#39;]&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Proof.&lt;/strong&gt; By induction on &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Consider the case &lt;script type=&quot;math/tex&quot;&gt;k = k&#39;; v \square&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;We want to show &lt;script type=&quot;math/tex&quot;&gt;(k; v \square)[e] \mapsto (k&#39;; v \square)[e&#39;]&lt;/script&gt;. Thus, we want to show &lt;script type=&quot;math/tex&quot;&gt;k&#39;[v~e] \mapsto k&#39;[v~e&#39;]&lt;/script&gt;, and so, we want &lt;script type=&quot;math/tex&quot;&gt;v~e \mapsto v~e&#39;&lt;/script&gt;. But, do we actually know that &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; is a value? It turns out this is true, but we need to codify this in an invariant.&lt;/p&gt;

&lt;p&gt;We rephrase the lemma: “if &lt;script type=&quot;math/tex&quot;&gt;e \mapsto e&#39;&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;\forall k&lt;/script&gt;, if &lt;script type=&quot;math/tex&quot;&gt;k&lt;/script&gt; is good, &lt;script type=&quot;math/tex&quot;&gt;k[e] \mapsto k[e&#39;]&lt;/script&gt;”. Note that since the book does call-by-name, we don’t have to worry about this case, since &lt;script type=&quot;math/tex&quot;&gt;v\square&lt;/script&gt; never happens.&lt;/p&gt;

&lt;h2 id=&quot;exceptions&quot;&gt;Exceptions&lt;/h2&gt;

&lt;h3 id=&quot;failcatch&quot;&gt;Fail/Catch&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e ::= \cdots \mid \fail \mid \catch{e}{e}&lt;/script&gt;

&lt;p&gt;We can interpret the &lt;script type=&quot;math/tex&quot;&gt;\m{catch}&lt;/script&gt; expression as evaluating the first expression, and if reach &lt;script type=&quot;math/tex&quot;&gt;\fail&lt;/script&gt;, we evaluate the second expression.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;k ::= \cdots \mid k; f \mid k; \catch{\square}{e}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;k &gt; \fail \mapsto k \ll&lt;/script&gt;

&lt;p&gt;where &lt;script type=&quot;math/tex&quot;&gt;\ll&lt;/script&gt; represents unwinding the stack (to find a handler for &lt;script type=&quot;math/tex&quot;&gt;\fail&lt;/script&gt;)&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;k &gt; \catch{e_1}{e_2} \mapsto k; \catch{\square}{e_2} &gt; e_1&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k; \catch{\square}{e} &lt; v \mapsto k &lt; v %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;k; \catch{\square}{e} \ll~\mapsto k &gt; e&lt;/script&gt;

&lt;p&gt;If there’s nothing to pop off the stack, then we’ll reach an error.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;k;f \ll~\mapsto k \ll&lt;/script&gt;

&lt;h3 id=&quot;raisehandle&quot;&gt;Raise/Handle&lt;/h3&gt;

&lt;p&gt;We want our exceptions to be able to carry data as well:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e ::= \cdots \mid \raiset{\t}{e} \mid \handle{e}{x}{e}&lt;/script&gt;

&lt;p&gt;We need to choose &lt;script type=&quot;math/tex&quot;&gt;\t&lt;/script&gt; to be a specific type (as part of the language definition), &lt;script type=&quot;math/tex&quot;&gt;\tau_{exn}&lt;/script&gt;, for typechecking to work. If this is just &lt;script type=&quot;math/tex&quot;&gt;\m{unit}&lt;/script&gt;, then this is basically the same as &lt;script type=&quot;math/tex&quot;&gt;\fail&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;k &gt; \raise{e} \mapsto k; \raise{\square} &gt; e&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
k; \raise{\square} &lt; v \mapsto k \ll v %]]&gt;&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;k &gt; \handle{e_1}{x}{e_2} \mapsto k; \handle{\square}{x}{e_2} &gt; e_1&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
k; \handle{\square}{x}{e_2} &lt; v \mapsto k &lt; v %]]&gt;&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;k; \handle{\square}{x}{e_2} \ll v \mapsto k &gt; [v/x]e_2&lt;/script&gt;&lt;br /&gt;
&lt;script type=&quot;math/tex&quot;&gt;k;f \ll v \mapsto k \ll v&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;For proof of type safety, look in &lt;em&gt;PFPL&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Now, let’s consider what &lt;script type=&quot;math/tex&quot;&gt;\tau_{exn}&lt;/script&gt; should be.&lt;/p&gt;

&lt;p&gt;Strings are possible (older versions of ML did this), but require serialization and deserialization, which isn’t great.&lt;/p&gt;

&lt;p&gt;Ints are used in C, but you’re limited to a fixed mapping of integers to exceptions. You &lt;em&gt;could&lt;/em&gt; use Gödel numberings, but no one actually wants that.&lt;/p&gt;

&lt;p&gt;We could do &lt;script type=&quot;math/tex&quot;&gt;\unit + \unit + \unit + \m{string} + \unit + \cdots \unit&lt;/script&gt;, where we map each layer of the sum to a different exception. This can be pattern matched on, but is pretty silly.&lt;/p&gt;

&lt;p&gt;Instead, (and modern ML does this) we use the extensible type &lt;script type=&quot;math/tex&quot;&gt;\exn&lt;/script&gt;. According to Crary’s revisionist history, &lt;script type=&quot;math/tex&quot;&gt;\exn&lt;/script&gt; stands for “extensible,” &lt;strong&gt;not&lt;/strong&gt; exception. We can add to this type with the syntax &lt;script type=&quot;math/tex&quot;&gt;\m{extension}~\m{Foo}&lt;/script&gt;.&lt;/p&gt;
</description>
        <pubDate>Thu, 02 Apr 2015 13:26:59 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/04/02/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/04/02/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 20: Futures, Control Operators</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}
\def\a{\alpha}
\def\b{\beta}
\def\t{\tau}

\def\natt{\m{nat}}
\def\boolt{\m{bool}}
\def\unitt{\m{unit}}
\def\voidt{\m{void}}

\def\unit{\langle \rangle}

\def\tt{\m{true}}
\def\ff{\m{false}}

\def\prove{\vdash}

\renewcommand\fun[3]{\lambda #1 : #2 . #3}
\renewcommand\Fun[2]{\Lambda #1 . #2}

\renewcommand\let[3]{\m{let}~#1 = #2~\m{in}~#3}

\def\typet{\m{type}}
\renewcommand\type[1]{#1 : \typet}

\renewcommand\allt[2]{\forall #1.#2}
\renewcommand\prodt[2]{#1 \times #2}
\renewcommand\pair[2]{\langle #1, #2 \rangle}
\renewcommand\App[2]{#1[#2]}
\renewcommand\subst[3]{[#1 / #2] #3}

\renewcommand\existst[2]{\exists #1.#2}
\renewcommand\pack[4]{\m{pack}~[#1,#2]~\m{as}~\exists #3.#4}
\renewcommand\open[4]{\m{open}~[#1,#2] = #3~\m{in}~#4}

\def\defeq{\overset{def}{=}}

\renewcommand\par[5]{\m{par}~#1=#2 \m{ and } #3=#4 \m{ in } #5}
\renewcommand\val[1]{#1~\m{val}}
\def\mapstos{\mapsto_{\m{seq}}}
\def\mapstop{\mapsto_{\m{par}}}

\renewcommand\futt[1]{#1~\m{fut}}
\renewcommand\fute[1]{\m{fut}(#1)}
\renewcommand\fsyn[1]{\m{fsyn}(#1)}
$$
&lt;/div&gt;

&lt;h1 id=&quot;parallelism-continued&quot;&gt;Parallelism (continued)&lt;/h1&gt;

&lt;h2 id=&quot;implicit-parallelism-theorem&quot;&gt;Implicit Parallelism Theorem&lt;/h2&gt;
&lt;p&gt;For all values &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;e \mapstos^* v \iff e \mapstop^* v&lt;/script&gt;.&lt;/p&gt;

&lt;h2 id=&quot;futures&quot;&gt;Futures&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\t &amp; ::= \cdots \mid \futt{\t} \\
e &amp; ::= \cdots \mid \fute{e} \mid \fsyn{e}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\fsyn{e}&lt;/script&gt; is used to synchronize a future and thereby get its actual value.&lt;/p&gt;

&lt;p&gt;We can define nested parallelism with futures:&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\par{x_1}{e_1}{x_2}{e_2} \defeq \let{x_1&#39;}{\fute{e_1}}{
    \let{x_2}{e_2}{
        \let{x_1}{\fsyn{x_1&#39;}}{e}
    }
}&lt;/script&gt;

&lt;h3 id=&quot;statics&quot;&gt;Statics&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \prove e : \t}
{\ctx \prove \fute{e} : \futt{\t}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \prove e : \futt{\t}}
{\ctx \prove \fsyn{e} : \t}&lt;/script&gt;

&lt;h3 id=&quot;sequential-dynamics&quot;&gt;Sequential Dynamics&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\val{e}}
{\val{\fute{e}}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \mapstos e&#39;}
{\fute{e} \mapstos \fute{e&#39;}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e \mapstos e&#39;}
{\fsyn{e} \mapstos \fsyn{e&#39;}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\val{e}}
{\fsyn{\fute{e}} \mapstos e}&lt;/script&gt;

&lt;h3 id=&quot;pipelining&quot;&gt;Pipelining&lt;/h3&gt;

&lt;p&gt;Consider a situation where a &lt;em&gt;producer&lt;/em&gt; builds a list where elements represent units of works. This can easily be programming with a future list.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[See p.395 of PFPL]&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&quot;speculations&quot;&gt;Speculations&lt;/h3&gt;

&lt;p&gt;Speculations are the by-name version of futures.&lt;/p&gt;

&lt;h3 id=&quot;cost-dynamics--brents-theorem&quot;&gt;Cost Dynamics / Brent’s Theorem&lt;/h3&gt;

&lt;p&gt;Work/span analysis.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[Will be covered in recitation]&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&quot;control-operators&quot;&gt;Control Operators&lt;/h1&gt;
&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}
\def\a{\alpha}
\def\b{\beta}
\def\t{\tau}

\def\natt{\m{nat}}

\renewcommand\ifz[4]{\m{ifz}(#1 ; #2 ; #3 . #4)}
$$
&lt;/div&gt;

&lt;ul&gt;
  &lt;li&gt;Exceptions&lt;/li&gt;
  &lt;li&gt;Continuations&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;stack-machines&quot;&gt;Stack machines&lt;/h2&gt;
&lt;p&gt;We want to store &lt;em&gt;where we are in an expression&lt;/em&gt;. Note that we’re doing call-by-value, and the book does call-by-name.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
k &amp; ::= \cdotp \mid k;s~\square \mid k;\ifz{\square}{e_0}{x}{e_1} \mid \cdots \\
S &amp; ::= k &gt; e \mid k &lt; e
\end{align} %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k &gt; z \mapsto k &lt; z %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;k &gt; s(e) \mapsto k; s~\square &gt; e&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k; s~\square &lt; v \mapsto k &lt; s(v) %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;k &gt; \ifz{e}{e_0}{x}{e_1} \mapsto k; \ifz{\square}{e_0}{x}{e_1}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k; \ifz{\square}{e_0}{x}{e_1} &lt; z \mapsto k &gt; e_0 %]]&gt;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
k; \ifz{\square}{e_0}{x}{e_1} &lt; s(v) \mapsto k &gt; [v / x] e_1 %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;soundness--completeness&quot;&gt;Soundness &amp;amp; Completeness&lt;/h3&gt;

&lt;h4 id=&quot;soundness&quot;&gt;Soundness&lt;/h4&gt;
&lt;p&gt;If &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\cdotp &gt; e \mapsto^* \cdotp &lt; v %]]&gt;&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;e \mapsto^*&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\val{v}&lt;/script&gt;.&lt;/p&gt;

&lt;h4 id=&quot;completeness&quot;&gt;Completeness&lt;/h4&gt;
&lt;p&gt;If &lt;script type=&quot;math/tex&quot;&gt;e \mapsto^* v&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\val{v}&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
\cdotp &gt; e \mapsto^* \cdotp &lt; v %]]&gt;&lt;/script&gt;.&lt;/p&gt;
</description>
        <pubDate>Tue, 31 Mar 2015 13:33:22 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/03/31/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/03/31/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
      <item>
        <title>15-312 Lecture 19: Representation Independence, Parallelism</title>
        <description>&lt;div style=&quot;display:none&quot;&gt;
$$
\renewcommand{\m}[1]{\textsf{#1}}
\def\ctx{\Gamma}
\def\sig{\Sigma}
\def\qquad{~~~~}
\def\a{\alpha}
\def\b{\beta}
\def\t{\tau}

\def\natt{\m{nat}}
\def\boolt{\m{bool}}
\def\unitt{\m{unit}}
\def\voidt{\m{void}}

\def\unit{\langle \rangle}

\def\tt{\m{true}}
\def\ff{\m{false}}

\def\prove{\vdash}

\renewcommand\fun[3]{\lambda #1 : #2 . #3}
\renewcommand\Fun[2]{\Lambda #1 . #2}

\def\typet{\m{type}}
\renewcommand\type[1]{#1 : \typet}

\renewcommand\allt[2]{\forall #1.#2}
\renewcommand\prodt[2]{#1 \times #2}
\renewcommand\pair[2]{\langle #1, #2 \rangle}
\renewcommand\App[2]{#1[#2]}
\renewcommand\subst[3]{[#1 / #2] #3}

\renewcommand\existst[2]{\exists #1.#2}
\renewcommand\pack[4]{\m{pack}~[#1,#2]~\m{as}~\exists #3.#4}
\renewcommand\open[4]{\m{open}~[#1,#2] = #3~\m{in}~#4}

\def\defeq{\overset{def}{=}}

\renewcommand\par[5]{\m{par}~#1=#2 \m{ and } #3=#4 \m{ in } #5}
\renewcommand\val[1]{#1~\m{val}}
\def\mapstos{\mapsto_{\m{seq}}}
\def\mapstop{\mapsto_{\m{par}}}
$$
&lt;/div&gt;

&lt;h1 id=&quot;representation-independence--abstraction-theoremhttpwwwandrewcmueducourse15-312notesmar-20pdf-continued&quot;&gt;&lt;a href=&quot;http://www.andrew.cmu.edu/course/15-312/notes/mar-20.pdf&quot;&gt;Representation Independence / Abstraction Theorem&lt;/a&gt; (continued)&lt;/h1&gt;

&lt;h2 id=&quot;equivalence-continued&quot;&gt;Equivalence (continued)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;Lemma&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;If &lt;script type=&quot;math/tex&quot;&gt;M,M&#39; : \exists{\a}{\t}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;M = \pack{\sigma}{e}{\a}{\t}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;M&#39; = \pack{\sigma&#39;}{e&#39;}{\a}{\t}&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;R : \sigma \to \sigma&#39;&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; is closed under equivalence and &lt;script type=&quot;math/tex&quot;&gt;e \sim e&#39; : \subst{R}{\a}{\t}&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;M \sim M&#39; : \existst{\a}{\t}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Proof&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;Suppose &lt;script type=&quot;math/tex&quot;&gt;M,M&#39; : \exists{\a}{\t}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;M = \pack{\sigma}{e}{\a}{\t}&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;M&#39; = \pack{\sigma&#39;}{e&#39;}{\a}{\t}&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;R : \sigma \to \sigma&#39;&lt;/script&gt; such that &lt;script type=&quot;math/tex&quot;&gt;R&lt;/script&gt; is closed under equivalence and &lt;script type=&quot;math/tex&quot;&gt;e \sim e&#39; : \subst{R}{\a}{\t}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;We want to show that &lt;script type=&quot;math/tex&quot;&gt;M \sim M&#39; : \allt{\beta}{(\allt{\a}{\t \to \b}) \to \b}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Suppose &lt;script type=&quot;math/tex&quot;&gt;\rho, \rho&#39; : \typet&lt;/script&gt;, &lt;script type=&quot;math/tex&quot;&gt;Q : \rho \leftrightarrow \rho&#39;&lt;/script&gt;, and &lt;script type=&quot;math/tex&quot;&gt;Q&lt;/script&gt; is closed under equivalence.&lt;/p&gt;

&lt;p&gt;We want to show &lt;script type=&quot;math/tex&quot;&gt;\App{M}{\rho} \sim \App{M&#39;}{\rho&#39;} : (\allt{\a}{\t \to Q}) \to Q&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;Suppose &lt;script type=&quot;math/tex&quot;&gt;f \sim f&#39; : \allt{\a}{\t \to Q}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;We want to show &lt;script type=&quot;math/tex&quot;&gt;\App{M}{\rho}f \sim \App{M&#39;}{\rho&#39;}f&#39; : Q&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;We want to show that &lt;script type=&quot;math/tex&quot;&gt;\App{M}{\rho}f~~Q~~\App{M&#39;}{\rho&#39;}f&#39;&lt;/script&gt;.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\App{(\Fun{\b}{\lambda g . \App{g}{\sigma}e})}{\rho}f \mapsto^* \App{f}{\sigma}e&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\App{(\Fun{\b}{\lambda g . \App{g}{\sigma&#39;}e&#39;})}{\rho&#39;}f&#39; \mapsto^* \App{f&#39;}{\sigma&#39;}e&#39;&lt;/script&gt;

&lt;p&gt;We want to show that &lt;script type=&quot;math/tex&quot;&gt;\App{f}{\sigma}e~~Q~~\App{f&#39;}{\sigma&#39;}e&#39;&lt;/script&gt;.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\App{f}{\sigma} \sim \App{f&#39;}{\sigma&#39;} : \subst{R}{\a}{(\t \to Q)}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\therefore \App{f}{\sigma} \sim \App{f&#39;}{\sigma&#39;} : Q&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\therefore \App{f}{\sigma}e~~Q~~\App{f&#39;}{\sigma&#39;}e&#39;&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\blacksquare&lt;/script&gt;

&lt;p&gt;&lt;strong&gt;Theorem&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;If &lt;script type=&quot;math/tex&quot;&gt;e : \allt{\a}{\a \to \a}&lt;/script&gt;, then &lt;script type=&quot;math/tex&quot;&gt;e \cong \Fun{\a}{\fun{x}{\a}{x}} : \allt{\a}{\a \to \a}&lt;/script&gt;.&lt;/p&gt;

&lt;p&gt;This theorem states that we can still have &lt;script type=&quot;math/tex&quot;&gt;\unitt&lt;/script&gt;.&lt;/p&gt;

&lt;h1 id=&quot;parallelism&quot;&gt;Parallelism&lt;/h1&gt;

&lt;p&gt;Thus far, we’ve been focusing on &lt;em&gt;small-step evaluation&lt;/em&gt;, &lt;script type=&quot;math/tex&quot;&gt;e \mapsto e&#39;&lt;/script&gt;, where each step is a small, atomic operation. We’ve also encountered &lt;em&gt;large-step evaluation&lt;/em&gt;, &lt;script type=&quot;math/tex&quot;&gt;e \Downarrow v&lt;/script&gt;, where &lt;script type=&quot;math/tex&quot;&gt;e&lt;/script&gt; evaluates to the value &lt;script type=&quot;math/tex&quot;&gt;v&lt;/script&gt; after a number of small steps: &lt;script type=&quot;math/tex&quot;&gt;e \mapsto^* v \wedge v~\m{val} \iff e \Downarrow v&lt;/script&gt;.&lt;/p&gt;

&lt;h2 id=&quot;nested-parallelism&quot;&gt;Nested Parallelism&lt;/h2&gt;

&lt;p&gt;This terminology is still non-standard, but Crary believes it should and will be.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Parallelism &lt;script type=&quot;math/tex&quot;&gt;\neq&lt;/script&gt; concurrency.&lt;/strong&gt; Parallelism is deterministic–we want to run a computation on multiple processors to improve efficiency, but there is one, deterministic result that is the result of the computation. Concurrency is nondeterministic.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Nested parallelism&lt;/em&gt; is also known as &lt;em&gt;fork-join parallelism&lt;/em&gt;.&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;e ::= \cdots \mid \par{x_1}{e_1}{x_2}{e_2}{e}&lt;/script&gt;

&lt;h3 id=&quot;statics&quot;&gt;Statics&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\ctx \prove e_1 : \t_1 \qquad \ctx \prove e_2 : \t_2 \qquad \ctx, x_1 : \t_1, x_2 : \t_2 \prove e : \t}
{\ctx \prove \par{x_1}{e_1}{x_2}{e_2}{e} : \tau}&lt;/script&gt;

&lt;h3 id=&quot;dynamics&quot;&gt;Dynamics&lt;/h3&gt;

&lt;p&gt;Let’s pretend our construct isn’t parallel, and just evaluate the two expressions sequentially.&lt;/p&gt;

&lt;h4 id=&quot;sequential&quot;&gt;Sequential&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e_1 \mapsto e_1&#39;}
{\par{x_1}{e_1}{x_2}{e_2}{e} \mapsto \par{x_1}{e_1&#39;}{x_2}{e_2}{e}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\val{e_1} \qquad e_2 \mapsto e_2&#39;}
{\par{x_1}{e_1}{x_2}{e_2}{e} \mapsto \par{x_1}{e_1}{x_2}{e_2&#39;}{e}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\val{e_1} \qquad \val{e_2}}
{\par{x_1}{e_1}{x_2}{e_2}{e} \mapsto \subst{e_1~e_2}{x_1~x_2}{e}}&lt;/script&gt;

&lt;p&gt;If we can show the actual implementation works like this, we can reason about our parallel code the same way we’ve reasoned about sequential code, which greatly simplifies analysis.&lt;/p&gt;

&lt;p&gt;We will make the distinction between &lt;script type=&quot;math/tex&quot;&gt;\mapstos&lt;/script&gt; and &lt;script type=&quot;math/tex&quot;&gt;\mapstop&lt;/script&gt;.&lt;/p&gt;

&lt;h4 id=&quot;parallel&quot;&gt;Parallel&lt;/h4&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e_1 \mapstop e_1&#39; \qquad e_2 \mapstop e_2&#39;}
{\par{x_1}{e_1}{x_2}{e_2}{e} \mapstop \par{x_1}{e_1&#39;}{x_2}{e_2&#39;}{e}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\val{e_1} \qquad e_2 \mapstop e_2&#39;}
{\par{x_1}{e_1}{x_2}{e_2}{e} \mapstop \par{x_1}{e_1}{x_2}{e_2&#39;}{e}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{e_1 \mapstop e_1&#39; \qquad \val{e_2}}
{\par{x_1}{e_1}{x_2}{e_2}{e} \mapstop \par{x_1}{e_1&#39;}{x_2}{e_2}{e}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac
{\val{e_1} \qquad \val{e_2}}
{\par{x_1}{e_1}{x_2}{e_2}{e} \mapstop \subst{e_1~e_2}{x_1~x_2}{e}}&lt;/script&gt;
</description>
        <pubDate>Thu, 26 Mar 2015 13:25:50 -0400</pubDate>
        <link>http://www.tomshen.me/notes/cmu/15312/2015/03/26/</link>
        <guid isPermaLink="true">http://www.tomshen.me/notes/cmu/15312/2015/03/26/</guid>
        
        
        <category>cmu</category>
        
        <category>15312</category>
        
      </item>
    
  </channel>
</rss>
